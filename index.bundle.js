/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["testpackage"] = factory();
	else
		root["TEST"] = factory();
})((typeof self!='undefined'?self:this), function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../node_modules/@alt1/base/dist/alt1api.js":
/*!**************************************************!*\
  !*** ../node_modules/@alt1/base/dist/alt1api.js ***!
  \**************************************************/
/***/ (() => {

"use strict";
eval("\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BhbHQxL2Jhc2UvZGlzdC9hbHQxYXBpLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vVEVTVC8uLi9ub2RlX21vZHVsZXMvQGFsdDEvYmFzZS9kaXN0L2FsdDFhcGkuanM/YWJjZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/@alt1/base/dist/alt1api.js\n");

/***/ }),

/***/ "../node_modules/@alt1/base/dist/declarations.js":
/*!*******************************************************!*\
  !*** ../node_modules/@alt1/base/dist/declarations.js ***!
  \*******************************************************/
/***/ (() => {

"use strict";
eval("\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BhbHQxL2Jhc2UvZGlzdC9kZWNsYXJhdGlvbnMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9URVNULy4uL25vZGVfbW9kdWxlcy9AYWx0MS9iYXNlL2Rpc3QvZGVjbGFyYXRpb25zLmpzP2JiMGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/@alt1/base/dist/declarations.js\n");

/***/ }),

/***/ "../node_modules/@alt1/base/dist/imagedata-extensions.js":
/*!***************************************************************!*\
  !*** ../node_modules/@alt1/base/dist/imagedata-extensions.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ImageData\": () => (/* binding */ ImageData)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ \"../node_modules/@alt1/base/dist/index.js\");\n/* harmony import */ var _nodepolyfill_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nodepolyfill.js */ \"../node_modules/@alt1/base/dist/nodepolyfill.js\");\n\r\n\r\n//export this so node.js can also use it\r\nvar ImageData;\r\n// //TODO revamp this madness a bit?\r\n// (function () {\r\n// \tvar globalvar = (typeof self != \"undefined\" ? self : (typeof (global as any) != \"undefined\" ? (global as any) : null)) as any;\r\n// \t//use the node-canvas version when on node\r\n// \tif (typeof globalvar.ImageData == \"undefined\") {\r\n// \t\tlet nodecnv = requireNodeCanvas();\r\n// \t\tglobalvar.ImageData = nodecnv.ImageData;\r\n// \t}\r\n// \tvar fill = typeof globalvar.ImageData == \"undefined\";\r\n// \t//should never be reach anymore\r\n// \tvar constr = function (this: any) {\r\n// \t\tvar i = 0;\r\n// \t\tvar data = (arguments[i] instanceof Uint8ClampedArray ? arguments[i++] : null);\r\n// \t\tvar width = arguments[i++];\r\n// \t\tvar height = arguments[i++];\r\n// \t\tif (fill) {\r\n// \t\t\tif (!data) { data = new Uint8ClampedArray(width * height * 4); }\r\n// \t\t\tthis.width = width;\r\n// \t\t\tthis.height = height;\r\n// \t\t\tthis.data = data;\r\n// \t\t}\r\n// \t\telse if (oldconstr) {\r\n// \t\t\treturn (data ? new oldconstr(data, width, height) : new oldconstr(width, height));\r\n// \t\t} else {\r\n// \t\t\tvar canvas = document.createElement('canvas');\r\n// \t\t\tcanvas.width = width;\r\n// \t\t\tcanvas.height = height;\r\n// \t\t\tvar ctx = canvas.getContext(\"2d\")!;\r\n// \t\t\tvar imageData = ctx.createImageData(width, height);\r\n// \t\t\tif (data) { imageData.data.set(data); }\r\n// \t\t\treturn imageData;\r\n// \t\t}\r\n// \t}\r\n// \tvar oldconstr = globalvar.ImageData;\r\n// \tif (typeof document != \"undefined\") {\r\n// \t\ttry {\r\n// \t\t\tnew oldconstr(1, 1);\r\n// \t\t} catch (e) {\r\n// \t\t\t//direct constructor call not allowed in ie\r\n// \t\t\toldconstr = null;\r\n// \t\t}\r\n// \t}\r\n// \tif (!fill) { constr.prototype = globalvar.ImageData.prototype; }\r\n// \tglobalvar.ImageData = constr;\r\n// \tImageData = constr as any;\r\n// })();\r\n(function () {\r\n    var globalvar = (typeof self != \"undefined\" ? self : (typeof global != \"undefined\" ? global : null));\r\n    var filltype = typeof globalvar.ImageData == \"undefined\" || typeof globalvar.document == \"undefined\";\r\n    var fillconstr = filltype;\r\n    if (!filltype) {\r\n        var oldconstr = globalvar.ImageData;\r\n        try {\r\n            let data = new Uint8ClampedArray(4);\r\n            data[0] = 1;\r\n            let a = new globalvar.ImageData(data, 1, 1);\r\n            fillconstr = a.data[0] != 1;\r\n        }\r\n        catch (e) {\r\n            fillconstr = true;\r\n        }\r\n    }\r\n    if (fillconstr) {\r\n        var constr = function ImageDataShim() {\r\n            var i = 0;\r\n            var data = (arguments[i] instanceof Uint8ClampedArray ? arguments[i++] : null);\r\n            var width = arguments[i++];\r\n            var height = arguments[i++];\r\n            if (filltype) {\r\n                if (!data) {\r\n                    data = new Uint8ClampedArray(width * height * 4);\r\n                }\r\n                this.width = width;\r\n                this.height = height;\r\n                this.data = data;\r\n            }\r\n            else if (fillconstr) {\r\n                //WARNING This branch of code does not use the same pixel data backing store\r\n                //(problem with wasm, however all wasm browser have a native constructor (unless asm.js is used))\r\n                var canvas = document.createElement('canvas');\r\n                canvas.width = width;\r\n                canvas.height = height;\r\n                var ctx = canvas.getContext(\"2d\");\r\n                var imageData = ctx.createImageData(width, height);\r\n                if (data) {\r\n                    imageData.data.set(data);\r\n                }\r\n                return imageData;\r\n            }\r\n            // else {\r\n            // \t//oh no...\r\n            // \t//we need this monstrocity in order to call the native constructor with variable number of args\r\n            // \t//when es5 transpile is enable (that strips the spread operator)\r\n            // \treturn new (Function.prototype.bind.apply(oldconstr, [null,...arguments]));\r\n            // }\r\n        };\r\n        if (!filltype) {\r\n            constr.prototype = globalvar.ImageData.prototype;\r\n        }\r\n        globalvar.ImageData = constr;\r\n        ImageData = constr;\r\n    }\r\n    else {\r\n        ImageData = globalvar.ImageData;\r\n    }\r\n})();\r\n//Recast into a drawable imagedata class on all platforms, into a normal browser ImageData on browsers or a node-canvas imagedata on nodejs\r\nImageData.prototype.toDrawableData = function () {\r\n    if (typeof document == \"undefined\") {\r\n        return _nodepolyfill_js__WEBPACK_IMPORTED_MODULE_1__.imageDataToDrawable(this);\r\n    }\r\n    else {\r\n        return this;\r\n    }\r\n};\r\nImageData.prototype.putImageData = function (buf, cx, cy) {\r\n    for (var dx = 0; dx < buf.width; dx++) {\r\n        for (var dy = 0; dy < buf.height; dy++) {\r\n            var i1 = (dx + cx) * 4 + (dy + cy) * 4 * this.width;\r\n            var i2 = dx * 4 + dy * 4 * buf.width;\r\n            this.data[i1] = buf.data[i2];\r\n            this.data[i1 + 1] = buf.data[i2 + 1];\r\n            this.data[i1 + 2] = buf.data[i2 + 2];\r\n            this.data[i1 + 3] = buf.data[i2 + 3];\r\n        }\r\n    }\r\n};\r\nImageData.prototype.pixelOffset = function (x, y) {\r\n    return x * 4 + y * this.width * 4;\r\n};\r\n//creates a hash of a portion of the buffer used to check for changes\r\nImageData.prototype.getPixelHash = function (rect) {\r\n    if (!rect) {\r\n        rect = new _index_js__WEBPACK_IMPORTED_MODULE_0__.Rect(0, 0, this.width, this.height);\r\n    }\r\n    var hash = 0;\r\n    for (var x = rect.x; x < rect.x + rect.width; x++) {\r\n        for (var y = rect.y; y < rect.y + rect.height; y++) {\r\n            var i = x * 4 + y * 4 * this.width;\r\n            hash = (((hash << 5) - hash) + this.data[i]) | 0;\r\n            hash = (((hash << 5) - hash) + this.data[i + 1]) | 0;\r\n            hash = (((hash << 5) - hash) + this.data[i + 2]) | 0;\r\n            hash = (((hash << 5) - hash) + this.data[i + 3]) | 0;\r\n        }\r\n    }\r\n    return hash;\r\n};\r\nImageData.prototype.clone = function (rect) {\r\n    return this.toImage(rect).getContext(\"2d\").getImageData(0, 0, rect.width, rect.height);\r\n};\r\nImageData.prototype.show = function (x = 5, y = 5, zoom = 1) {\r\n    if (typeof document == \"undefined\") {\r\n        console.error(\"need a document to show an imagedata object\");\r\n        return;\r\n    }\r\n    var imgs = document.getElementsByClassName(\"debugimage\");\r\n    while (imgs.length > ImageData.prototype.show.maxImages) {\r\n        imgs[0].remove();\r\n    }\r\n    var el = this.toImage();\r\n    el.classList.add(\"debugimage\");\r\n    el.style.position = \"absolute\";\r\n    el.style.zIndex = \"1000\";\r\n    el.style.left = x / zoom + \"px\";\r\n    el.style.top = y / zoom + \"px\";\r\n    el.style.background = \"purple\";\r\n    el.style.cursor = \"pointer\";\r\n    el.style.imageRendering = \"pixelated\";\r\n    el.style.outline = \"1px solid #0f0\";\r\n    el.style.width = (this.width == 1 ? 100 : this.width) * zoom + \"px\";\r\n    el.style.height = (this.height == 1 ? 100 : this.height) * zoom + \"px\";\r\n    el.onclick = function () { el.remove(); };\r\n    document.body.appendChild(el);\r\n    return el;\r\n};\r\nImageData.prototype.show.maxImages = 10;\r\nImageData.prototype.toImage = function (rect) {\r\n    if (!rect) {\r\n        rect = new _index_js__WEBPACK_IMPORTED_MODULE_0__.Rect(0, 0, this.width, this.height);\r\n    }\r\n    if (typeof document != \"undefined\") {\r\n        var el = document.createElement(\"canvas\");\r\n        el.width = rect.width;\r\n        el.height = rect.height;\r\n    }\r\n    else {\r\n        el = _nodepolyfill_js__WEBPACK_IMPORTED_MODULE_1__.createCanvas(rect.width, rect.height);\r\n    }\r\n    var ctx = el.getContext(\"2d\");\r\n    ctx.putImageData(this.toDrawableData(), -rect.x, -rect.y);\r\n    return el;\r\n};\r\nImageData.prototype.getPixel = function (x, y) {\r\n    var i = x * 4 + y * 4 * this.width;\r\n    return [this.data[i], this.data[i + 1], this.data[i + 2], this.data[i + 3]];\r\n};\r\nImageData.prototype.getPixelValueSum = function (x, y) {\r\n    var i = x * 4 + y * 4 * this.width;\r\n    return this.data[i] + this.data[i + 1] + this.data[i + 2];\r\n};\r\nImageData.prototype.getPixelInt = function (x, y) {\r\n    var i = x * 4 + y * 4 * this.width;\r\n    return (this.data[i + 3] << 24) + (this.data[i + 0] << 16) + (this.data[i + 1] << 8) + (this.data[i + 2] << 0);\r\n};\r\nImageData.prototype.getColorDifference = function (x, y, r, g, b, a = 255) {\r\n    var i = x * 4 + y * 4 * this.width;\r\n    return Math.abs(this.data[i] - r) + Math.abs(this.data[i + 1] - g) + Math.abs(this.data[i + 2] - b) * a / 255;\r\n};\r\nImageData.prototype.setPixel = function (x, y, ...color) {\r\n    var r, g, b, a;\r\n    var [r, g, b, a] = (Array.isArray(color[0]) ? color[0] : color);\r\n    var i = x * 4 + y * 4 * this.width;\r\n    this.data[i] = r;\r\n    this.data[i + 1] = g;\r\n    this.data[i + 2] = b;\r\n    this.data[i + 3] = a == undefined ? 255 : a;\r\n};\r\nImageData.prototype.setPixelInt = function (x, y, color) {\r\n    var i = x * 4 + y * 4 * this.width;\r\n    this.data[i] = (color >> 24) & 0xff;\r\n    this.data[i + 1] = (color >> 16) & 0xff;\r\n    this.data[i + 2] = (color >> 8) & 0xff;\r\n    this.data[i + 3] = (color >> 0) & 0xff;\r\n};\r\nImageData.prototype.toFileBytes = function (format, quality) {\r\n    if (typeof HTMLCanvasElement != \"undefined\") {\r\n        return new Promise(d => this.toImage().toBlob(b => {\r\n            var r = new FileReader();\r\n            r.readAsArrayBuffer(b);\r\n            r.onload = () => d(new Uint8Array(r.result));\r\n        }, format, quality));\r\n    }\r\n    else {\r\n        return _nodepolyfill_js__WEBPACK_IMPORTED_MODULE_1__.imageDataToFileBytes(this, format, quality);\r\n    }\r\n};\r\nImageData.prototype.toPngBase64 = function () {\r\n    if (typeof HTMLCanvasElement != \"undefined\") {\r\n        var str = this.toImage().toDataURL(\"image/png\");\r\n        return str.slice(str.indexOf(\",\") + 1);\r\n    }\r\n    else {\r\n        throw new Error(\"synchronous image conversion not supported in nodejs, try using ImageData.prototype.toFileBytes\");\r\n    }\r\n};\r\nImageData.prototype.pixelCompare = function (buf, x = 0, y = 0, max) {\r\n    return _index_js__WEBPACK_IMPORTED_MODULE_0__.ImageDetect.simpleCompare(this, buf, x, y, max);\r\n};\r\nImageData.prototype.copyTo = function (target, sourcex, sourcey, width, height, targetx, targety) {\r\n    //convince v8 that these are 31bit uints\r\n    const targetwidth = target.width | 0;\r\n    const thiswidth = this.width | 0;\r\n    const copywidth = width | 0;\r\n    const fastwidth = Math.floor(width / 4) * 4;\r\n    const thisdata = new Int32Array(this.data.buffer, this.data.byteOffset, this.data.byteLength / 4);\r\n    const targetdata = new Int32Array(target.data.buffer, target.data.byteOffset, target.data.byteLength / 4);\r\n    for (let cy = 0; cy < height; cy++) {\r\n        let cx = 0;\r\n        let it = (cx + targetx) + (cy + targety) * targetwidth;\r\n        let is = (cx + sourcex) + (cy + sourcey) * thiswidth;\r\n        //copy 4 pixels per iter (xmm)\r\n        for (; cx < fastwidth; cx += 4) {\r\n            targetdata[it] = thisdata[is];\r\n            targetdata[it + 1] = thisdata[is + 1];\r\n            targetdata[it + 2] = thisdata[is + 2];\r\n            targetdata[it + 3] = thisdata[is + 3];\r\n            it += 4;\r\n            is += 4;\r\n        }\r\n        //copy remainder per pixel\r\n        for (; cx < copywidth; cx++) {\r\n            targetdata[it] = thisdata[is];\r\n            it += 1;\r\n            is += 1;\r\n        }\r\n    }\r\n};\r\nif (typeof HTMLImageElement != \"undefined\") {\r\n    HTMLImageElement.prototype.toBuffer = function (x = 0, y = 0, w = this.width, h = this.height) {\r\n        var cnv = document.createElement(\"canvas\");\r\n        cnv.width = w;\r\n        cnv.height = h;\r\n        var ctx = cnv.getContext(\"2d\");\r\n        ctx.drawImage(this, -x, -y);\r\n        return ctx.getImageData(0, 0, w, h);\r\n    };\r\n    HTMLImageElement.prototype.toCanvas = function (x = 0, y = 0, w = this.width, h = this.height) {\r\n        var cnv = document.createElement(\"canvas\");\r\n        cnv.width = w;\r\n        cnv.height = h;\r\n        var ctx = cnv.getContext(\"2d\");\r\n        ctx.drawImage(this, -x, -y);\r\n        return cnv;\r\n    };\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BhbHQxL2Jhc2UvZGlzdC9pbWFnZWRhdGEtZXh0ZW5zaW9ucy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBb0M7QUFDYTtBQUNqRDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUVBQStCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckMseUJBQXlCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkNBQVU7QUFDN0I7QUFDQTtBQUNBLHlCQUF5Qix5QkFBeUI7QUFDbEQsNkJBQTZCLDBCQUEwQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJDQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwwREFBd0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGVBQWUsa0VBQWdDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0VBQStCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL1RFU1QvLi4vbm9kZV9tb2R1bGVzL0BhbHQxL2Jhc2UvZGlzdC9pbWFnZWRhdGEtZXh0ZW5zaW9ucy5qcz9hOWNmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGExbGliIGZyb20gXCIuL2luZGV4LmpzXCI7XHJcbmltcG9ydCAqIGFzIG5vZGVpbXBvcnRzIGZyb20gXCIuL25vZGVwb2x5ZmlsbC5qc1wiO1xyXG4vL2V4cG9ydCB0aGlzIHNvIG5vZGUuanMgY2FuIGFsc28gdXNlIGl0XHJcbmV4cG9ydCB2YXIgSW1hZ2VEYXRhO1xyXG4vLyAvL1RPRE8gcmV2YW1wIHRoaXMgbWFkbmVzcyBhIGJpdD9cclxuLy8gKGZ1bmN0aW9uICgpIHtcclxuLy8gXHR2YXIgZ2xvYmFsdmFyID0gKHR5cGVvZiBzZWxmICE9IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogKHR5cGVvZiAoZ2xvYmFsIGFzIGFueSkgIT0gXCJ1bmRlZmluZWRcIiA/IChnbG9iYWwgYXMgYW55KSA6IG51bGwpKSBhcyBhbnk7XHJcbi8vIFx0Ly91c2UgdGhlIG5vZGUtY2FudmFzIHZlcnNpb24gd2hlbiBvbiBub2RlXHJcbi8vIFx0aWYgKHR5cGVvZiBnbG9iYWx2YXIuSW1hZ2VEYXRhID09IFwidW5kZWZpbmVkXCIpIHtcclxuLy8gXHRcdGxldCBub2RlY252ID0gcmVxdWlyZU5vZGVDYW52YXMoKTtcclxuLy8gXHRcdGdsb2JhbHZhci5JbWFnZURhdGEgPSBub2RlY252LkltYWdlRGF0YTtcclxuLy8gXHR9XHJcbi8vIFx0dmFyIGZpbGwgPSB0eXBlb2YgZ2xvYmFsdmFyLkltYWdlRGF0YSA9PSBcInVuZGVmaW5lZFwiO1xyXG4vLyBcdC8vc2hvdWxkIG5ldmVyIGJlIHJlYWNoIGFueW1vcmVcclxuLy8gXHR2YXIgY29uc3RyID0gZnVuY3Rpb24gKHRoaXM6IGFueSkge1xyXG4vLyBcdFx0dmFyIGkgPSAwO1xyXG4vLyBcdFx0dmFyIGRhdGEgPSAoYXJndW1lbnRzW2ldIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkgPyBhcmd1bWVudHNbaSsrXSA6IG51bGwpO1xyXG4vLyBcdFx0dmFyIHdpZHRoID0gYXJndW1lbnRzW2krK107XHJcbi8vIFx0XHR2YXIgaGVpZ2h0ID0gYXJndW1lbnRzW2krK107XHJcbi8vIFx0XHRpZiAoZmlsbCkge1xyXG4vLyBcdFx0XHRpZiAoIWRhdGEpIHsgZGF0YSA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpOyB9XHJcbi8vIFx0XHRcdHRoaXMud2lkdGggPSB3aWR0aDtcclxuLy8gXHRcdFx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbi8vIFx0XHRcdHRoaXMuZGF0YSA9IGRhdGE7XHJcbi8vIFx0XHR9XHJcbi8vIFx0XHRlbHNlIGlmIChvbGRjb25zdHIpIHtcclxuLy8gXHRcdFx0cmV0dXJuIChkYXRhID8gbmV3IG9sZGNvbnN0cihkYXRhLCB3aWR0aCwgaGVpZ2h0KSA6IG5ldyBvbGRjb25zdHIod2lkdGgsIGhlaWdodCkpO1xyXG4vLyBcdFx0fSBlbHNlIHtcclxuLy8gXHRcdFx0dmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4vLyBcdFx0XHRjYW52YXMud2lkdGggPSB3aWR0aDtcclxuLy8gXHRcdFx0Y2FudmFzLmhlaWdodCA9IGhlaWdodDtcclxuLy8gXHRcdFx0dmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikhO1xyXG4vLyBcdFx0XHR2YXIgaW1hZ2VEYXRhID0gY3R4LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0KTtcclxuLy8gXHRcdFx0aWYgKGRhdGEpIHsgaW1hZ2VEYXRhLmRhdGEuc2V0KGRhdGEpOyB9XHJcbi8vIFx0XHRcdHJldHVybiBpbWFnZURhdGE7XHJcbi8vIFx0XHR9XHJcbi8vIFx0fVxyXG4vLyBcdHZhciBvbGRjb25zdHIgPSBnbG9iYWx2YXIuSW1hZ2VEYXRhO1xyXG4vLyBcdGlmICh0eXBlb2YgZG9jdW1lbnQgIT0gXCJ1bmRlZmluZWRcIikge1xyXG4vLyBcdFx0dHJ5IHtcclxuLy8gXHRcdFx0bmV3IG9sZGNvbnN0cigxLCAxKTtcclxuLy8gXHRcdH0gY2F0Y2ggKGUpIHtcclxuLy8gXHRcdFx0Ly9kaXJlY3QgY29uc3RydWN0b3IgY2FsbCBub3QgYWxsb3dlZCBpbiBpZVxyXG4vLyBcdFx0XHRvbGRjb25zdHIgPSBudWxsO1xyXG4vLyBcdFx0fVxyXG4vLyBcdH1cclxuLy8gXHRpZiAoIWZpbGwpIHsgY29uc3RyLnByb3RvdHlwZSA9IGdsb2JhbHZhci5JbWFnZURhdGEucHJvdG90eXBlOyB9XHJcbi8vIFx0Z2xvYmFsdmFyLkltYWdlRGF0YSA9IGNvbnN0cjtcclxuLy8gXHRJbWFnZURhdGEgPSBjb25zdHIgYXMgYW55O1xyXG4vLyB9KSgpO1xyXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGdsb2JhbHZhciA9ICh0eXBlb2Ygc2VsZiAhPSBcInVuZGVmaW5lZFwiID8gc2VsZiA6ICh0eXBlb2YgZ2xvYmFsICE9IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiBudWxsKSk7XHJcbiAgICB2YXIgZmlsbHR5cGUgPSB0eXBlb2YgZ2xvYmFsdmFyLkltYWdlRGF0YSA9PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiBnbG9iYWx2YXIuZG9jdW1lbnQgPT0gXCJ1bmRlZmluZWRcIjtcclxuICAgIHZhciBmaWxsY29uc3RyID0gZmlsbHR5cGU7XHJcbiAgICBpZiAoIWZpbGx0eXBlKSB7XHJcbiAgICAgICAgdmFyIG9sZGNvbnN0ciA9IGdsb2JhbHZhci5JbWFnZURhdGE7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoNCk7XHJcbiAgICAgICAgICAgIGRhdGFbMF0gPSAxO1xyXG4gICAgICAgICAgICBsZXQgYSA9IG5ldyBnbG9iYWx2YXIuSW1hZ2VEYXRhKGRhdGEsIDEsIDEpO1xyXG4gICAgICAgICAgICBmaWxsY29uc3RyID0gYS5kYXRhWzBdICE9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGZpbGxjb25zdHIgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChmaWxsY29uc3RyKSB7XHJcbiAgICAgICAgdmFyIGNvbnN0ciA9IGZ1bmN0aW9uIEltYWdlRGF0YVNoaW0oKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSAoYXJndW1lbnRzW2ldIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkgPyBhcmd1bWVudHNbaSsrXSA6IG51bGwpO1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBhcmd1bWVudHNbaSsrXTtcclxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGFyZ3VtZW50c1tpKytdO1xyXG4gICAgICAgICAgICBpZiAoZmlsbHR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChmaWxsY29uc3RyKSB7XHJcbiAgICAgICAgICAgICAgICAvL1dBUk5JTkcgVGhpcyBicmFuY2ggb2YgY29kZSBkb2VzIG5vdCB1c2UgdGhlIHNhbWUgcGl4ZWwgZGF0YSBiYWNraW5nIHN0b3JlXHJcbiAgICAgICAgICAgICAgICAvLyhwcm9ibGVtIHdpdGggd2FzbSwgaG93ZXZlciBhbGwgd2FzbSBicm93c2VyIGhhdmUgYSBuYXRpdmUgY29uc3RydWN0b3IgKHVubGVzcyBhc20uanMgaXMgdXNlZCkpXHJcbiAgICAgICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuICAgICAgICAgICAgICAgIHZhciBpbWFnZURhdGEgPSBjdHguY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbWFnZURhdGEuZGF0YS5zZXQoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW1hZ2VEYXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBcdC8vb2ggbm8uLi5cclxuICAgICAgICAgICAgLy8gXHQvL3dlIG5lZWQgdGhpcyBtb25zdHJvY2l0eSBpbiBvcmRlciB0byBjYWxsIHRoZSBuYXRpdmUgY29uc3RydWN0b3Igd2l0aCB2YXJpYWJsZSBudW1iZXIgb2YgYXJnc1xyXG4gICAgICAgICAgICAvLyBcdC8vd2hlbiBlczUgdHJhbnNwaWxlIGlzIGVuYWJsZSAodGhhdCBzdHJpcHMgdGhlIHNwcmVhZCBvcGVyYXRvcilcclxuICAgICAgICAgICAgLy8gXHRyZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShvbGRjb25zdHIsIFtudWxsLC4uLmFyZ3VtZW50c10pKTtcclxuICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKCFmaWxsdHlwZSkge1xyXG4gICAgICAgICAgICBjb25zdHIucHJvdG90eXBlID0gZ2xvYmFsdmFyLkltYWdlRGF0YS5wcm90b3R5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdsb2JhbHZhci5JbWFnZURhdGEgPSBjb25zdHI7XHJcbiAgICAgICAgSW1hZ2VEYXRhID0gY29uc3RyO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgSW1hZ2VEYXRhID0gZ2xvYmFsdmFyLkltYWdlRGF0YTtcclxuICAgIH1cclxufSkoKTtcclxuLy9SZWNhc3QgaW50byBhIGRyYXdhYmxlIGltYWdlZGF0YSBjbGFzcyBvbiBhbGwgcGxhdGZvcm1zLCBpbnRvIGEgbm9ybWFsIGJyb3dzZXIgSW1hZ2VEYXRhIG9uIGJyb3dzZXJzIG9yIGEgbm9kZS1jYW52YXMgaW1hZ2VkYXRhIG9uIG5vZGVqc1xyXG5JbWFnZURhdGEucHJvdG90eXBlLnRvRHJhd2FibGVEYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgcmV0dXJuIG5vZGVpbXBvcnRzLmltYWdlRGF0YVRvRHJhd2FibGUodGhpcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufTtcclxuSW1hZ2VEYXRhLnByb3RvdHlwZS5wdXRJbWFnZURhdGEgPSBmdW5jdGlvbiAoYnVmLCBjeCwgY3kpIHtcclxuICAgIGZvciAodmFyIGR4ID0gMDsgZHggPCBidWYud2lkdGg7IGR4KyspIHtcclxuICAgICAgICBmb3IgKHZhciBkeSA9IDA7IGR5IDwgYnVmLmhlaWdodDsgZHkrKykge1xyXG4gICAgICAgICAgICB2YXIgaTEgPSAoZHggKyBjeCkgKiA0ICsgKGR5ICsgY3kpICogNCAqIHRoaXMud2lkdGg7XHJcbiAgICAgICAgICAgIHZhciBpMiA9IGR4ICogNCArIGR5ICogNCAqIGJ1Zi53aWR0aDtcclxuICAgICAgICAgICAgdGhpcy5kYXRhW2kxXSA9IGJ1Zi5kYXRhW2kyXTtcclxuICAgICAgICAgICAgdGhpcy5kYXRhW2kxICsgMV0gPSBidWYuZGF0YVtpMiArIDFdO1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFbaTEgKyAyXSA9IGJ1Zi5kYXRhW2kyICsgMl07XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVtpMSArIDNdID0gYnVmLmRhdGFbaTIgKyAzXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbkltYWdlRGF0YS5wcm90b3R5cGUucGl4ZWxPZmZzZXQgPSBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgcmV0dXJuIHggKiA0ICsgeSAqIHRoaXMud2lkdGggKiA0O1xyXG59O1xyXG4vL2NyZWF0ZXMgYSBoYXNoIG9mIGEgcG9ydGlvbiBvZiB0aGUgYnVmZmVyIHVzZWQgdG8gY2hlY2sgZm9yIGNoYW5nZXNcclxuSW1hZ2VEYXRhLnByb3RvdHlwZS5nZXRQaXhlbEhhc2ggPSBmdW5jdGlvbiAocmVjdCkge1xyXG4gICAgaWYgKCFyZWN0KSB7XHJcbiAgICAgICAgcmVjdCA9IG5ldyBhMWxpYi5SZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIHZhciBoYXNoID0gMDtcclxuICAgIGZvciAodmFyIHggPSByZWN0Lng7IHggPCByZWN0LnggKyByZWN0LndpZHRoOyB4KyspIHtcclxuICAgICAgICBmb3IgKHZhciB5ID0gcmVjdC55OyB5IDwgcmVjdC55ICsgcmVjdC5oZWlnaHQ7IHkrKykge1xyXG4gICAgICAgICAgICB2YXIgaSA9IHggKiA0ICsgeSAqIDQgKiB0aGlzLndpZHRoO1xyXG4gICAgICAgICAgICBoYXNoID0gKCgoaGFzaCA8PCA1KSAtIGhhc2gpICsgdGhpcy5kYXRhW2ldKSB8IDA7XHJcbiAgICAgICAgICAgIGhhc2ggPSAoKChoYXNoIDw8IDUpIC0gaGFzaCkgKyB0aGlzLmRhdGFbaSArIDFdKSB8IDA7XHJcbiAgICAgICAgICAgIGhhc2ggPSAoKChoYXNoIDw8IDUpIC0gaGFzaCkgKyB0aGlzLmRhdGFbaSArIDJdKSB8IDA7XHJcbiAgICAgICAgICAgIGhhc2ggPSAoKChoYXNoIDw8IDUpIC0gaGFzaCkgKyB0aGlzLmRhdGFbaSArIDNdKSB8IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhhc2g7XHJcbn07XHJcbkltYWdlRGF0YS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAocmVjdCkge1xyXG4gICAgcmV0dXJuIHRoaXMudG9JbWFnZShyZWN0KS5nZXRDb250ZXh0KFwiMmRcIikuZ2V0SW1hZ2VEYXRhKDAsIDAsIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcclxufTtcclxuSW1hZ2VEYXRhLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKHggPSA1LCB5ID0gNSwgem9vbSA9IDEpIHtcclxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJuZWVkIGEgZG9jdW1lbnQgdG8gc2hvdyBhbiBpbWFnZWRhdGEgb2JqZWN0XCIpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBpbWdzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImRlYnVnaW1hZ2VcIik7XHJcbiAgICB3aGlsZSAoaW1ncy5sZW5ndGggPiBJbWFnZURhdGEucHJvdG90eXBlLnNob3cubWF4SW1hZ2VzKSB7XHJcbiAgICAgICAgaW1nc1swXS5yZW1vdmUoKTtcclxuICAgIH1cclxuICAgIHZhciBlbCA9IHRoaXMudG9JbWFnZSgpO1xyXG4gICAgZWwuY2xhc3NMaXN0LmFkZChcImRlYnVnaW1hZ2VcIik7XHJcbiAgICBlbC5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcclxuICAgIGVsLnN0eWxlLnpJbmRleCA9IFwiMTAwMFwiO1xyXG4gICAgZWwuc3R5bGUubGVmdCA9IHggLyB6b29tICsgXCJweFwiO1xyXG4gICAgZWwuc3R5bGUudG9wID0geSAvIHpvb20gKyBcInB4XCI7XHJcbiAgICBlbC5zdHlsZS5iYWNrZ3JvdW5kID0gXCJwdXJwbGVcIjtcclxuICAgIGVsLnN0eWxlLmN1cnNvciA9IFwicG9pbnRlclwiO1xyXG4gICAgZWwuc3R5bGUuaW1hZ2VSZW5kZXJpbmcgPSBcInBpeGVsYXRlZFwiO1xyXG4gICAgZWwuc3R5bGUub3V0bGluZSA9IFwiMXB4IHNvbGlkICMwZjBcIjtcclxuICAgIGVsLnN0eWxlLndpZHRoID0gKHRoaXMud2lkdGggPT0gMSA/IDEwMCA6IHRoaXMud2lkdGgpICogem9vbSArIFwicHhcIjtcclxuICAgIGVsLnN0eWxlLmhlaWdodCA9ICh0aGlzLmhlaWdodCA9PSAxID8gMTAwIDogdGhpcy5oZWlnaHQpICogem9vbSArIFwicHhcIjtcclxuICAgIGVsLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7IGVsLnJlbW92ZSgpOyB9O1xyXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbCk7XHJcbiAgICByZXR1cm4gZWw7XHJcbn07XHJcbkltYWdlRGF0YS5wcm90b3R5cGUuc2hvdy5tYXhJbWFnZXMgPSAxMDtcclxuSW1hZ2VEYXRhLnByb3RvdHlwZS50b0ltYWdlID0gZnVuY3Rpb24gKHJlY3QpIHtcclxuICAgIGlmICghcmVjdCkge1xyXG4gICAgICAgIHJlY3QgPSBuZXcgYTFsaWIuUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG4gICAgICAgIGVsLndpZHRoID0gcmVjdC53aWR0aDtcclxuICAgICAgICBlbC5oZWlnaHQgPSByZWN0LmhlaWdodDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGVsID0gbm9kZWltcG9ydHMuY3JlYXRlQ2FudmFzKHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIHZhciBjdHggPSBlbC5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICBjdHgucHV0SW1hZ2VEYXRhKHRoaXMudG9EcmF3YWJsZURhdGEoKSwgLXJlY3QueCwgLXJlY3QueSk7XHJcbiAgICByZXR1cm4gZWw7XHJcbn07XHJcbkltYWdlRGF0YS5wcm90b3R5cGUuZ2V0UGl4ZWwgPSBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgdmFyIGkgPSB4ICogNCArIHkgKiA0ICogdGhpcy53aWR0aDtcclxuICAgIHJldHVybiBbdGhpcy5kYXRhW2ldLCB0aGlzLmRhdGFbaSArIDFdLCB0aGlzLmRhdGFbaSArIDJdLCB0aGlzLmRhdGFbaSArIDNdXTtcclxufTtcclxuSW1hZ2VEYXRhLnByb3RvdHlwZS5nZXRQaXhlbFZhbHVlU3VtID0gZnVuY3Rpb24gKHgsIHkpIHtcclxuICAgIHZhciBpID0geCAqIDQgKyB5ICogNCAqIHRoaXMud2lkdGg7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhW2ldICsgdGhpcy5kYXRhW2kgKyAxXSArIHRoaXMuZGF0YVtpICsgMl07XHJcbn07XHJcbkltYWdlRGF0YS5wcm90b3R5cGUuZ2V0UGl4ZWxJbnQgPSBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgdmFyIGkgPSB4ICogNCArIHkgKiA0ICogdGhpcy53aWR0aDtcclxuICAgIHJldHVybiAodGhpcy5kYXRhW2kgKyAzXSA8PCAyNCkgKyAodGhpcy5kYXRhW2kgKyAwXSA8PCAxNikgKyAodGhpcy5kYXRhW2kgKyAxXSA8PCA4KSArICh0aGlzLmRhdGFbaSArIDJdIDw8IDApO1xyXG59O1xyXG5JbWFnZURhdGEucHJvdG90eXBlLmdldENvbG9yRGlmZmVyZW5jZSA9IGZ1bmN0aW9uICh4LCB5LCByLCBnLCBiLCBhID0gMjU1KSB7XHJcbiAgICB2YXIgaSA9IHggKiA0ICsgeSAqIDQgKiB0aGlzLndpZHRoO1xyXG4gICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuZGF0YVtpXSAtIHIpICsgTWF0aC5hYnModGhpcy5kYXRhW2kgKyAxXSAtIGcpICsgTWF0aC5hYnModGhpcy5kYXRhW2kgKyAyXSAtIGIpICogYSAvIDI1NTtcclxufTtcclxuSW1hZ2VEYXRhLnByb3RvdHlwZS5zZXRQaXhlbCA9IGZ1bmN0aW9uICh4LCB5LCAuLi5jb2xvcikge1xyXG4gICAgdmFyIHIsIGcsIGIsIGE7XHJcbiAgICB2YXIgW3IsIGcsIGIsIGFdID0gKEFycmF5LmlzQXJyYXkoY29sb3JbMF0pID8gY29sb3JbMF0gOiBjb2xvcik7XHJcbiAgICB2YXIgaSA9IHggKiA0ICsgeSAqIDQgKiB0aGlzLndpZHRoO1xyXG4gICAgdGhpcy5kYXRhW2ldID0gcjtcclxuICAgIHRoaXMuZGF0YVtpICsgMV0gPSBnO1xyXG4gICAgdGhpcy5kYXRhW2kgKyAyXSA9IGI7XHJcbiAgICB0aGlzLmRhdGFbaSArIDNdID0gYSA9PSB1bmRlZmluZWQgPyAyNTUgOiBhO1xyXG59O1xyXG5JbWFnZURhdGEucHJvdG90eXBlLnNldFBpeGVsSW50ID0gZnVuY3Rpb24gKHgsIHksIGNvbG9yKSB7XHJcbiAgICB2YXIgaSA9IHggKiA0ICsgeSAqIDQgKiB0aGlzLndpZHRoO1xyXG4gICAgdGhpcy5kYXRhW2ldID0gKGNvbG9yID4+IDI0KSAmIDB4ZmY7XHJcbiAgICB0aGlzLmRhdGFbaSArIDFdID0gKGNvbG9yID4+IDE2KSAmIDB4ZmY7XHJcbiAgICB0aGlzLmRhdGFbaSArIDJdID0gKGNvbG9yID4+IDgpICYgMHhmZjtcclxuICAgIHRoaXMuZGF0YVtpICsgM10gPSAoY29sb3IgPj4gMCkgJiAweGZmO1xyXG59O1xyXG5JbWFnZURhdGEucHJvdG90eXBlLnRvRmlsZUJ5dGVzID0gZnVuY3Rpb24gKGZvcm1hdCwgcXVhbGl0eSkge1xyXG4gICAgaWYgKHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGQgPT4gdGhpcy50b0ltYWdlKCkudG9CbG9iKGIgPT4ge1xyXG4gICAgICAgICAgICB2YXIgciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcbiAgICAgICAgICAgIHIucmVhZEFzQXJyYXlCdWZmZXIoYik7XHJcbiAgICAgICAgICAgIHIub25sb2FkID0gKCkgPT4gZChuZXcgVWludDhBcnJheShyLnJlc3VsdCkpO1xyXG4gICAgICAgIH0sIGZvcm1hdCwgcXVhbGl0eSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG5vZGVpbXBvcnRzLmltYWdlRGF0YVRvRmlsZUJ5dGVzKHRoaXMsIGZvcm1hdCwgcXVhbGl0eSk7XHJcbiAgICB9XHJcbn07XHJcbkltYWdlRGF0YS5wcm90b3R5cGUudG9QbmdCYXNlNjQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICB2YXIgc3RyID0gdGhpcy50b0ltYWdlKCkudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpO1xyXG4gICAgICAgIHJldHVybiBzdHIuc2xpY2Uoc3RyLmluZGV4T2YoXCIsXCIpICsgMSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzeW5jaHJvbm91cyBpbWFnZSBjb252ZXJzaW9uIG5vdCBzdXBwb3J0ZWQgaW4gbm9kZWpzLCB0cnkgdXNpbmcgSW1hZ2VEYXRhLnByb3RvdHlwZS50b0ZpbGVCeXRlc1wiKTtcclxuICAgIH1cclxufTtcclxuSW1hZ2VEYXRhLnByb3RvdHlwZS5waXhlbENvbXBhcmUgPSBmdW5jdGlvbiAoYnVmLCB4ID0gMCwgeSA9IDAsIG1heCkge1xyXG4gICAgcmV0dXJuIGExbGliLkltYWdlRGV0ZWN0LnNpbXBsZUNvbXBhcmUodGhpcywgYnVmLCB4LCB5LCBtYXgpO1xyXG59O1xyXG5JbWFnZURhdGEucHJvdG90eXBlLmNvcHlUbyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZXgsIHNvdXJjZXksIHdpZHRoLCBoZWlnaHQsIHRhcmdldHgsIHRhcmdldHkpIHtcclxuICAgIC8vY29udmluY2UgdjggdGhhdCB0aGVzZSBhcmUgMzFiaXQgdWludHNcclxuICAgIGNvbnN0IHRhcmdldHdpZHRoID0gdGFyZ2V0LndpZHRoIHwgMDtcclxuICAgIGNvbnN0IHRoaXN3aWR0aCA9IHRoaXMud2lkdGggfCAwO1xyXG4gICAgY29uc3QgY29weXdpZHRoID0gd2lkdGggfCAwO1xyXG4gICAgY29uc3QgZmFzdHdpZHRoID0gTWF0aC5mbG9vcih3aWR0aCAvIDQpICogNDtcclxuICAgIGNvbnN0IHRoaXNkYXRhID0gbmV3IEludDMyQXJyYXkodGhpcy5kYXRhLmJ1ZmZlciwgdGhpcy5kYXRhLmJ5dGVPZmZzZXQsIHRoaXMuZGF0YS5ieXRlTGVuZ3RoIC8gNCk7XHJcbiAgICBjb25zdCB0YXJnZXRkYXRhID0gbmV3IEludDMyQXJyYXkodGFyZ2V0LmRhdGEuYnVmZmVyLCB0YXJnZXQuZGF0YS5ieXRlT2Zmc2V0LCB0YXJnZXQuZGF0YS5ieXRlTGVuZ3RoIC8gNCk7XHJcbiAgICBmb3IgKGxldCBjeSA9IDA7IGN5IDwgaGVpZ2h0OyBjeSsrKSB7XHJcbiAgICAgICAgbGV0IGN4ID0gMDtcclxuICAgICAgICBsZXQgaXQgPSAoY3ggKyB0YXJnZXR4KSArIChjeSArIHRhcmdldHkpICogdGFyZ2V0d2lkdGg7XHJcbiAgICAgICAgbGV0IGlzID0gKGN4ICsgc291cmNleCkgKyAoY3kgKyBzb3VyY2V5KSAqIHRoaXN3aWR0aDtcclxuICAgICAgICAvL2NvcHkgNCBwaXhlbHMgcGVyIGl0ZXIgKHhtbSlcclxuICAgICAgICBmb3IgKDsgY3ggPCBmYXN0d2lkdGg7IGN4ICs9IDQpIHtcclxuICAgICAgICAgICAgdGFyZ2V0ZGF0YVtpdF0gPSB0aGlzZGF0YVtpc107XHJcbiAgICAgICAgICAgIHRhcmdldGRhdGFbaXQgKyAxXSA9IHRoaXNkYXRhW2lzICsgMV07XHJcbiAgICAgICAgICAgIHRhcmdldGRhdGFbaXQgKyAyXSA9IHRoaXNkYXRhW2lzICsgMl07XHJcbiAgICAgICAgICAgIHRhcmdldGRhdGFbaXQgKyAzXSA9IHRoaXNkYXRhW2lzICsgM107XHJcbiAgICAgICAgICAgIGl0ICs9IDQ7XHJcbiAgICAgICAgICAgIGlzICs9IDQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vY29weSByZW1haW5kZXIgcGVyIHBpeGVsXHJcbiAgICAgICAgZm9yICg7IGN4IDwgY29weXdpZHRoOyBjeCsrKSB7XHJcbiAgICAgICAgICAgIHRhcmdldGRhdGFbaXRdID0gdGhpc2RhdGFbaXNdO1xyXG4gICAgICAgICAgICBpdCArPSAxO1xyXG4gICAgICAgICAgICBpcyArPSAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuaWYgKHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50ICE9IFwidW5kZWZpbmVkXCIpIHtcclxuICAgIEhUTUxJbWFnZUVsZW1lbnQucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24gKHggPSAwLCB5ID0gMCwgdyA9IHRoaXMud2lkdGgsIGggPSB0aGlzLmhlaWdodCkge1xyXG4gICAgICAgIHZhciBjbnYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG4gICAgICAgIGNudi53aWR0aCA9IHc7XHJcbiAgICAgICAgY252LmhlaWdodCA9IGg7XHJcbiAgICAgICAgdmFyIGN0eCA9IGNudi5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLCAteCwgLXkpO1xyXG4gICAgICAgIHJldHVybiBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHcsIGgpO1xyXG4gICAgfTtcclxuICAgIEhUTUxJbWFnZUVsZW1lbnQucHJvdG90eXBlLnRvQ2FudmFzID0gZnVuY3Rpb24gKHggPSAwLCB5ID0gMCwgdyA9IHRoaXMud2lkdGgsIGggPSB0aGlzLmhlaWdodCkge1xyXG4gICAgICAgIHZhciBjbnYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG4gICAgICAgIGNudi53aWR0aCA9IHc7XHJcbiAgICAgICAgY252LmhlaWdodCA9IGg7XHJcbiAgICAgICAgdmFyIGN0eCA9IGNudi5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLCAteCwgLXkpO1xyXG4gICAgICAgIHJldHVybiBjbnY7XHJcbiAgICB9O1xyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/@alt1/base/dist/imagedata-extensions.js\n");

/***/ }),

/***/ "../node_modules/@alt1/base/dist/imagedetect.js":
/*!******************************************************!*\
  !*** ../node_modules/@alt1/base/dist/imagedetect.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"imageDataFromUrl\": () => (/* binding */ imageDataFromUrl),\n/* harmony export */   \"imageDataFromBase64\": () => (/* binding */ imageDataFromBase64),\n/* harmony export */   \"imageDataFromFileBuffer\": () => (/* binding */ imageDataFromFileBuffer),\n/* harmony export */   \"isPngBuffer\": () => (/* binding */ isPngBuffer),\n/* harmony export */   \"clearPngColorspace\": () => (/* binding */ clearPngColorspace),\n/* harmony export */   \"findSubimage\": () => (/* binding */ findSubimage),\n/* harmony export */   \"findSubbuffer\": () => (/* binding */ findSubbuffer),\n/* harmony export */   \"simpleCompare\": () => (/* binding */ simpleCompare),\n/* harmony export */   \"coldif\": () => (/* binding */ coldif),\n/* harmony export */   \"asyncMap\": () => (/* binding */ asyncMap),\n/* harmony export */   \"webpackImages\": () => (/* binding */ webpackImages),\n/* harmony export */   \"ImageDataSet\": () => (/* binding */ ImageDataSet)\n/* harmony export */ });\n/* harmony import */ var _imgref_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./imgref.js */ \"../node_modules/@alt1/base/dist/imgref.js\");\n/* harmony import */ var _wrapper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wrapper.js */ \"../node_modules/@alt1/base/dist/wrapper.js\");\n/* harmony import */ var _nodepolyfill_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nodepolyfill.js */ \"../node_modules/@alt1/base/dist/nodepolyfill.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./index.js */ \"../node_modules/@alt1/base/dist/index.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n/**\r\n* Downloads an image and returns the ImageData\r\n* Make sure the png image does not have a sRGB chunk or the resulting pixels will differ for different users!!!\r\n* @param url http(s) or data url to the image\r\n*/\r\nfunction imageDataFromUrl(url) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        if (typeof Image != \"undefined\") {\r\n            var img = new Image();\r\n            img.crossOrigin = \"crossorigin\";\r\n            return yield new Promise((done, fail) => {\r\n                img.onload = function () { done(img.toBuffer()); };\r\n                img.onerror = fail;\r\n                img.src = url;\r\n            });\r\n        }\r\n        else {\r\n            var hdr = \"data:image/png;base64,\";\r\n            if (url.startsWith(hdr)) {\r\n                return imageDataFromBase64(url.slice(hdr.length));\r\n            }\r\n            throw new Error(\"loading remote images in nodejs has been disabled, load the raw bytes and use imageDataFromNodeBuffer instead\");\r\n        }\r\n    });\r\n}\r\n/**\r\n* Loads an ImageData object from a base64 encoded png image\r\n* Make sure the png image does not have a sRGB chunk or the resulting pixels will differ for different users!!!\r\n* @param data a base64 encoded png image\r\n*/\r\nfunction imageDataFromBase64(data) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        if (typeof Image != \"undefined\") {\r\n            return imageDataFromUrl(\"data:image/png;base64,\" + data);\r\n        }\r\n        else {\r\n            return _nodepolyfill_js__WEBPACK_IMPORTED_MODULE_2__.imageDataFromBase64(data);\r\n        }\r\n    });\r\n}\r\n/**\r\n * Loads an ImageData object directly from a png encoded file buffer\r\n * This method ensures that png color space headers are taken care off\r\n * @param data The bytes of a png file\r\n */\r\nfunction imageDataFromFileBuffer(data) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        clearPngColorspace(data);\r\n        if (typeof Image != \"undefined\") {\r\n            let blob = new Blob([data], { type: \"image/png\" });\r\n            let url = URL.createObjectURL(blob);\r\n            let r = yield imageDataFromUrl(url);\r\n            URL.revokeObjectURL(url);\r\n            return r;\r\n        }\r\n        else {\r\n            return _nodepolyfill_js__WEBPACK_IMPORTED_MODULE_2__.imageDataFromBuffer(data);\r\n        }\r\n    });\r\n}\r\n/**\r\n* Checks if a given byte array is a png file (by checking for ?PNG as first 4 bytes)\r\n* @param bytes Raw bytes of the png file\r\n*/\r\nfunction isPngBuffer(bytes) {\r\n    return bytes[0] == 137 && bytes[1] == 80 && bytes[2] == 78 && bytes[3] == 71;\r\n}\r\n/**\r\n* Resets the colorspace data in the png file.\r\n* This makes sure the browser renders the exact colors in the file instead of filtering it in order to obtain the best real life representation of\r\n* what it looked like on the authors screen. (this feature is often broken and not supported)\r\n* For example a round trip printscreen -> open in browser results in different colors than the original\r\n* @param data Raw bytes of the png file\r\n*/\r\nfunction clearPngColorspace(data) {\r\n    if (!isPngBuffer(data)) {\r\n        throw new Error(\"non-png image received\");\r\n    }\r\n    var i = 8;\r\n    while (i < data.length) {\r\n        var length = data[i++] * 0x1000000 + data[i++] * 0x10000 + data[i++] * 0x100 + data[i++];\r\n        var ancillary = !!((data[i] >> 5) & 1);\r\n        var chunkname = String.fromCharCode(data[i], data[i + 1], data[i + 2], data[i + 3]);\r\n        var chunkid = chunkname.toLowerCase();\r\n        if (chunkid != \"trns\" && ancillary) {\r\n            data[i + 0] = \"n\".charCodeAt(0);\r\n            data[i + 1] = \"o\".charCodeAt(0);\r\n            data[i + 2] = \"P\".charCodeAt(0);\r\n            data[i + 3] = \"E\".charCodeAt(0);\r\n            //calculate new chunk checksum\r\n            //http://www.libpng.org/pub/png/spec/1.2/PNG-CRCAppendix.html\r\n            var end = i + 4 + length;\r\n            var crc = 0xffffffff;\r\n            //should be fast enough like this\r\n            var bitcrc = function (bit) {\r\n                for (var k = 0; k < 8; k++) {\r\n                    if (bit & 1) {\r\n                        bit = 0xedb88320 ^ (bit >>> 1);\r\n                    }\r\n                    else {\r\n                        bit = bit >>> 1;\r\n                    }\r\n                }\r\n                return bit;\r\n            };\r\n            for (var a = i; a < end; a++) {\r\n                if (a >= i + 4) {\r\n                    data[a] = 0;\r\n                }\r\n                var bit = data[a];\r\n                crc = bitcrc((crc ^ bit) & 0xff) ^ (crc >>> 8);\r\n            }\r\n            crc = crc ^ 0xffffffff;\r\n            //new chunk checksum\r\n            data[i + 4 + length + 0] = (crc >> 24) & 0xff;\r\n            data[i + 4 + length + 1] = (crc >> 16) & 0xff;\r\n            data[i + 4 + length + 2] = (crc >> 8) & 0xff;\r\n            data[i + 4 + length + 3] = (crc >> 0) & 0xff;\r\n        }\r\n        if (chunkname == \"IEND\") {\r\n            break;\r\n        }\r\n        i += 4; //type\r\n        i += length; //data\r\n        i += 4; //crc\r\n    }\r\n}\r\n/**\r\n* finds the given needle ImageBuffer in the given haystack ImgRef this function uses the best optimized available\r\n* code depending on the type of the haystack. It will use fast c# searching if the haystack is an ImgRefBind, js searching\r\n* is used otherwise.\r\n* the checklist argument is no longer used and should ignored or null/undefined\r\n* The optional sx,sy,sw,sh arguments indicate a bounding rectangle in which to search the needle. The rectangle should be bigger than the needle\r\n* @returns An array of points where the needle is found. The array is empty if none are found\r\n*/\r\nfunction findSubimage(haystackImgref, needleBuffer, sx = 0, sy = 0, sw = haystackImgref.width, sh = haystackImgref.height) {\r\n    if (!haystackImgref) {\r\n        throw new TypeError();\r\n    }\r\n    if (!needleBuffer) {\r\n        throw new TypeError();\r\n    }\r\n    var max = 30;\r\n    //check if we can do this in alt1\r\n    if (haystackImgref instanceof _imgref_js__WEBPACK_IMPORTED_MODULE_0__.ImgRefBind && _wrapper_js__WEBPACK_IMPORTED_MODULE_1__.hasAlt1 && alt1.bindFindSubImg) {\r\n        var needlestr = _wrapper_js__WEBPACK_IMPORTED_MODULE_1__.encodeImageString(needleBuffer);\r\n        var r = alt1.bindFindSubImg(haystackImgref.handle, needlestr, needleBuffer.width, sx, sy, sw, sh);\r\n        if (!r) {\r\n            throw new _wrapper_js__WEBPACK_IMPORTED_MODULE_1__.Alt1Error();\r\n        }\r\n        return JSON.parse(r);\r\n    }\r\n    return findSubbuffer(haystackImgref.read(), needleBuffer, sx, sy, sw, sh);\r\n}\r\n/**\r\n* Uses js to find the given needle ImageBuffer in the given haystack ImageBuffer. It is better to use the alt1.bind- functions in\r\n* combination with a1nxt.findsubimg.\r\n* the optional sx,sy,sw,sh arguments indicate a bounding rectangle in which to search.\r\n* @returns An array of points where the needle is found. The array is empty if none are found\r\n*/\r\nfunction findSubbuffer(haystack, needle, sx = 0, sy = 0, sw = haystack.width, sh = haystack.height) {\r\n    var r = [];\r\n    var maxdif = 30;\r\n    var maxresults = 50;\r\n    var needlestride = needle.width * 4;\r\n    var heystackstride = haystack.width * 4;\r\n    //built list of non trans pixel to check\r\n    var checkList = [];\r\n    for (var y = 0; y < needle.height; y++) {\r\n        for (var x = 0; x < needle.width; x++) {\r\n            var i = x * 4 + y * needlestride;\r\n            if (needle.data[i + 3] == 255) {\r\n                checkList.push({ x: x, y: y });\r\n            }\r\n            if (checkList.length == 10) {\r\n                break;\r\n            }\r\n        }\r\n        if (checkList.length == 10) {\r\n            break;\r\n        }\r\n    }\r\n    var cw = (sx + sw) - needle.width;\r\n    var ch = (sy + sh) - needle.height;\r\n    var checklength = checkList.length;\r\n    for (var y = sy; y <= ch; y++) {\r\n        outer: for (var x = sx; x <= cw; x++) {\r\n            for (var a = 0; a < checklength; a++) {\r\n                var i1 = (x + checkList[a].x) * 4 + (y + checkList[a].y) * heystackstride;\r\n                var i2 = checkList[a].x * 4 + checkList[a].y * needlestride;\r\n                var d = 0;\r\n                d = d + Math.abs(haystack.data[i1 + 0] - needle.data[i2 + 0]) | 0;\r\n                d = d + Math.abs(haystack.data[i1 + 1] - needle.data[i2 + 1]) | 0;\r\n                d = d + Math.abs(haystack.data[i1 + 2] - needle.data[i2 + 2]) | 0;\r\n                d *= 255 / needle.data[i2 + 3];\r\n                if (d > maxdif) {\r\n                    continue outer;\r\n                }\r\n            }\r\n            if (simpleCompare(haystack, needle, x, y, maxdif) != Infinity) {\r\n                r.push({ x, y });\r\n                if (r.length > maxresults) {\r\n                    return r;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return r;\r\n}\r\n/**\r\n* Compares two images and returns the average color difference per pixel between them\r\n* @param max The max color difference at any point in the image before short circuiting the function and returning Infinity. set to -1 to always continue.\r\n* @returns The average color difference per pixel or Infinity if the difference is more than max at any point in the image\r\n*/\r\nfunction simpleCompare(bigbuf, checkbuf, x, y, max = 30) {\r\n    if (x < 0 || y < 0) {\r\n        throw new RangeError();\r\n    }\r\n    if (x + checkbuf.width > bigbuf.width || y + checkbuf.height > bigbuf.height) {\r\n        throw new RangeError();\r\n    }\r\n    if (max == -1) {\r\n        max = 255 * 4;\r\n    }\r\n    var dif = 0;\r\n    for (var step = 8; step >= 1; step /= 2) {\r\n        for (var cx = 0; cx < checkbuf.width; cx += step) {\r\n            for (var cy = 0; cy < checkbuf.height; cy += step) {\r\n                var i1 = (x + cx) * 4 + (y + cy) * bigbuf.width * 4;\r\n                var i2 = cx * 4 + cy * checkbuf.width * 4;\r\n                var d = 0;\r\n                d = d + Math.abs(bigbuf.data[i1 + 0] - checkbuf.data[i2 + 0]) | 0;\r\n                d = d + Math.abs(bigbuf.data[i1 + 1] - checkbuf.data[i2 + 1]) | 0;\r\n                d = d + Math.abs(bigbuf.data[i1 + 2] - checkbuf.data[i2 + 2]) | 0;\r\n                d *= checkbuf.data[i2 + 3] / 255;\r\n                if (step == 1) {\r\n                    dif += d;\r\n                }\r\n                if (d > max) {\r\n                    return Infinity;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return dif / checkbuf.width / checkbuf.height;\r\n}\r\n/**\r\n* Returns the difference between two colors (scaled to the alpha of the second color)\r\n*/\r\nfunction coldif(r1, g1, b1, r2, g2, b2, a2) {\r\n    return (Math.abs(r1 - r2) + Math.abs(g1 - g2) + Math.abs(b1 - b2)) * a2 / 255; //only applies alpha for 2nd buffer!\r\n}\r\n/**\r\n * Turns map of promises into a map that contains the resolved values after loading.\r\n * @param input\r\n */\r\nfunction asyncMap(input) {\r\n    var raw = {};\r\n    var promises = [];\r\n    for (var a in input) {\r\n        if (input.hasOwnProperty(a)) {\r\n            raw[a] = null;\r\n            promises.push(input[a].then(function (a, i) { raw[a] = i; r[a] = i; }.bind(null, a)));\r\n        }\r\n    }\r\n    var r = {};\r\n    var promise = Promise.all(promises).then(() => { r.loaded = true; return r; });\r\n    Object.defineProperty(r, \"loaded\", { enumerable: false, value: false, writable: true });\r\n    Object.defineProperty(r, \"promise\", { enumerable: false, value: promise });\r\n    Object.defineProperty(r, \"raw\", { enumerable: false, value: raw });\r\n    return Object.assign(r, raw);\r\n}\r\n/**\r\n* Same as asyncMap, but casts the properties to ImageData in typescript\r\n*/\r\nfunction webpackImages(input) {\r\n    return asyncMap(input);\r\n}\r\nclass ImageDataSet {\r\n    constructor() {\r\n        this.buffers = [];\r\n    }\r\n    matchBest(img, x, y, max) {\r\n        let best = null;\r\n        let bestscore = max;\r\n        for (let a = 0; a < this.buffers.length; a++) {\r\n            let score = img.pixelCompare(this.buffers[a], x, y, bestscore);\r\n            if (isFinite(score) && (bestscore == undefined || score < bestscore)) {\r\n                bestscore = score;\r\n                best = a;\r\n            }\r\n        }\r\n        if (best == null) {\r\n            return null;\r\n        }\r\n        return { index: best, score: bestscore };\r\n    }\r\n    static fromFilmStrip(baseimg, width) {\r\n        if ((baseimg.width % width) != 0) {\r\n            throw new Error(\"slice size does not fit in base img\");\r\n        }\r\n        let r = new ImageDataSet();\r\n        for (let x = 0; x < baseimg.width; x += width) {\r\n            r.buffers.push(baseimg.clone(new _index_js__WEBPACK_IMPORTED_MODULE_3__.Rect(x, 0, width, baseimg.height)));\r\n        }\r\n        return r;\r\n    }\r\n    static fromFilmStripUneven(baseimg, widths) {\r\n        let r = new ImageDataSet();\r\n        let x = 0;\r\n        for (let w of widths) {\r\n            r.buffers.push(baseimg.clone(new _index_js__WEBPACK_IMPORTED_MODULE_3__.Rect(x, 0, w, baseimg.height)));\r\n            x += w;\r\n            if (x > baseimg.width) {\r\n                throw new Error(\"sampling filmstrip outside bounds\");\r\n            }\r\n        }\r\n        if (x != baseimg.width) {\r\n            throw new Error(\"unconsumed pixels left in film strip imagedata\");\r\n        }\r\n        return r;\r\n    }\r\n    static fromAtlas(baseimg, slices) {\r\n        let r = new ImageDataSet();\r\n        for (let slice of slices) {\r\n            r.buffers.push(baseimg.clone(slice));\r\n        }\r\n        return r;\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BhbHQxL2Jhc2UvZGlzdC9pbWFnZWRldGVjdC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsaUJBQWlCLFNBQUksSUFBSSxTQUFJO0FBQzdCLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ3lDO0FBQ0Y7QUFDVTtBQUNmO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQSxtQkFBbUIsaUVBQStCO0FBQ2xEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG1CQUFtQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUVBQStCO0FBQ2xEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLHFCQUFxQjtBQUNyQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msa0RBQVUsSUFBSSxnREFBYztBQUM5RCx3QkFBd0IsMERBQXdCO0FBQ2hEO0FBQ0E7QUFDQSxzQkFBc0Isa0RBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2Qyx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQSxpQ0FBaUMsWUFBWTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QixnQ0FBZ0MsU0FBUztBQUN6Qyw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixNQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDLHlCQUF5QixxQkFBcUI7QUFDOUMsNkJBQTZCLHNCQUFzQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFlBQVksV0FBVztBQUNqRjtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsaUJBQWlCLFdBQVc7QUFDakYseUNBQXlDLGlEQUFpRDtBQUMxRiwwQ0FBMEMsbUNBQW1DO0FBQzdFLHNDQUFzQywrQkFBK0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQyw2Q0FBNkMsMkNBQUk7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMkNBQUk7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vVEVTVC8uLi9ub2RlX21vZHVsZXMvQGFsdDEvYmFzZS9kaXN0L2ltYWdlZGV0ZWN0LmpzPzNiNWQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG5pbXBvcnQgeyBJbWdSZWZCaW5kIH0gZnJvbSBcIi4vaW1ncmVmLmpzXCI7XHJcbmltcG9ydCAqIGFzIHdhcHBlciBmcm9tIFwiLi93cmFwcGVyLmpzXCI7XHJcbmltcG9ydCAqIGFzIG5vZGVpbXBvcnRzIGZyb20gXCIuL25vZGVwb2x5ZmlsbC5qc1wiO1xyXG5pbXBvcnQgeyBSZWN0IH0gZnJvbSBcIi4vaW5kZXguanNcIjtcclxuLyoqXHJcbiogRG93bmxvYWRzIGFuIGltYWdlIGFuZCByZXR1cm5zIHRoZSBJbWFnZURhdGFcclxuKiBNYWtlIHN1cmUgdGhlIHBuZyBpbWFnZSBkb2VzIG5vdCBoYXZlIGEgc1JHQiBjaHVuayBvciB0aGUgcmVzdWx0aW5nIHBpeGVscyB3aWxsIGRpZmZlciBmb3IgZGlmZmVyZW50IHVzZXJzISEhXHJcbiogQHBhcmFtIHVybCBodHRwKHMpIG9yIGRhdGEgdXJsIHRvIHRoZSBpbWFnZVxyXG4qL1xyXG5leHBvcnQgZnVuY3Rpb24gaW1hZ2VEYXRhRnJvbVVybCh1cmwpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBJbWFnZSAhPSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICAgICAgaW1nLmNyb3NzT3JpZ2luID0gXCJjcm9zc29yaWdpblwiO1xyXG4gICAgICAgICAgICByZXR1cm4geWllbGQgbmV3IFByb21pc2UoKGRvbmUsIGZhaWwpID0+IHtcclxuICAgICAgICAgICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7IGRvbmUoaW1nLnRvQnVmZmVyKCkpOyB9O1xyXG4gICAgICAgICAgICAgICAgaW1nLm9uZXJyb3IgPSBmYWlsO1xyXG4gICAgICAgICAgICAgICAgaW1nLnNyYyA9IHVybDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgaGRyID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsXCI7XHJcbiAgICAgICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aChoZHIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW1hZ2VEYXRhRnJvbUJhc2U2NCh1cmwuc2xpY2UoaGRyLmxlbmd0aCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImxvYWRpbmcgcmVtb3RlIGltYWdlcyBpbiBub2RlanMgaGFzIGJlZW4gZGlzYWJsZWQsIGxvYWQgdGhlIHJhdyBieXRlcyBhbmQgdXNlIGltYWdlRGF0YUZyb21Ob2RlQnVmZmVyIGluc3RlYWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiogTG9hZHMgYW4gSW1hZ2VEYXRhIG9iamVjdCBmcm9tIGEgYmFzZTY0IGVuY29kZWQgcG5nIGltYWdlXHJcbiogTWFrZSBzdXJlIHRoZSBwbmcgaW1hZ2UgZG9lcyBub3QgaGF2ZSBhIHNSR0IgY2h1bmsgb3IgdGhlIHJlc3VsdGluZyBwaXhlbHMgd2lsbCBkaWZmZXIgZm9yIGRpZmZlcmVudCB1c2VycyEhIVxyXG4qIEBwYXJhbSBkYXRhIGEgYmFzZTY0IGVuY29kZWQgcG5nIGltYWdlXHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiBpbWFnZURhdGFGcm9tQmFzZTY0KGRhdGEpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBJbWFnZSAhPSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbWFnZURhdGFGcm9tVXJsKFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LFwiICsgZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZWltcG9ydHMuaW1hZ2VEYXRhRnJvbUJhc2U2NChkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogTG9hZHMgYW4gSW1hZ2VEYXRhIG9iamVjdCBkaXJlY3RseSBmcm9tIGEgcG5nIGVuY29kZWQgZmlsZSBidWZmZXJcclxuICogVGhpcyBtZXRob2QgZW5zdXJlcyB0aGF0IHBuZyBjb2xvciBzcGFjZSBoZWFkZXJzIGFyZSB0YWtlbiBjYXJlIG9mZlxyXG4gKiBAcGFyYW0gZGF0YSBUaGUgYnl0ZXMgb2YgYSBwbmcgZmlsZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGltYWdlRGF0YUZyb21GaWxlQnVmZmVyKGRhdGEpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgY2xlYXJQbmdDb2xvcnNwYWNlKGRhdGEpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgSW1hZ2UgIT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICBsZXQgYmxvYiA9IG5ldyBCbG9iKFtkYXRhXSwgeyB0eXBlOiBcImltYWdlL3BuZ1wiIH0pO1xyXG4gICAgICAgICAgICBsZXQgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuICAgICAgICAgICAgbGV0IHIgPSB5aWVsZCBpbWFnZURhdGFGcm9tVXJsKHVybCk7XHJcbiAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcclxuICAgICAgICAgICAgcmV0dXJuIHI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZWltcG9ydHMuaW1hZ2VEYXRhRnJvbUJ1ZmZlcihkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuKiBDaGVja3MgaWYgYSBnaXZlbiBieXRlIGFycmF5IGlzIGEgcG5nIGZpbGUgKGJ5IGNoZWNraW5nIGZvciA/UE5HIGFzIGZpcnN0IDQgYnl0ZXMpXHJcbiogQHBhcmFtIGJ5dGVzIFJhdyBieXRlcyBvZiB0aGUgcG5nIGZpbGVcclxuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzUG5nQnVmZmVyKGJ5dGVzKSB7XHJcbiAgICByZXR1cm4gYnl0ZXNbMF0gPT0gMTM3ICYmIGJ5dGVzWzFdID09IDgwICYmIGJ5dGVzWzJdID09IDc4ICYmIGJ5dGVzWzNdID09IDcxO1xyXG59XHJcbi8qKlxyXG4qIFJlc2V0cyB0aGUgY29sb3JzcGFjZSBkYXRhIGluIHRoZSBwbmcgZmlsZS5cclxuKiBUaGlzIG1ha2VzIHN1cmUgdGhlIGJyb3dzZXIgcmVuZGVycyB0aGUgZXhhY3QgY29sb3JzIGluIHRoZSBmaWxlIGluc3RlYWQgb2YgZmlsdGVyaW5nIGl0IGluIG9yZGVyIHRvIG9idGFpbiB0aGUgYmVzdCByZWFsIGxpZmUgcmVwcmVzZW50YXRpb24gb2ZcclxuKiB3aGF0IGl0IGxvb2tlZCBsaWtlIG9uIHRoZSBhdXRob3JzIHNjcmVlbi4gKHRoaXMgZmVhdHVyZSBpcyBvZnRlbiBicm9rZW4gYW5kIG5vdCBzdXBwb3J0ZWQpXHJcbiogRm9yIGV4YW1wbGUgYSByb3VuZCB0cmlwIHByaW50c2NyZWVuIC0+IG9wZW4gaW4gYnJvd3NlciByZXN1bHRzIGluIGRpZmZlcmVudCBjb2xvcnMgdGhhbiB0aGUgb3JpZ2luYWxcclxuKiBAcGFyYW0gZGF0YSBSYXcgYnl0ZXMgb2YgdGhlIHBuZyBmaWxlXHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGVhclBuZ0NvbG9yc3BhY2UoZGF0YSkge1xyXG4gICAgaWYgKCFpc1BuZ0J1ZmZlcihkYXRhKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vbi1wbmcgaW1hZ2UgcmVjZWl2ZWRcIik7XHJcbiAgICB9XHJcbiAgICB2YXIgaSA9IDg7XHJcbiAgICB3aGlsZSAoaSA8IGRhdGEubGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IGRhdGFbaSsrXSAqIDB4MTAwMDAwMCArIGRhdGFbaSsrXSAqIDB4MTAwMDAgKyBkYXRhW2krK10gKiAweDEwMCArIGRhdGFbaSsrXTtcclxuICAgICAgICB2YXIgYW5jaWxsYXJ5ID0gISEoKGRhdGFbaV0gPj4gNSkgJiAxKTtcclxuICAgICAgICB2YXIgY2h1bmtuYW1lID0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhW2ldLCBkYXRhW2kgKyAxXSwgZGF0YVtpICsgMl0sIGRhdGFbaSArIDNdKTtcclxuICAgICAgICB2YXIgY2h1bmtpZCA9IGNodW5rbmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGlmIChjaHVua2lkICE9IFwidHJuc1wiICYmIGFuY2lsbGFyeSkge1xyXG4gICAgICAgICAgICBkYXRhW2kgKyAwXSA9IFwiblwiLmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gXCJvXCIuY2hhckNvZGVBdCgwKTtcclxuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBcIlBcIi5jaGFyQ29kZUF0KDApO1xyXG4gICAgICAgICAgICBkYXRhW2kgKyAzXSA9IFwiRVwiLmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgICAgICAgIC8vY2FsY3VsYXRlIG5ldyBjaHVuayBjaGVja3N1bVxyXG4gICAgICAgICAgICAvL2h0dHA6Ly93d3cubGlicG5nLm9yZy9wdWIvcG5nL3NwZWMvMS4yL1BORy1DUkNBcHBlbmRpeC5odG1sXHJcbiAgICAgICAgICAgIHZhciBlbmQgPSBpICsgNCArIGxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIGNyYyA9IDB4ZmZmZmZmZmY7XHJcbiAgICAgICAgICAgIC8vc2hvdWxkIGJlIGZhc3QgZW5vdWdoIGxpa2UgdGhpc1xyXG4gICAgICAgICAgICB2YXIgYml0Y3JjID0gZnVuY3Rpb24gKGJpdCkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCA4OyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYml0ICYgMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiaXQgPSAweGVkYjg4MzIwIF4gKGJpdCA+Pj4gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiaXQgPSBiaXQgPj4+IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZm9yICh2YXIgYSA9IGk7IGEgPCBlbmQ7IGErKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGEgPj0gaSArIDQpIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhW2FdID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBiaXQgPSBkYXRhW2FdO1xyXG4gICAgICAgICAgICAgICAgY3JjID0gYml0Y3JjKChjcmMgXiBiaXQpICYgMHhmZikgXiAoY3JjID4+PiA4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjcmMgPSBjcmMgXiAweGZmZmZmZmZmO1xyXG4gICAgICAgICAgICAvL25ldyBjaHVuayBjaGVja3N1bVxyXG4gICAgICAgICAgICBkYXRhW2kgKyA0ICsgbGVuZ3RoICsgMF0gPSAoY3JjID4+IDI0KSAmIDB4ZmY7XHJcbiAgICAgICAgICAgIGRhdGFbaSArIDQgKyBsZW5ndGggKyAxXSA9IChjcmMgPj4gMTYpICYgMHhmZjtcclxuICAgICAgICAgICAgZGF0YVtpICsgNCArIGxlbmd0aCArIDJdID0gKGNyYyA+PiA4KSAmIDB4ZmY7XHJcbiAgICAgICAgICAgIGRhdGFbaSArIDQgKyBsZW5ndGggKyAzXSA9IChjcmMgPj4gMCkgJiAweGZmO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2h1bmtuYW1lID09IFwiSUVORFwiKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpICs9IDQ7IC8vdHlwZVxyXG4gICAgICAgIGkgKz0gbGVuZ3RoOyAvL2RhdGFcclxuICAgICAgICBpICs9IDQ7IC8vY3JjXHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiogZmluZHMgdGhlIGdpdmVuIG5lZWRsZSBJbWFnZUJ1ZmZlciBpbiB0aGUgZ2l2ZW4gaGF5c3RhY2sgSW1nUmVmIHRoaXMgZnVuY3Rpb24gdXNlcyB0aGUgYmVzdCBvcHRpbWl6ZWQgYXZhaWxhYmxlXHJcbiogY29kZSBkZXBlbmRpbmcgb24gdGhlIHR5cGUgb2YgdGhlIGhheXN0YWNrLiBJdCB3aWxsIHVzZSBmYXN0IGMjIHNlYXJjaGluZyBpZiB0aGUgaGF5c3RhY2sgaXMgYW4gSW1nUmVmQmluZCwganMgc2VhcmNoaW5nXHJcbiogaXMgdXNlZCBvdGhlcndpc2UuXHJcbiogdGhlIGNoZWNrbGlzdCBhcmd1bWVudCBpcyBubyBsb25nZXIgdXNlZCBhbmQgc2hvdWxkIGlnbm9yZWQgb3IgbnVsbC91bmRlZmluZWRcclxuKiBUaGUgb3B0aW9uYWwgc3gsc3ksc3csc2ggYXJndW1lbnRzIGluZGljYXRlIGEgYm91bmRpbmcgcmVjdGFuZ2xlIGluIHdoaWNoIHRvIHNlYXJjaCB0aGUgbmVlZGxlLiBUaGUgcmVjdGFuZ2xlIHNob3VsZCBiZSBiaWdnZXIgdGhhbiB0aGUgbmVlZGxlXHJcbiogQHJldHVybnMgQW4gYXJyYXkgb2YgcG9pbnRzIHdoZXJlIHRoZSBuZWVkbGUgaXMgZm91bmQuIFRoZSBhcnJheSBpcyBlbXB0eSBpZiBub25lIGFyZSBmb3VuZFxyXG4qL1xyXG5leHBvcnQgZnVuY3Rpb24gZmluZFN1YmltYWdlKGhheXN0YWNrSW1ncmVmLCBuZWVkbGVCdWZmZXIsIHN4ID0gMCwgc3kgPSAwLCBzdyA9IGhheXN0YWNrSW1ncmVmLndpZHRoLCBzaCA9IGhheXN0YWNrSW1ncmVmLmhlaWdodCkge1xyXG4gICAgaWYgKCFoYXlzdGFja0ltZ3JlZikge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgIH1cclxuICAgIGlmICghbmVlZGxlQnVmZmVyKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgfVxyXG4gICAgdmFyIG1heCA9IDMwO1xyXG4gICAgLy9jaGVjayBpZiB3ZSBjYW4gZG8gdGhpcyBpbiBhbHQxXHJcbiAgICBpZiAoaGF5c3RhY2tJbWdyZWYgaW5zdGFuY2VvZiBJbWdSZWZCaW5kICYmIHdhcHBlci5oYXNBbHQxICYmIGFsdDEuYmluZEZpbmRTdWJJbWcpIHtcclxuICAgICAgICB2YXIgbmVlZGxlc3RyID0gd2FwcGVyLmVuY29kZUltYWdlU3RyaW5nKG5lZWRsZUJ1ZmZlcik7XHJcbiAgICAgICAgdmFyIHIgPSBhbHQxLmJpbmRGaW5kU3ViSW1nKGhheXN0YWNrSW1ncmVmLmhhbmRsZSwgbmVlZGxlc3RyLCBuZWVkbGVCdWZmZXIud2lkdGgsIHN4LCBzeSwgc3csIHNoKTtcclxuICAgICAgICBpZiAoIXIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IHdhcHBlci5BbHQxRXJyb3IoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uocik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmluZFN1YmJ1ZmZlcihoYXlzdGFja0ltZ3JlZi5yZWFkKCksIG5lZWRsZUJ1ZmZlciwgc3gsIHN5LCBzdywgc2gpO1xyXG59XHJcbi8qKlxyXG4qIFVzZXMganMgdG8gZmluZCB0aGUgZ2l2ZW4gbmVlZGxlIEltYWdlQnVmZmVyIGluIHRoZSBnaXZlbiBoYXlzdGFjayBJbWFnZUJ1ZmZlci4gSXQgaXMgYmV0dGVyIHRvIHVzZSB0aGUgYWx0MS5iaW5kLSBmdW5jdGlvbnMgaW5cclxuKiBjb21iaW5hdGlvbiB3aXRoIGExbnh0LmZpbmRzdWJpbWcuXHJcbiogdGhlIG9wdGlvbmFsIHN4LHN5LHN3LHNoIGFyZ3VtZW50cyBpbmRpY2F0ZSBhIGJvdW5kaW5nIHJlY3RhbmdsZSBpbiB3aGljaCB0byBzZWFyY2guXHJcbiogQHJldHVybnMgQW4gYXJyYXkgb2YgcG9pbnRzIHdoZXJlIHRoZSBuZWVkbGUgaXMgZm91bmQuIFRoZSBhcnJheSBpcyBlbXB0eSBpZiBub25lIGFyZSBmb3VuZFxyXG4qL1xyXG5leHBvcnQgZnVuY3Rpb24gZmluZFN1YmJ1ZmZlcihoYXlzdGFjaywgbmVlZGxlLCBzeCA9IDAsIHN5ID0gMCwgc3cgPSBoYXlzdGFjay53aWR0aCwgc2ggPSBoYXlzdGFjay5oZWlnaHQpIHtcclxuICAgIHZhciByID0gW107XHJcbiAgICB2YXIgbWF4ZGlmID0gMzA7XHJcbiAgICB2YXIgbWF4cmVzdWx0cyA9IDUwO1xyXG4gICAgdmFyIG5lZWRsZXN0cmlkZSA9IG5lZWRsZS53aWR0aCAqIDQ7XHJcbiAgICB2YXIgaGV5c3RhY2tzdHJpZGUgPSBoYXlzdGFjay53aWR0aCAqIDQ7XHJcbiAgICAvL2J1aWx0IGxpc3Qgb2Ygbm9uIHRyYW5zIHBpeGVsIHRvIGNoZWNrXHJcbiAgICB2YXIgY2hlY2tMaXN0ID0gW107XHJcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8IG5lZWRsZS5oZWlnaHQ7IHkrKykge1xyXG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgbmVlZGxlLndpZHRoOyB4KyspIHtcclxuICAgICAgICAgICAgdmFyIGkgPSB4ICogNCArIHkgKiBuZWVkbGVzdHJpZGU7XHJcbiAgICAgICAgICAgIGlmIChuZWVkbGUuZGF0YVtpICsgM10gPT0gMjU1KSB7XHJcbiAgICAgICAgICAgICAgICBjaGVja0xpc3QucHVzaCh7IHg6IHgsIHk6IHkgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNoZWNrTGlzdC5sZW5ndGggPT0gMTApIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjaGVja0xpc3QubGVuZ3RoID09IDEwKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBjdyA9IChzeCArIHN3KSAtIG5lZWRsZS53aWR0aDtcclxuICAgIHZhciBjaCA9IChzeSArIHNoKSAtIG5lZWRsZS5oZWlnaHQ7XHJcbiAgICB2YXIgY2hlY2tsZW5ndGggPSBjaGVja0xpc3QubGVuZ3RoO1xyXG4gICAgZm9yICh2YXIgeSA9IHN5OyB5IDw9IGNoOyB5KyspIHtcclxuICAgICAgICBvdXRlcjogZm9yICh2YXIgeCA9IHN4OyB4IDw9IGN3OyB4KyspIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCBjaGVja2xlbmd0aDsgYSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaTEgPSAoeCArIGNoZWNrTGlzdFthXS54KSAqIDQgKyAoeSArIGNoZWNrTGlzdFthXS55KSAqIGhleXN0YWNrc3RyaWRlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGkyID0gY2hlY2tMaXN0W2FdLnggKiA0ICsgY2hlY2tMaXN0W2FdLnkgKiBuZWVkbGVzdHJpZGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IDA7XHJcbiAgICAgICAgICAgICAgICBkID0gZCArIE1hdGguYWJzKGhheXN0YWNrLmRhdGFbaTEgKyAwXSAtIG5lZWRsZS5kYXRhW2kyICsgMF0pIHwgMDtcclxuICAgICAgICAgICAgICAgIGQgPSBkICsgTWF0aC5hYnMoaGF5c3RhY2suZGF0YVtpMSArIDFdIC0gbmVlZGxlLmRhdGFbaTIgKyAxXSkgfCAwO1xyXG4gICAgICAgICAgICAgICAgZCA9IGQgKyBNYXRoLmFicyhoYXlzdGFjay5kYXRhW2kxICsgMl0gLSBuZWVkbGUuZGF0YVtpMiArIDJdKSB8IDA7XHJcbiAgICAgICAgICAgICAgICBkICo9IDI1NSAvIG5lZWRsZS5kYXRhW2kyICsgM107XHJcbiAgICAgICAgICAgICAgICBpZiAoZCA+IG1heGRpZikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzaW1wbGVDb21wYXJlKGhheXN0YWNrLCBuZWVkbGUsIHgsIHksIG1heGRpZikgIT0gSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgICAgIHIucHVzaCh7IHgsIHkgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoci5sZW5ndGggPiBtYXhyZXN1bHRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcjtcclxufVxyXG4vKipcclxuKiBDb21wYXJlcyB0d28gaW1hZ2VzIGFuZCByZXR1cm5zIHRoZSBhdmVyYWdlIGNvbG9yIGRpZmZlcmVuY2UgcGVyIHBpeGVsIGJldHdlZW4gdGhlbVxyXG4qIEBwYXJhbSBtYXggVGhlIG1heCBjb2xvciBkaWZmZXJlbmNlIGF0IGFueSBwb2ludCBpbiB0aGUgaW1hZ2UgYmVmb3JlIHNob3J0IGNpcmN1aXRpbmcgdGhlIGZ1bmN0aW9uIGFuZCByZXR1cm5pbmcgSW5maW5pdHkuIHNldCB0byAtMSB0byBhbHdheXMgY29udGludWUuXHJcbiogQHJldHVybnMgVGhlIGF2ZXJhZ2UgY29sb3IgZGlmZmVyZW5jZSBwZXIgcGl4ZWwgb3IgSW5maW5pdHkgaWYgdGhlIGRpZmZlcmVuY2UgaXMgbW9yZSB0aGFuIG1heCBhdCBhbnkgcG9pbnQgaW4gdGhlIGltYWdlXHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiBzaW1wbGVDb21wYXJlKGJpZ2J1ZiwgY2hlY2tidWYsIHgsIHksIG1heCA9IDMwKSB7XHJcbiAgICBpZiAoeCA8IDAgfHwgeSA8IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigpO1xyXG4gICAgfVxyXG4gICAgaWYgKHggKyBjaGVja2J1Zi53aWR0aCA+IGJpZ2J1Zi53aWR0aCB8fCB5ICsgY2hlY2tidWYuaGVpZ2h0ID4gYmlnYnVmLmhlaWdodCkge1xyXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCk7XHJcbiAgICB9XHJcbiAgICBpZiAobWF4ID09IC0xKSB7XHJcbiAgICAgICAgbWF4ID0gMjU1ICogNDtcclxuICAgIH1cclxuICAgIHZhciBkaWYgPSAwO1xyXG4gICAgZm9yICh2YXIgc3RlcCA9IDg7IHN0ZXAgPj0gMTsgc3RlcCAvPSAyKSB7XHJcbiAgICAgICAgZm9yICh2YXIgY3ggPSAwOyBjeCA8IGNoZWNrYnVmLndpZHRoOyBjeCArPSBzdGVwKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGN5ID0gMDsgY3kgPCBjaGVja2J1Zi5oZWlnaHQ7IGN5ICs9IHN0ZXApIHtcclxuICAgICAgICAgICAgICAgIHZhciBpMSA9ICh4ICsgY3gpICogNCArICh5ICsgY3kpICogYmlnYnVmLndpZHRoICogNDtcclxuICAgICAgICAgICAgICAgIHZhciBpMiA9IGN4ICogNCArIGN5ICogY2hlY2tidWYud2lkdGggKiA0O1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSAwO1xyXG4gICAgICAgICAgICAgICAgZCA9IGQgKyBNYXRoLmFicyhiaWdidWYuZGF0YVtpMSArIDBdIC0gY2hlY2tidWYuZGF0YVtpMiArIDBdKSB8IDA7XHJcbiAgICAgICAgICAgICAgICBkID0gZCArIE1hdGguYWJzKGJpZ2J1Zi5kYXRhW2kxICsgMV0gLSBjaGVja2J1Zi5kYXRhW2kyICsgMV0pIHwgMDtcclxuICAgICAgICAgICAgICAgIGQgPSBkICsgTWF0aC5hYnMoYmlnYnVmLmRhdGFbaTEgKyAyXSAtIGNoZWNrYnVmLmRhdGFbaTIgKyAyXSkgfCAwO1xyXG4gICAgICAgICAgICAgICAgZCAqPSBjaGVja2J1Zi5kYXRhW2kyICsgM10gLyAyNTU7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RlcCA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlmICs9IGQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZCA+IG1heCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkaWYgLyBjaGVja2J1Zi53aWR0aCAvIGNoZWNrYnVmLmhlaWdodDtcclxufVxyXG4vKipcclxuKiBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdHdvIGNvbG9ycyAoc2NhbGVkIHRvIHRoZSBhbHBoYSBvZiB0aGUgc2Vjb25kIGNvbG9yKVxyXG4qL1xyXG5leHBvcnQgZnVuY3Rpb24gY29sZGlmKHIxLCBnMSwgYjEsIHIyLCBnMiwgYjIsIGEyKSB7XHJcbiAgICByZXR1cm4gKE1hdGguYWJzKHIxIC0gcjIpICsgTWF0aC5hYnMoZzEgLSBnMikgKyBNYXRoLmFicyhiMSAtIGIyKSkgKiBhMiAvIDI1NTsgLy9vbmx5IGFwcGxpZXMgYWxwaGEgZm9yIDJuZCBidWZmZXIhXHJcbn1cclxuLyoqXHJcbiAqIFR1cm5zIG1hcCBvZiBwcm9taXNlcyBpbnRvIGEgbWFwIHRoYXQgY29udGFpbnMgdGhlIHJlc29sdmVkIHZhbHVlcyBhZnRlciBsb2FkaW5nLlxyXG4gKiBAcGFyYW0gaW5wdXRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhc3luY01hcChpbnB1dCkge1xyXG4gICAgdmFyIHJhdyA9IHt9O1xyXG4gICAgdmFyIHByb21pc2VzID0gW107XHJcbiAgICBmb3IgKHZhciBhIGluIGlucHV0KSB7XHJcbiAgICAgICAgaWYgKGlucHV0Lmhhc093blByb3BlcnR5KGEpKSB7XHJcbiAgICAgICAgICAgIHJhd1thXSA9IG51bGw7XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goaW5wdXRbYV0udGhlbihmdW5jdGlvbiAoYSwgaSkgeyByYXdbYV0gPSBpOyByW2FdID0gaTsgfS5iaW5kKG51bGwsIGEpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIHIgPSB7fTtcclxuICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oKCkgPT4geyByLmxvYWRlZCA9IHRydWU7IHJldHVybiByOyB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLCBcImxvYWRlZFwiLCB7IGVudW1lcmFibGU6IGZhbHNlLCB2YWx1ZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsIFwicHJvbWlzZVwiLCB7IGVudW1lcmFibGU6IGZhbHNlLCB2YWx1ZTogcHJvbWlzZSB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLCBcInJhd1wiLCB7IGVudW1lcmFibGU6IGZhbHNlLCB2YWx1ZTogcmF3IH0pO1xyXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ociwgcmF3KTtcclxufVxyXG4vKipcclxuKiBTYW1lIGFzIGFzeW5jTWFwLCBidXQgY2FzdHMgdGhlIHByb3BlcnRpZXMgdG8gSW1hZ2VEYXRhIGluIHR5cGVzY3JpcHRcclxuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHdlYnBhY2tJbWFnZXMoaW5wdXQpIHtcclxuICAgIHJldHVybiBhc3luY01hcChpbnB1dCk7XHJcbn1cclxuZXhwb3J0IGNsYXNzIEltYWdlRGF0YVNldCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBbXTtcclxuICAgIH1cclxuICAgIG1hdGNoQmVzdChpbWcsIHgsIHksIG1heCkge1xyXG4gICAgICAgIGxldCBiZXN0ID0gbnVsbDtcclxuICAgICAgICBsZXQgYmVzdHNjb3JlID0gbWF4O1xyXG4gICAgICAgIGZvciAobGV0IGEgPSAwOyBhIDwgdGhpcy5idWZmZXJzLmxlbmd0aDsgYSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBzY29yZSA9IGltZy5waXhlbENvbXBhcmUodGhpcy5idWZmZXJzW2FdLCB4LCB5LCBiZXN0c2NvcmUpO1xyXG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUoc2NvcmUpICYmIChiZXN0c2NvcmUgPT0gdW5kZWZpbmVkIHx8IHNjb3JlIDwgYmVzdHNjb3JlKSkge1xyXG4gICAgICAgICAgICAgICAgYmVzdHNjb3JlID0gc2NvcmU7XHJcbiAgICAgICAgICAgICAgICBiZXN0ID0gYTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYmVzdCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBpbmRleDogYmVzdCwgc2NvcmU6IGJlc3RzY29yZSB9O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21GaWxtU3RyaXAoYmFzZWltZywgd2lkdGgpIHtcclxuICAgICAgICBpZiAoKGJhc2VpbWcud2lkdGggJSB3aWR0aCkgIT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzbGljZSBzaXplIGRvZXMgbm90IGZpdCBpbiBiYXNlIGltZ1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHIgPSBuZXcgSW1hZ2VEYXRhU2V0KCk7XHJcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBiYXNlaW1nLndpZHRoOyB4ICs9IHdpZHRoKSB7XHJcbiAgICAgICAgICAgIHIuYnVmZmVycy5wdXNoKGJhc2VpbWcuY2xvbmUobmV3IFJlY3QoeCwgMCwgd2lkdGgsIGJhc2VpbWcuaGVpZ2h0KSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tRmlsbVN0cmlwVW5ldmVuKGJhc2VpbWcsIHdpZHRocykge1xyXG4gICAgICAgIGxldCByID0gbmV3IEltYWdlRGF0YVNldCgpO1xyXG4gICAgICAgIGxldCB4ID0gMDtcclxuICAgICAgICBmb3IgKGxldCB3IG9mIHdpZHRocykge1xyXG4gICAgICAgICAgICByLmJ1ZmZlcnMucHVzaChiYXNlaW1nLmNsb25lKG5ldyBSZWN0KHgsIDAsIHcsIGJhc2VpbWcuaGVpZ2h0KSkpO1xyXG4gICAgICAgICAgICB4ICs9IHc7XHJcbiAgICAgICAgICAgIGlmICh4ID4gYmFzZWltZy53aWR0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2FtcGxpbmcgZmlsbXN0cmlwIG91dHNpZGUgYm91bmRzXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh4ICE9IGJhc2VpbWcud2lkdGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5jb25zdW1lZCBwaXhlbHMgbGVmdCBpbiBmaWxtIHN0cmlwIGltYWdlZGF0YVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbUF0bGFzKGJhc2VpbWcsIHNsaWNlcykge1xyXG4gICAgICAgIGxldCByID0gbmV3IEltYWdlRGF0YVNldCgpO1xyXG4gICAgICAgIGZvciAobGV0IHNsaWNlIG9mIHNsaWNlcykge1xyXG4gICAgICAgICAgICByLmJ1ZmZlcnMucHVzaChiYXNlaW1nLmNsb25lKHNsaWNlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfVxyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/@alt1/base/dist/imagedetect.js\n");

/***/ }),

/***/ "../node_modules/@alt1/base/dist/imgref.js":
/*!*************************************************!*\
  !*** ../node_modules/@alt1/base/dist/imgref.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ImgRef\": () => (/* binding */ ImgRef),\n/* harmony export */   \"ImgRefCtx\": () => (/* binding */ ImgRefCtx),\n/* harmony export */   \"ImgRefBind\": () => (/* binding */ ImgRefBind),\n/* harmony export */   \"ImgRefData\": () => (/* binding */ ImgRefData)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ \"../node_modules/@alt1/base/dist/index.js\");\n\r\n/**\r\n * Represents an image that might be in different types of memory\r\n * This is mostly used to represent images still in Alt1 memory that have\r\n * not been transfered to js yet. Various a1lib api's use this type and\r\n * choose the most efficient approach based on the memory type\r\n */\r\nclass ImgRef {\r\n    constructor(x, y, w, h) {\r\n        this.t = \"none\";\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = w;\r\n        this.height = h;\r\n    }\r\n    read(x = 0, y = 0, w = this.width, h = this.height) {\r\n        throw new Error(\"This imgref (\" + this.t + \") does not support toData\");\r\n    }\r\n    findSubimage(needle, sx = 0, sy = 0, w = this.width, h = this.height) {\r\n        return _index_js__WEBPACK_IMPORTED_MODULE_0__.ImageDetect.findSubimage(this, needle, sx, sy, w, h);\r\n    }\r\n    toData(x = this.x, y = this.y, w = this.width, h = this.height) {\r\n        return this.read(x - this.x, y - this.y, w, h);\r\n    }\r\n    ;\r\n    containsArea(rect) {\r\n        return this.x <= rect.x && this.y <= rect.y && this.x + this.width >= rect.x + rect.width && this.y + this.height >= rect.y + rect.height;\r\n    }\r\n}\r\n/**\r\n * Represents an image in js render memory (canvas/image tag)\r\n */\r\nclass ImgRefCtx extends ImgRef {\r\n    constructor(img, x = 0, y = 0) {\r\n        if (img instanceof CanvasRenderingContext2D) {\r\n            super(x, y, img.canvas.width, img.canvas.height);\r\n            this.ctx = img;\r\n        }\r\n        else {\r\n            super(x, y, img.width, img.height);\r\n            var cnv = (img instanceof HTMLCanvasElement ? img : img.toCanvas());\r\n            this.ctx = cnv.getContext(\"2d\");\r\n        }\r\n        this.t = \"ctx\";\r\n    }\r\n    read(x = 0, y = 0, w = this.width, h = this.height) {\r\n        return this.ctx.getImageData(x, y, w, h);\r\n    }\r\n}\r\n/**\r\n * Represents in image in Alt1 memory, This type of image can be searched for subimages\r\n * very efficiently and transfering the full image to js can be avoided this way\r\n */\r\nclass ImgRefBind extends ImgRef {\r\n    constructor(handle, x = 0, y = 0, w = 0, h = 0) {\r\n        super(x, y, w, h);\r\n        this.handle = handle;\r\n        this.t = \"bind\";\r\n    }\r\n    read(x = 0, y = 0, w = this.width, h = this.height) {\r\n        return (0,_index_js__WEBPACK_IMPORTED_MODULE_0__.transferImageData)(this.handle, x, y, w, h);\r\n    }\r\n}\r\n/**\r\n * Represents an image in js memory\r\n */\r\nclass ImgRefData extends ImgRef {\r\n    constructor(buf, x = 0, y = 0) {\r\n        super(x, y, buf.width, buf.height);\r\n        this.buf = buf;\r\n        this.t = \"data\";\r\n    }\r\n    read(x = 0, y = 0, w = this.width, h = this.height) {\r\n        if (x == 0 && y == 0 && w == this.width && h == this.height) {\r\n            return this.buf;\r\n        }\r\n        var r = new ImageData(w, h);\r\n        for (var b = y; b < y + h; b++) {\r\n            for (var a = x; a < x + w; a++) {\r\n                var i1 = (a - x) * 4 + (b - y) * w * 4;\r\n                var i2 = a * 4 + b * 4 * this.buf.width;\r\n                r.data[i1] = this.buf.data[i2];\r\n                r.data[i1 + 1] = this.buf.data[i2 + 1];\r\n                r.data[i1 + 2] = this.buf.data[i2 + 2];\r\n                r.data[i1 + 3] = this.buf.data[i2 + 3];\r\n            }\r\n        }\r\n        return r;\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BhbHQxL2Jhc2UvZGlzdC9pbWdyZWYuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrREFBd0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDREQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9URVNULy4uL25vZGVfbW9kdWxlcy9AYWx0MS9iYXNlL2Rpc3QvaW1ncmVmLmpzPzY4MTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW1hZ2VEZXRlY3QsIHRyYW5zZmVySW1hZ2VEYXRhIH0gZnJvbSBcIi4vaW5kZXguanNcIjtcclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYW4gaW1hZ2UgdGhhdCBtaWdodCBiZSBpbiBkaWZmZXJlbnQgdHlwZXMgb2YgbWVtb3J5XHJcbiAqIFRoaXMgaXMgbW9zdGx5IHVzZWQgdG8gcmVwcmVzZW50IGltYWdlcyBzdGlsbCBpbiBBbHQxIG1lbW9yeSB0aGF0IGhhdmVcclxuICogbm90IGJlZW4gdHJhbnNmZXJlZCB0byBqcyB5ZXQuIFZhcmlvdXMgYTFsaWIgYXBpJ3MgdXNlIHRoaXMgdHlwZSBhbmRcclxuICogY2hvb3NlIHRoZSBtb3N0IGVmZmljaWVudCBhcHByb2FjaCBiYXNlZCBvbiB0aGUgbWVtb3J5IHR5cGVcclxuICovXHJcbmV4cG9ydCBjbGFzcyBJbWdSZWYge1xyXG4gICAgY29uc3RydWN0b3IoeCwgeSwgdywgaCkge1xyXG4gICAgICAgIHRoaXMudCA9IFwibm9uZVwiO1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICB0aGlzLndpZHRoID0gdztcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGg7XHJcbiAgICB9XHJcbiAgICByZWFkKHggPSAwLCB5ID0gMCwgdyA9IHRoaXMud2lkdGgsIGggPSB0aGlzLmhlaWdodCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgaW1ncmVmIChcIiArIHRoaXMudCArIFwiKSBkb2VzIG5vdCBzdXBwb3J0IHRvRGF0YVwiKTtcclxuICAgIH1cclxuICAgIGZpbmRTdWJpbWFnZShuZWVkbGUsIHN4ID0gMCwgc3kgPSAwLCB3ID0gdGhpcy53aWR0aCwgaCA9IHRoaXMuaGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIEltYWdlRGV0ZWN0LmZpbmRTdWJpbWFnZSh0aGlzLCBuZWVkbGUsIHN4LCBzeSwgdywgaCk7XHJcbiAgICB9XHJcbiAgICB0b0RhdGEoeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgdyA9IHRoaXMud2lkdGgsIGggPSB0aGlzLmhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlYWQoeCAtIHRoaXMueCwgeSAtIHRoaXMueSwgdywgaCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBjb250YWluc0FyZWEocmVjdCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnggPD0gcmVjdC54ICYmIHRoaXMueSA8PSByZWN0LnkgJiYgdGhpcy54ICsgdGhpcy53aWR0aCA+PSByZWN0LnggKyByZWN0LndpZHRoICYmIHRoaXMueSArIHRoaXMuaGVpZ2h0ID49IHJlY3QueSArIHJlY3QuaGVpZ2h0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGFuIGltYWdlIGluIGpzIHJlbmRlciBtZW1vcnkgKGNhbnZhcy9pbWFnZSB0YWcpXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgSW1nUmVmQ3R4IGV4dGVuZHMgSW1nUmVmIHtcclxuICAgIGNvbnN0cnVjdG9yKGltZywgeCA9IDAsIHkgPSAwKSB7XHJcbiAgICAgICAgaWYgKGltZyBpbnN0YW5jZW9mIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xyXG4gICAgICAgICAgICBzdXBlcih4LCB5LCBpbWcuY2FudmFzLndpZHRoLCBpbWcuY2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgICAgIHRoaXMuY3R4ID0gaW1nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc3VwZXIoeCwgeSwgaW1nLndpZHRoLCBpbWcuaGVpZ2h0KTtcclxuICAgICAgICAgICAgdmFyIGNudiA9IChpbWcgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCA/IGltZyA6IGltZy50b0NhbnZhcygpKTtcclxuICAgICAgICAgICAgdGhpcy5jdHggPSBjbnYuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnQgPSBcImN0eFwiO1xyXG4gICAgfVxyXG4gICAgcmVhZCh4ID0gMCwgeSA9IDAsIHcgPSB0aGlzLndpZHRoLCBoID0gdGhpcy5oZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jdHguZ2V0SW1hZ2VEYXRhKHgsIHksIHcsIGgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGluIGltYWdlIGluIEFsdDEgbWVtb3J5LCBUaGlzIHR5cGUgb2YgaW1hZ2UgY2FuIGJlIHNlYXJjaGVkIGZvciBzdWJpbWFnZXNcclxuICogdmVyeSBlZmZpY2llbnRseSBhbmQgdHJhbnNmZXJpbmcgdGhlIGZ1bGwgaW1hZ2UgdG8ganMgY2FuIGJlIGF2b2lkZWQgdGhpcyB3YXlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBJbWdSZWZCaW5kIGV4dGVuZHMgSW1nUmVmIHtcclxuICAgIGNvbnN0cnVjdG9yKGhhbmRsZSwgeCA9IDAsIHkgPSAwLCB3ID0gMCwgaCA9IDApIHtcclxuICAgICAgICBzdXBlcih4LCB5LCB3LCBoKTtcclxuICAgICAgICB0aGlzLmhhbmRsZSA9IGhhbmRsZTtcclxuICAgICAgICB0aGlzLnQgPSBcImJpbmRcIjtcclxuICAgIH1cclxuICAgIHJlYWQoeCA9IDAsIHkgPSAwLCB3ID0gdGhpcy53aWR0aCwgaCA9IHRoaXMuaGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRyYW5zZmVySW1hZ2VEYXRhKHRoaXMuaGFuZGxlLCB4LCB5LCB3LCBoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmVwcmVzZW50cyBhbiBpbWFnZSBpbiBqcyBtZW1vcnlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBJbWdSZWZEYXRhIGV4dGVuZHMgSW1nUmVmIHtcclxuICAgIGNvbnN0cnVjdG9yKGJ1ZiwgeCA9IDAsIHkgPSAwKSB7XHJcbiAgICAgICAgc3VwZXIoeCwgeSwgYnVmLndpZHRoLCBidWYuaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmJ1ZiA9IGJ1ZjtcclxuICAgICAgICB0aGlzLnQgPSBcImRhdGFcIjtcclxuICAgIH1cclxuICAgIHJlYWQoeCA9IDAsIHkgPSAwLCB3ID0gdGhpcy53aWR0aCwgaCA9IHRoaXMuaGVpZ2h0KSB7XHJcbiAgICAgICAgaWYgKHggPT0gMCAmJiB5ID09IDAgJiYgdyA9PSB0aGlzLndpZHRoICYmIGggPT0gdGhpcy5oZWlnaHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVmO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgciA9IG5ldyBJbWFnZURhdGEodywgaCk7XHJcbiAgICAgICAgZm9yICh2YXIgYiA9IHk7IGIgPCB5ICsgaDsgYisrKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGEgPSB4OyBhIDwgeCArIHc7IGErKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGkxID0gKGEgLSB4KSAqIDQgKyAoYiAtIHkpICogdyAqIDQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgaTIgPSBhICogNCArIGIgKiA0ICogdGhpcy5idWYud2lkdGg7XHJcbiAgICAgICAgICAgICAgICByLmRhdGFbaTFdID0gdGhpcy5idWYuZGF0YVtpMl07XHJcbiAgICAgICAgICAgICAgICByLmRhdGFbaTEgKyAxXSA9IHRoaXMuYnVmLmRhdGFbaTIgKyAxXTtcclxuICAgICAgICAgICAgICAgIHIuZGF0YVtpMSArIDJdID0gdGhpcy5idWYuZGF0YVtpMiArIDJdO1xyXG4gICAgICAgICAgICAgICAgci5kYXRhW2kxICsgM10gPSB0aGlzLmJ1Zi5kYXRhW2kyICsgM107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/@alt1/base/dist/imgref.js\n");

/***/ }),

/***/ "../node_modules/@alt1/base/dist/index.js":
/*!************************************************!*\
  !*** ../node_modules/@alt1/base/dist/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ImageDetect\": () => (/* reexport module object */ _imagedetect_js__WEBPACK_IMPORTED_MODULE_1__),\n/* harmony export */   \"PasteInput\": () => (/* reexport module object */ _pasteinput_js__WEBPACK_IMPORTED_MODULE_2__),\n/* harmony export */   \"Rect\": () => (/* reexport safe */ _rect_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   \"ImageData\": () => (/* reexport safe */ _imagedata_extensions_js__WEBPACK_IMPORTED_MODULE_4__.ImageData),\n/* harmony export */   \"NodePolyfill\": () => (/* reexport module object */ _nodepolyfill_js__WEBPACK_IMPORTED_MODULE_5__),\n/* harmony export */   \"ImgRef\": () => (/* reexport safe */ _imgref_js__WEBPACK_IMPORTED_MODULE_6__.ImgRef),\n/* harmony export */   \"ImgRefBind\": () => (/* reexport safe */ _imgref_js__WEBPACK_IMPORTED_MODULE_6__.ImgRefBind),\n/* harmony export */   \"ImgRefCtx\": () => (/* reexport safe */ _imgref_js__WEBPACK_IMPORTED_MODULE_6__.ImgRefCtx),\n/* harmony export */   \"ImgRefData\": () => (/* reexport safe */ _imgref_js__WEBPACK_IMPORTED_MODULE_6__.ImgRefData),\n/* harmony export */   \"Alt1Error\": () => (/* reexport safe */ _wrapper_js__WEBPACK_IMPORTED_MODULE_7__.Alt1Error),\n/* harmony export */   \"ImageStreamReader\": () => (/* reexport safe */ _wrapper_js__WEBPACK_IMPORTED_MODULE_7__.ImageStreamReader),\n/* harmony export */   \"NoAlt1Error\": () => (/* reexport safe */ _wrapper_js__WEBPACK_IMPORTED_MODULE_7__.NoAlt1Error),\n/* harmony export */   \"addResizeElement\": () => (/* reexport safe */ _wrapper_js__WEBPACK_IMPORTED_MODULE_7__.addResizeElement),\n/* harmony export */   \"capture\": () => (/* reexport safe */ _wrapper_js__WEBPACK_IMPORTED_MODULE_7__.capture),\n/* harmony export */   \"captureAsync\": () => (/* reexport safe */ _wrapper_js__WEBPACK_IMPORTED_MODULE_7__.captureAsync),\n/* harmony export */   \"captureHold\": () => (/* reexport safe */ _wrapper_js__WEBPACK_IMPORTED_MODULE_7__.captureHold),\n/* harmony export */   \"captureHoldFullRs\": () => (/* reexport safe */ _wrapper_js__WEBPACK_IMPORTED_MODULE_7__.captureHoldFullRs),\n/* harmony export */   \"captureHoldScreen\": () => (/* reexport safe */ _wrapper_js__WEBPACK_IMPORTED_MODULE_7__.captureHoldScreen),\n/* harmony export */   \"captureMultiAsync\": () => (/* reexport safe */ _wrapper_js__WEBPACK_IMPORTED_MODULE_7__.captureMultiAsync),\n/* harmony export */   \"captureStream\": () => (/* reexport safe */ _wrapper_js__WEBPACK_IMPORTED_MODULE_7__.captureStream),\n/* harmony export */   \"decodeImageString\": () => (/* reexport safe */ _wrapper_js__WEBPACK_IMPORTED_MODULE_7__.decodeImageString),\n/* harmony export */   \"encodeImageString\": () => (/* reexport safe */ _wrapper_js__WEBPACK_IMPORTED_MODULE_7__.encodeImageString),\n/* harmony export */   \"getMousePosition\": () => (/* reexport safe */ _wrapper_js__WEBPACK_IMPORTED_MODULE_7__.getMousePosition),\n/* harmony export */   \"getdisplaybounds\": () => (/* reexport safe */ _wrapper_js__WEBPACK_IMPORTED_MODULE_7__.getdisplaybounds),\n/* harmony export */   \"hasAlt1\": () => (/* reexport safe */ _wrapper_js__WEBPACK_IMPORTED_MODULE_7__.hasAlt1),\n/* harmony export */   \"hasAlt1Version\": () => (/* reexport safe */ _wrapper_js__WEBPACK_IMPORTED_MODULE_7__.hasAlt1Version),\n/* harmony export */   \"identifyApp\": () => (/* reexport safe */ _wrapper_js__WEBPACK_IMPORTED_MODULE_7__.identifyApp),\n/* harmony export */   \"mixColor\": () => (/* reexport safe */ _wrapper_js__WEBPACK_IMPORTED_MODULE_7__.mixColor),\n/* harmony export */   \"newestversion\": () => (/* reexport safe */ _wrapper_js__WEBPACK_IMPORTED_MODULE_7__.newestversion),\n/* harmony export */   \"on\": () => (/* reexport safe */ _wrapper_js__WEBPACK_IMPORTED_MODULE_7__.on),\n/* harmony export */   \"once\": () => (/* reexport safe */ _wrapper_js__WEBPACK_IMPORTED_MODULE_7__.once),\n/* harmony export */   \"openbrowser\": () => (/* reexport safe */ _wrapper_js__WEBPACK_IMPORTED_MODULE_7__.openbrowser),\n/* harmony export */   \"removeListener\": () => (/* reexport safe */ _wrapper_js__WEBPACK_IMPORTED_MODULE_7__.removeListener),\n/* harmony export */   \"requireAlt1\": () => (/* reexport safe */ _wrapper_js__WEBPACK_IMPORTED_MODULE_7__.requireAlt1),\n/* harmony export */   \"resetEnvironment\": () => (/* reexport safe */ _wrapper_js__WEBPACK_IMPORTED_MODULE_7__.resetEnvironment),\n/* harmony export */   \"skinName\": () => (/* reexport safe */ _wrapper_js__WEBPACK_IMPORTED_MODULE_7__.skinName),\n/* harmony export */   \"transferImageData\": () => (/* reexport safe */ _wrapper_js__WEBPACK_IMPORTED_MODULE_7__.transferImageData),\n/* harmony export */   \"unmixColor\": () => (/* reexport safe */ _wrapper_js__WEBPACK_IMPORTED_MODULE_7__.unmixColor)\n/* harmony export */ });\n/* harmony import */ var _declarations_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./declarations.js */ \"../node_modules/@alt1/base/dist/declarations.js\");\n/* harmony import */ var _declarations_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_declarations_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _imagedetect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./imagedetect.js */ \"../node_modules/@alt1/base/dist/imagedetect.js\");\n/* harmony import */ var _pasteinput_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pasteinput.js */ \"../node_modules/@alt1/base/dist/pasteinput.js\");\n/* harmony import */ var _rect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rect.js */ \"../node_modules/@alt1/base/dist/rect.js\");\n/* harmony import */ var _imagedata_extensions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./imagedata-extensions.js */ \"../node_modules/@alt1/base/dist/imagedata-extensions.js\");\n/* harmony import */ var _nodepolyfill_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./nodepolyfill.js */ \"../node_modules/@alt1/base/dist/nodepolyfill.js\");\n/* harmony import */ var _imgref_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./imgref.js */ \"../node_modules/@alt1/base/dist/imgref.js\");\n/* harmony import */ var _wrapper_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./wrapper.js */ \"../node_modules/@alt1/base/dist/wrapper.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BhbHQxL2Jhc2UvZGlzdC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEyQjtBQUNxQjtBQUNGO0FBQ0Y7QUFDVTtBQUNKO0FBQ3RCO0FBQ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9URVNULy4uL25vZGVfbW9kdWxlcy9AYWx0MS9iYXNlL2Rpc3QvaW5kZXguanM/YjVjOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgXCIuL2RlY2xhcmF0aW9ucy5qc1wiO1xyXG5leHBvcnQgKiBhcyBJbWFnZURldGVjdCBmcm9tIFwiLi9pbWFnZWRldGVjdC5qc1wiO1xyXG5leHBvcnQgKiBhcyBQYXN0ZUlucHV0IGZyb20gXCIuL3Bhc3RlaW5wdXQuanNcIjtcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBSZWN0IH0gZnJvbSBcIi4vcmVjdC5qc1wiO1xyXG5leHBvcnQgeyBJbWFnZURhdGEgfSBmcm9tIFwiLi9pbWFnZWRhdGEtZXh0ZW5zaW9ucy5qc1wiO1xyXG5leHBvcnQgKiBhcyBOb2RlUG9seWZpbGwgZnJvbSBcIi4vbm9kZXBvbHlmaWxsLmpzXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL2ltZ3JlZi5qc1wiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi93cmFwcGVyLmpzXCI7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/@alt1/base/dist/index.js\n");

/***/ }),

/***/ "../node_modules/@alt1/base/dist/nodepolyfill.js":
/*!*******************************************************!*\
  !*** ../node_modules/@alt1/base/dist/nodepolyfill.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"polyfillRequire\": () => (/* binding */ polyfillRequire),\n/* harmony export */   \"requireSharp\": () => (/* binding */ requireSharp),\n/* harmony export */   \"requireNodeCanvas\": () => (/* binding */ requireNodeCanvas),\n/* harmony export */   \"requireElectronCommon\": () => (/* binding */ requireElectronCommon),\n/* harmony export */   \"imageDataToDrawable\": () => (/* binding */ imageDataToDrawable),\n/* harmony export */   \"createCanvas\": () => (/* binding */ createCanvas),\n/* harmony export */   \"imageDataToFileBytes\": () => (/* binding */ imageDataToFileBytes),\n/* harmony export */   \"imageDataFromBase64\": () => (/* binding */ imageDataFromBase64),\n/* harmony export */   \"imageDataFromBuffer\": () => (/* binding */ imageDataFromBuffer)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ \"../node_modules/@alt1/base/dist/index.js\");\n/* harmony import */ var _imagedetect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./imagedetect.js */ \"../node_modules/@alt1/base/dist/imagedetect.js\");\n//nodejs and electron polyfills for web api's\r\n//commented out type info as that breaks webpack with optional dependencies\r\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\nvar requirefunction = null;\r\n/**\r\n * Call this function to let the libs require extra dependencies on nodejs in order\r\n * to polyfill some browser api's (mostly image compression/decompression)\r\n * `NodePolifill.polyfillRequire(require);` should solve most cases\r\n */\r\nfunction polyfillRequire(requirefn) {\r\n    requirefunction = requirefn;\r\n}\r\nfunction requireSharp() {\r\n    try {\r\n        if (requirefunction) {\r\n            return requirefunction(\"sharp\");\r\n        }\r\n        else {\r\n            return require(/* webpackIgnore: true */ \"sharp\"); // as typeof import(\"sharp\");\r\n        }\r\n    }\r\n    catch (e) { }\r\n    return null;\r\n}\r\nfunction requireNodeCanvas() {\r\n    //attempt to require sharp first, after loading canvas the module sharp fails to load\r\n    requireSharp();\r\n    try {\r\n        if (requirefunction) {\r\n            return requirefunction(\"canvas\");\r\n        }\r\n        else {\r\n            return require(/* webpackIgnore: true */ \"canvas\"); // as typeof import(\"sharp\");\r\n        }\r\n    }\r\n    catch (e) { }\r\n    return null;\r\n}\r\nfunction requireElectronCommon() {\r\n    try {\r\n        if (requirefunction) {\r\n            return requirefunction(\"electron/common\");\r\n        }\r\n        else {\r\n            return require(/* webpackIgnore: true */ \"electron/common\");\r\n        }\r\n    }\r\n    catch (e) { }\r\n    return null;\r\n}\r\nfunction imageDataToDrawable(buf) {\r\n    let nodecnv = requireNodeCanvas();\r\n    if (!nodecnv) {\r\n        throw new Error(\"couldn't find built-in canvas or the module 'canvas'\");\r\n    }\r\n    return new nodecnv.ImageData(buf.data, buf.width, buf.height);\r\n}\r\nfunction createCanvas(w, h) {\r\n    let nodecnv = requireNodeCanvas();\r\n    if (!nodecnv) {\r\n        throw new Error(\"couldn't find built-in canvas or the module 'canvas'\");\r\n    }\r\n    return nodecnv.createCanvas(w, h);\r\n}\r\nfunction flipBGRAtoRGBA(data) {\r\n    for (let i = 0; i < data.length; i += 4) {\r\n        let tmp = data[i + 2];\r\n        data[i + 2] = data[i + 0];\r\n        data[i + 0] = tmp;\r\n    }\r\n}\r\nfunction imageDataToFileBytes(buf, format, quality) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        //use the electron API if we're in electron\r\n        var electronCommon;\r\n        var sharp;\r\n        if (electronCommon = requireElectronCommon()) {\r\n            let nativeImage = electronCommon.nativeImage;\r\n            //need to copy the buffer in order to flip it without destroying the original\r\n            let bufcpy = Buffer.from(buf.data.slice(buf.data.byteOffset, buf.data.byteLength));\r\n            flipBGRAtoRGBA(bufcpy);\r\n            let nativeimg = nativeImage.createFromBitmap(bufcpy, { width: buf.width, height: buf.height });\r\n            return nativeimg.toPNG();\r\n        }\r\n        else if (sharp = requireSharp()) {\r\n            let img = sharp(Buffer.from(buf.data.buffer), { raw: { width: buf.width, height: buf.height, channels: 4 } });\r\n            if (format == \"image/png\") {\r\n                img.png();\r\n            }\r\n            else if (format == \"image/webp\") {\r\n                var opts = { quality: 80 };\r\n                if (typeof quality == \"number\") {\r\n                    opts.quality = quality * 100;\r\n                }\r\n                img.webp(opts);\r\n            }\r\n            else {\r\n                throw new Error(\"unknown image format: \" + format);\r\n            }\r\n            return yield img.toBuffer({ resolveWithObject: false }).buffer;\r\n        }\r\n        throw new Error(\"coulnd't find build-in image compression methods or the module 'electron/common' or 'sharp'\");\r\n    });\r\n}\r\nfunction imageDataFromBase64(base64) {\r\n    return imageDataFromBuffer(Buffer.from(base64, \"base64\"));\r\n}\r\nfunction imageDataFromBuffer(buffer) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        (0,_imagedetect_js__WEBPACK_IMPORTED_MODULE_1__.clearPngColorspace)(buffer);\r\n        //use the electron API if we're in electron\r\n        var electronCommon;\r\n        var nodecnv;\r\n        if (electronCommon = requireElectronCommon()) {\r\n            let nativeImage = electronCommon.nativeImage;\r\n            let img = nativeImage.createFromBuffer(buffer);\r\n            let pixels = img.toBitmap();\r\n            let size = img.getSize();\r\n            let pixbuf = new Uint8ClampedArray(pixels.buffer, pixels.byteOffset, pixels.byteLength);\r\n            flipBGRAtoRGBA(pixbuf);\r\n            return new _index_js__WEBPACK_IMPORTED_MODULE_0__.ImageData(pixbuf, size.width, size.height);\r\n        }\r\n        else if (nodecnv = requireNodeCanvas()) {\r\n            return new Promise((done, err) => {\r\n                let img = new nodecnv.Image();\r\n                img.onerror = err;\r\n                img.onload = () => {\r\n                    var cnv = nodecnv.createCanvas(img.naturalWidth, img.naturalHeight);\r\n                    var ctx = cnv.getContext(\"2d\");\r\n                    ctx.drawImage(img, 0, 0);\r\n                    var data = ctx.getImageData(0, 0, img.naturalWidth, img.naturalHeight);\r\n                    //use our own class\r\n                    done(new _index_js__WEBPACK_IMPORTED_MODULE_0__.ImageData(data.data, data.width, data.height));\r\n                };\r\n                img.src = Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);\r\n            });\r\n        }\r\n        throw new Error(\"couldn't find built-in canvas, module 'electron/common' or the module 'canvas'\");\r\n    });\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BhbHQxL2Jhc2UvZGlzdC9ub2RlcG9seWZpbGwuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQUksSUFBSSxTQUFJO0FBQzdCLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ3VDO0FBQ2U7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLHNDQUFzQztBQUN6RztBQUNBO0FBQ0E7QUFDQSw0REFBNEQsT0FBTyxxREFBcUQ7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywwQkFBMEI7QUFDbEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQSxRQUFRLG1FQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnREFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdEQUFTO0FBQ3RDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTCIsInNvdXJjZXMiOlsid2VicGFjazovL1RFU1QvLi4vbm9kZV9tb2R1bGVzL0BhbHQxL2Jhc2UvZGlzdC9ub2RlcG9seWZpbGwuanM/NTYwZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvL25vZGVqcyBhbmQgZWxlY3Ryb24gcG9seWZpbGxzIGZvciB3ZWIgYXBpJ3NcclxuLy9jb21tZW50ZWQgb3V0IHR5cGUgaW5mbyBhcyB0aGF0IGJyZWFrcyB3ZWJwYWNrIHdpdGggb3B0aW9uYWwgZGVwZW5kZW5jaWVzXHJcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufTtcclxuaW1wb3J0IHsgSW1hZ2VEYXRhIH0gZnJvbSBcIi4vaW5kZXguanNcIjtcclxuaW1wb3J0IHsgY2xlYXJQbmdDb2xvcnNwYWNlIH0gZnJvbSBcIi4vaW1hZ2VkZXRlY3QuanNcIjtcclxudmFyIHJlcXVpcmVmdW5jdGlvbiA9IG51bGw7XHJcbi8qKlxyXG4gKiBDYWxsIHRoaXMgZnVuY3Rpb24gdG8gbGV0IHRoZSBsaWJzIHJlcXVpcmUgZXh0cmEgZGVwZW5kZW5jaWVzIG9uIG5vZGVqcyBpbiBvcmRlclxyXG4gKiB0byBwb2x5ZmlsbCBzb21lIGJyb3dzZXIgYXBpJ3MgKG1vc3RseSBpbWFnZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uKVxyXG4gKiBgTm9kZVBvbGlmaWxsLnBvbHlmaWxsUmVxdWlyZShyZXF1aXJlKTtgIHNob3VsZCBzb2x2ZSBtb3N0IGNhc2VzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcG9seWZpbGxSZXF1aXJlKHJlcXVpcmVmbikge1xyXG4gICAgcmVxdWlyZWZ1bmN0aW9uID0gcmVxdWlyZWZuO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiByZXF1aXJlU2hhcnAoKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmIChyZXF1aXJlZnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcXVpcmVmdW5jdGlvbihcInNoYXJwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcXVpcmUoLyogd2VicGFja0lnbm9yZTogdHJ1ZSAqLyBcInNoYXJwXCIpOyAvLyBhcyB0eXBlb2YgaW1wb3J0KFwic2hhcnBcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHsgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHJlcXVpcmVOb2RlQ2FudmFzKCkge1xyXG4gICAgLy9hdHRlbXB0IHRvIHJlcXVpcmUgc2hhcnAgZmlyc3QsIGFmdGVyIGxvYWRpbmcgY2FudmFzIHRoZSBtb2R1bGUgc2hhcnAgZmFpbHMgdG8gbG9hZFxyXG4gICAgcmVxdWlyZVNoYXJwKCk7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmIChyZXF1aXJlZnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcXVpcmVmdW5jdGlvbihcImNhbnZhc1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXF1aXJlKC8qIHdlYnBhY2tJZ25vcmU6IHRydWUgKi8gXCJjYW52YXNcIik7IC8vIGFzIHR5cGVvZiBpbXBvcnQoXCJzaGFycFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkgeyB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gcmVxdWlyZUVsZWN0cm9uQ29tbW9uKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAocmVxdWlyZWZ1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXF1aXJlZnVuY3Rpb24oXCJlbGVjdHJvbi9jb21tb25cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVxdWlyZSgvKiB3ZWJwYWNrSWdub3JlOiB0cnVlICovIFwiZWxlY3Ryb24vY29tbW9uXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7IH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBpbWFnZURhdGFUb0RyYXdhYmxlKGJ1Zikge1xyXG4gICAgbGV0IG5vZGVjbnYgPSByZXF1aXJlTm9kZUNhbnZhcygpO1xyXG4gICAgaWYgKCFub2RlY252KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY291bGRuJ3QgZmluZCBidWlsdC1pbiBjYW52YXMgb3IgdGhlIG1vZHVsZSAnY2FudmFzJ1wiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgbm9kZWNudi5JbWFnZURhdGEoYnVmLmRhdGEsIGJ1Zi53aWR0aCwgYnVmLmhlaWdodCk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNhbnZhcyh3LCBoKSB7XHJcbiAgICBsZXQgbm9kZWNudiA9IHJlcXVpcmVOb2RlQ2FudmFzKCk7XHJcbiAgICBpZiAoIW5vZGVjbnYpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb3VsZG4ndCBmaW5kIGJ1aWx0LWluIGNhbnZhcyBvciB0aGUgbW9kdWxlICdjYW52YXMnXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5vZGVjbnYuY3JlYXRlQ2FudmFzKHcsIGgpO1xyXG59XHJcbmZ1bmN0aW9uIGZsaXBCR1JBdG9SR0JBKGRhdGEpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xyXG4gICAgICAgIGxldCB0bXAgPSBkYXRhW2kgKyAyXTtcclxuICAgICAgICBkYXRhW2kgKyAyXSA9IGRhdGFbaSArIDBdO1xyXG4gICAgICAgIGRhdGFbaSArIDBdID0gdG1wO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBpbWFnZURhdGFUb0ZpbGVCeXRlcyhidWYsIGZvcm1hdCwgcXVhbGl0eSkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAvL3VzZSB0aGUgZWxlY3Ryb24gQVBJIGlmIHdlJ3JlIGluIGVsZWN0cm9uXHJcbiAgICAgICAgdmFyIGVsZWN0cm9uQ29tbW9uO1xyXG4gICAgICAgIHZhciBzaGFycDtcclxuICAgICAgICBpZiAoZWxlY3Ryb25Db21tb24gPSByZXF1aXJlRWxlY3Ryb25Db21tb24oKSkge1xyXG4gICAgICAgICAgICBsZXQgbmF0aXZlSW1hZ2UgPSBlbGVjdHJvbkNvbW1vbi5uYXRpdmVJbWFnZTtcclxuICAgICAgICAgICAgLy9uZWVkIHRvIGNvcHkgdGhlIGJ1ZmZlciBpbiBvcmRlciB0byBmbGlwIGl0IHdpdGhvdXQgZGVzdHJveWluZyB0aGUgb3JpZ2luYWxcclxuICAgICAgICAgICAgbGV0IGJ1ZmNweSA9IEJ1ZmZlci5mcm9tKGJ1Zi5kYXRhLnNsaWNlKGJ1Zi5kYXRhLmJ5dGVPZmZzZXQsIGJ1Zi5kYXRhLmJ5dGVMZW5ndGgpKTtcclxuICAgICAgICAgICAgZmxpcEJHUkF0b1JHQkEoYnVmY3B5KTtcclxuICAgICAgICAgICAgbGV0IG5hdGl2ZWltZyA9IG5hdGl2ZUltYWdlLmNyZWF0ZUZyb21CaXRtYXAoYnVmY3B5LCB7IHdpZHRoOiBidWYud2lkdGgsIGhlaWdodDogYnVmLmhlaWdodCB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZWltZy50b1BORygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzaGFycCA9IHJlcXVpcmVTaGFycCgpKSB7XHJcbiAgICAgICAgICAgIGxldCBpbWcgPSBzaGFycChCdWZmZXIuZnJvbShidWYuZGF0YS5idWZmZXIpLCB7IHJhdzogeyB3aWR0aDogYnVmLndpZHRoLCBoZWlnaHQ6IGJ1Zi5oZWlnaHQsIGNoYW5uZWxzOiA0IH0gfSk7XHJcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT0gXCJpbWFnZS9wbmdcIikge1xyXG4gICAgICAgICAgICAgICAgaW1nLnBuZygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdCA9PSBcImltYWdlL3dlYnBcIikge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9wdHMgPSB7IHF1YWxpdHk6IDgwIH07XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHF1YWxpdHkgPT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdHMucXVhbGl0eSA9IHF1YWxpdHkgKiAxMDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbWcud2VicChvcHRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gaW1hZ2UgZm9ybWF0OiBcIiArIGZvcm1hdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGltZy50b0J1ZmZlcih7IHJlc29sdmVXaXRoT2JqZWN0OiBmYWxzZSB9KS5idWZmZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvdWxuZCd0IGZpbmQgYnVpbGQtaW4gaW1hZ2UgY29tcHJlc3Npb24gbWV0aG9kcyBvciB0aGUgbW9kdWxlICdlbGVjdHJvbi9jb21tb24nIG9yICdzaGFycCdcIik7XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gaW1hZ2VEYXRhRnJvbUJhc2U2NChiYXNlNjQpIHtcclxuICAgIHJldHVybiBpbWFnZURhdGFGcm9tQnVmZmVyKEJ1ZmZlci5mcm9tKGJhc2U2NCwgXCJiYXNlNjRcIikpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBpbWFnZURhdGFGcm9tQnVmZmVyKGJ1ZmZlcikge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBjbGVhclBuZ0NvbG9yc3BhY2UoYnVmZmVyKTtcclxuICAgICAgICAvL3VzZSB0aGUgZWxlY3Ryb24gQVBJIGlmIHdlJ3JlIGluIGVsZWN0cm9uXHJcbiAgICAgICAgdmFyIGVsZWN0cm9uQ29tbW9uO1xyXG4gICAgICAgIHZhciBub2RlY252O1xyXG4gICAgICAgIGlmIChlbGVjdHJvbkNvbW1vbiA9IHJlcXVpcmVFbGVjdHJvbkNvbW1vbigpKSB7XHJcbiAgICAgICAgICAgIGxldCBuYXRpdmVJbWFnZSA9IGVsZWN0cm9uQ29tbW9uLm5hdGl2ZUltYWdlO1xyXG4gICAgICAgICAgICBsZXQgaW1nID0gbmF0aXZlSW1hZ2UuY3JlYXRlRnJvbUJ1ZmZlcihidWZmZXIpO1xyXG4gICAgICAgICAgICBsZXQgcGl4ZWxzID0gaW1nLnRvQml0bWFwKCk7XHJcbiAgICAgICAgICAgIGxldCBzaXplID0gaW1nLmdldFNpemUoKTtcclxuICAgICAgICAgICAgbGV0IHBpeGJ1ZiA9IG5ldyBVaW50OENsYW1wZWRBcnJheShwaXhlbHMuYnVmZmVyLCBwaXhlbHMuYnl0ZU9mZnNldCwgcGl4ZWxzLmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgICAgICBmbGlwQkdSQXRvUkdCQShwaXhidWYpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEltYWdlRGF0YShwaXhidWYsIHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobm9kZWNudiA9IHJlcXVpcmVOb2RlQ2FudmFzKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChkb25lLCBlcnIpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBpbWcgPSBuZXcgbm9kZWNudi5JbWFnZSgpO1xyXG4gICAgICAgICAgICAgICAgaW1nLm9uZXJyb3IgPSBlcnI7XHJcbiAgICAgICAgICAgICAgICBpbWcub25sb2FkID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbnYgPSBub2RlY252LmNyZWF0ZUNhbnZhcyhpbWcubmF0dXJhbFdpZHRoLCBpbWcubmF0dXJhbEhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN0eCA9IGNudi5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBpbWcubmF0dXJhbFdpZHRoLCBpbWcubmF0dXJhbEhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy91c2Ugb3VyIG93biBjbGFzc1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbmUobmV3IEltYWdlRGF0YShkYXRhLmRhdGEsIGRhdGEud2lkdGgsIGRhdGEuaGVpZ2h0KSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgaW1nLnNyYyA9IEJ1ZmZlci5mcm9tKGJ1ZmZlci5idWZmZXIsIGJ1ZmZlci5ieXRlT2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb3VsZG4ndCBmaW5kIGJ1aWx0LWluIGNhbnZhcywgbW9kdWxlICdlbGVjdHJvbi9jb21tb24nIG9yIHRoZSBtb2R1bGUgJ2NhbnZhcydcIik7XHJcbiAgICB9KTtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/@alt1/base/dist/nodepolyfill.js\n");

/***/ }),

/***/ "../node_modules/@alt1/base/dist/pasteinput.js":
/*!*****************************************************!*\
  !*** ../node_modules/@alt1/base/dist/pasteinput.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"lastref\": () => (/* binding */ lastref),\n/* harmony export */   \"listen\": () => (/* binding */ listen),\n/* harmony export */   \"unlisten\": () => (/* binding */ unlisten),\n/* harmony export */   \"triggerPaste\": () => (/* binding */ triggerPaste),\n/* harmony export */   \"startDragNDrop\": () => (/* binding */ startDragNDrop),\n/* harmony export */   \"start\": () => (/* binding */ start),\n/* harmony export */   \"fileDialog\": () => (/* binding */ fileDialog)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ \"../node_modules/@alt1/base/dist/index.js\");\n/* harmony import */ var _imagedetect_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./imagedetect.js */ \"../node_modules/@alt1/base/dist/imagedetect.js\");\n\r\n\r\nvar listeners = [];\r\nvar started = false;\r\nvar dndStarted = false;\r\nvar pasting = false;\r\nvar lastref = null;\r\nfunction listen(func, errorfunc, dragndrop) {\r\n    listeners.push({ cb: func, error: errorfunc });\r\n    if (!started) {\r\n        start();\r\n    }\r\n    if (dragndrop && !dndStarted) {\r\n        startDragNDrop();\r\n    }\r\n}\r\nfunction unlisten(func) {\r\n    let i = listeners.findIndex(c => c.cb == func);\r\n    if (i != -1) {\r\n        listeners.splice(i, 1);\r\n    }\r\n}\r\n/**\r\n * currently used in multiple document situations (iframe), might be removed in the future\r\n */\r\nfunction triggerPaste(img) {\r\n    lastref = img;\r\n    for (var a in listeners) {\r\n        listeners[a].cb(lastref);\r\n    }\r\n}\r\nfunction pasted(img) {\r\n    pasting = false;\r\n    let cnv = img instanceof HTMLCanvasElement ? img : img.toCanvas();\r\n    triggerPaste(new _index_js__WEBPACK_IMPORTED_MODULE_0__.ImgRefCtx(cnv));\r\n}\r\nfunction error(error, mes) {\r\n    var _a, _b;\r\n    pasting = false;\r\n    for (var a in listeners) {\r\n        (_b = (_a = listeners[a]).error) === null || _b === void 0 ? void 0 : _b.call(_a, mes, error);\r\n    }\r\n}\r\nfunction startDragNDrop() {\r\n    var getitem = function (items) {\r\n        var foundimage = \"\";\r\n        for (var a = 0; a < items.length; a++) {\r\n            var item = items[a];\r\n            var m = item.type.match(/^image\\/(\\w+)$/);\r\n            if (m) {\r\n                if (m[1] == \"png\") {\r\n                    return item;\r\n                }\r\n                else {\r\n                    foundimage = m[1];\r\n                }\r\n            }\r\n        }\r\n        if (foundimage) {\r\n            error(\"notpng\", \"The image you uploaded is not a .png image. Other image type have compression noise and can't be used for image detection.\");\r\n        }\r\n        return null;\r\n    };\r\n    window.addEventListener(\"dragover\", function (e) {\r\n        e.preventDefault();\r\n    });\r\n    window.addEventListener(\"drop\", function (e) {\r\n        if (!e.dataTransfer) {\r\n            return;\r\n        }\r\n        var item = getitem(e.dataTransfer.items);\r\n        e.preventDefault();\r\n        if (!item) {\r\n            return;\r\n        }\r\n        fromFile(item.getAsFile());\r\n    });\r\n}\r\nfunction start() {\r\n    if (started) {\r\n        return;\r\n    }\r\n    started = true;\r\n    //determine if we have a clipboard api\r\n    //try{a=new Event(\"clipboard\"); a=\"clipboardData\" in a;}\r\n    //catch(e){a=false;}\r\n    var ischrome = !!navigator.userAgent.match(/Chrome/) && !navigator.userAgent.match(/Edge/);\r\n    //old method breaks after chrome 41, revert to good old user agent sniffing\r\n    //nvm, internet explorer (edge) decided that it wants to be chrome, however fails at delivering\r\n    //turns out this one is interesting, edge is a hybrid between the paste api's\r\n    var apipasted = function (e) {\r\n        if (!e.clipboardData) {\r\n            return;\r\n        }\r\n        for (var a = 0; a < e.clipboardData.items.length; a++) { //loop all data types\r\n            if (e.clipboardData.items[a].type.indexOf(\"image\") != -1) {\r\n                var file = e.clipboardData.items[a].getAsFile();\r\n                var img = new Image();\r\n                img.src = (window.URL || window.webkitURL).createObjectURL(file);\r\n                if (img.width > 0) {\r\n                    pasted(img);\r\n                }\r\n                else {\r\n                    img.onload = function () { pasted(img); };\r\n                }\r\n            }\r\n        }\r\n    };\r\n    if (ischrome) {\r\n        document.addEventListener(\"paste\", apipasted);\r\n    }\r\n    else {\r\n        var catcher = document.createElement(\"div\");\r\n        catcher.setAttribute(\"contenteditable\", \"\");\r\n        catcher.className = \"forcehidden\"; //retarded ie safety/bug, cant apply styles using js//TODO i don't even know what's going on\r\n        catcher.onpaste = function (e) {\r\n            if (e.clipboardData && e.clipboardData.items) {\r\n                apipasted(e);\r\n                return;\r\n            }\r\n            setTimeout(function () {\r\n                var b = catcher.children[0];\r\n                if (!b || b.tagName != \"IMG\") {\r\n                    return;\r\n                }\r\n                var img = new Image();\r\n                img.src = b.src;\r\n                var a = img.src.match(/^data:([\\w\\/]+);/);\r\n                if (img.width > 0) {\r\n                    pasted(img);\r\n                }\r\n                else {\r\n                    img.onload = function () { pasted(img); };\r\n                }\r\n                catcher.innerHTML = \"\";\r\n            }, 1);\r\n        };\r\n        document.body.appendChild(catcher);\r\n    }\r\n    //detect if ctrl-v is pressed and focus catcher if needed\r\n    document.addEventListener(\"keydown\", function (e) {\r\n        if (e.target.tagName == \"INPUT\") {\r\n            return;\r\n        }\r\n        if (e.keyCode != \"V\".charCodeAt(0) || !e.ctrlKey) {\r\n            return;\r\n        }\r\n        pasting = true;\r\n        setTimeout(function () {\r\n            if (pasting) {\r\n                error(\"noimg\", \"You pressed Ctrl+V, but no image was pasted by your browser, make sure your clipboard contains an image, and not a link to an image.\");\r\n            }\r\n        }, 1000);\r\n        if (catcher) {\r\n            catcher.focus();\r\n        }\r\n    });\r\n}\r\nfunction fileDialog() {\r\n    var fileinput = document.createElement(\"input\");\r\n    fileinput.type = \"file\";\r\n    fileinput.accept = \"image/png\";\r\n    fileinput.onchange = function () { if (fileinput.files && fileinput.files[0]) {\r\n        fromFile(fileinput.files[0]);\r\n    } };\r\n    fileinput.click();\r\n    return fileinput;\r\n}\r\nfunction fromFile(file) {\r\n    if (!file) {\r\n        return;\r\n    }\r\n    var reader = new FileReader();\r\n    reader.onload = function () {\r\n        var bytearray = new Uint8Array(reader.result);\r\n        if (_imagedetect_js__WEBPACK_IMPORTED_MODULE_1__.isPngBuffer(bytearray)) {\r\n            _imagedetect_js__WEBPACK_IMPORTED_MODULE_1__.clearPngColorspace(bytearray);\r\n        }\r\n        var blob = new Blob([bytearray], { type: \"image/png\" });\r\n        var img = new Image();\r\n        img.onerror = () => error(\"invalidfile\", \"The file you uploaded could not be opened as an image.\");\r\n        var bloburl = URL.createObjectURL(blob);\r\n        img.src = bloburl;\r\n        if (img.width > 0) {\r\n            pasted(img);\r\n            URL.revokeObjectURL(bloburl);\r\n        }\r\n        else {\r\n            img.onload = function () { pasted(img); URL.revokeObjectURL(bloburl); };\r\n        }\r\n    };\r\n    reader.readAsArrayBuffer(file);\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BhbHQxL2Jhc2UvZGlzdC9wYXN0ZWlucHV0LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUF1QztBQUNTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNQLHFCQUFxQiw0QkFBNEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0RBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwwQkFBMEI7QUFDcEMsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0NBQWtDLE9BQU87QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdEQUF1QjtBQUNuQyxZQUFZLCtEQUE4QjtBQUMxQztBQUNBLDJDQUEyQyxtQkFBbUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGFBQWE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9URVNULy4uL25vZGVfbW9kdWxlcy9AYWx0MS9iYXNlL2Rpc3QvcGFzdGVpbnB1dC5qcz85ZTY2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEltZ1JlZkN0eCB9IGZyb20gXCIuL2luZGV4LmpzXCI7XHJcbmltcG9ydCAqIGFzIEltYWdlRGV0ZWN0IGZyb20gXCIuL2ltYWdlZGV0ZWN0LmpzXCI7XHJcbnZhciBsaXN0ZW5lcnMgPSBbXTtcclxudmFyIHN0YXJ0ZWQgPSBmYWxzZTtcclxudmFyIGRuZFN0YXJ0ZWQgPSBmYWxzZTtcclxudmFyIHBhc3RpbmcgPSBmYWxzZTtcclxuZXhwb3J0IHZhciBsYXN0cmVmID0gbnVsbDtcclxuZXhwb3J0IGZ1bmN0aW9uIGxpc3RlbihmdW5jLCBlcnJvcmZ1bmMsIGRyYWduZHJvcCkge1xyXG4gICAgbGlzdGVuZXJzLnB1c2goeyBjYjogZnVuYywgZXJyb3I6IGVycm9yZnVuYyB9KTtcclxuICAgIGlmICghc3RhcnRlZCkge1xyXG4gICAgICAgIHN0YXJ0KCk7XHJcbiAgICB9XHJcbiAgICBpZiAoZHJhZ25kcm9wICYmICFkbmRTdGFydGVkKSB7XHJcbiAgICAgICAgc3RhcnREcmFnTkRyb3AoKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgZnVuY3Rpb24gdW5saXN0ZW4oZnVuYykge1xyXG4gICAgbGV0IGkgPSBsaXN0ZW5lcnMuZmluZEluZGV4KGMgPT4gYy5jYiA9PSBmdW5jKTtcclxuICAgIGlmIChpICE9IC0xKSB7XHJcbiAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogY3VycmVudGx5IHVzZWQgaW4gbXVsdGlwbGUgZG9jdW1lbnQgc2l0dWF0aW9ucyAoaWZyYW1lKSwgbWlnaHQgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdHJpZ2dlclBhc3RlKGltZykge1xyXG4gICAgbGFzdHJlZiA9IGltZztcclxuICAgIGZvciAodmFyIGEgaW4gbGlzdGVuZXJzKSB7XHJcbiAgICAgICAgbGlzdGVuZXJzW2FdLmNiKGxhc3RyZWYpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHBhc3RlZChpbWcpIHtcclxuICAgIHBhc3RpbmcgPSBmYWxzZTtcclxuICAgIGxldCBjbnYgPSBpbWcgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCA/IGltZyA6IGltZy50b0NhbnZhcygpO1xyXG4gICAgdHJpZ2dlclBhc3RlKG5ldyBJbWdSZWZDdHgoY252KSk7XHJcbn1cclxuZnVuY3Rpb24gZXJyb3IoZXJyb3IsIG1lcykge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIHBhc3RpbmcgPSBmYWxzZTtcclxuICAgIGZvciAodmFyIGEgaW4gbGlzdGVuZXJzKSB7XHJcbiAgICAgICAgKF9iID0gKF9hID0gbGlzdGVuZXJzW2FdKS5lcnJvcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIG1lcywgZXJyb3IpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBzdGFydERyYWdORHJvcCgpIHtcclxuICAgIHZhciBnZXRpdGVtID0gZnVuY3Rpb24gKGl0ZW1zKSB7XHJcbiAgICAgICAgdmFyIGZvdW5kaW1hZ2UgPSBcIlwiO1xyXG4gICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgaXRlbXMubGVuZ3RoOyBhKyspIHtcclxuICAgICAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1thXTtcclxuICAgICAgICAgICAgdmFyIG0gPSBpdGVtLnR5cGUubWF0Y2goL15pbWFnZVxcLyhcXHcrKSQvKTtcclxuICAgICAgICAgICAgaWYgKG0pIHtcclxuICAgICAgICAgICAgICAgIGlmIChtWzFdID09IFwicG5nXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kaW1hZ2UgPSBtWzFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmb3VuZGltYWdlKSB7XHJcbiAgICAgICAgICAgIGVycm9yKFwibm90cG5nXCIsIFwiVGhlIGltYWdlIHlvdSB1cGxvYWRlZCBpcyBub3QgYSAucG5nIGltYWdlLiBPdGhlciBpbWFnZSB0eXBlIGhhdmUgY29tcHJlc3Npb24gbm9pc2UgYW5kIGNhbid0IGJlIHVzZWQgZm9yIGltYWdlIGRldGVjdGlvbi5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ292ZXJcIiwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9KTtcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZHJvcFwiLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGlmICghZS5kYXRhVHJhbnNmZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaXRlbSA9IGdldGl0ZW0oZS5kYXRhVHJhbnNmZXIuaXRlbXMpO1xyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBpZiAoIWl0ZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmcm9tRmlsZShpdGVtLmdldEFzRmlsZSgpKTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBzdGFydCgpIHtcclxuICAgIGlmIChzdGFydGVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgc3RhcnRlZCA9IHRydWU7XHJcbiAgICAvL2RldGVybWluZSBpZiB3ZSBoYXZlIGEgY2xpcGJvYXJkIGFwaVxyXG4gICAgLy90cnl7YT1uZXcgRXZlbnQoXCJjbGlwYm9hcmRcIik7IGE9XCJjbGlwYm9hcmREYXRhXCIgaW4gYTt9XHJcbiAgICAvL2NhdGNoKGUpe2E9ZmFsc2U7fVxyXG4gICAgdmFyIGlzY2hyb21lID0gISFuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9DaHJvbWUvKSAmJiAhbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvRWRnZS8pO1xyXG4gICAgLy9vbGQgbWV0aG9kIGJyZWFrcyBhZnRlciBjaHJvbWUgNDEsIHJldmVydCB0byBnb29kIG9sZCB1c2VyIGFnZW50IHNuaWZmaW5nXHJcbiAgICAvL252bSwgaW50ZXJuZXQgZXhwbG9yZXIgKGVkZ2UpIGRlY2lkZWQgdGhhdCBpdCB3YW50cyB0byBiZSBjaHJvbWUsIGhvd2V2ZXIgZmFpbHMgYXQgZGVsaXZlcmluZ1xyXG4gICAgLy90dXJucyBvdXQgdGhpcyBvbmUgaXMgaW50ZXJlc3RpbmcsIGVkZ2UgaXMgYSBoeWJyaWQgYmV0d2VlbiB0aGUgcGFzdGUgYXBpJ3NcclxuICAgIHZhciBhcGlwYXN0ZWQgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGlmICghZS5jbGlwYm9hcmREYXRhKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCBlLmNsaXBib2FyZERhdGEuaXRlbXMubGVuZ3RoOyBhKyspIHsgLy9sb29wIGFsbCBkYXRhIHR5cGVzXHJcbiAgICAgICAgICAgIGlmIChlLmNsaXBib2FyZERhdGEuaXRlbXNbYV0udHlwZS5pbmRleE9mKFwiaW1hZ2VcIikgIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmaWxlID0gZS5jbGlwYm9hcmREYXRhLml0ZW1zW2FdLmdldEFzRmlsZSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgICAgICAgICAgaW1nLnNyYyA9ICh3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwpLmNyZWF0ZU9iamVjdFVSTChmaWxlKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbWcud2lkdGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFzdGVkKGltZyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkgeyBwYXN0ZWQoaW1nKTsgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBpZiAoaXNjaHJvbWUpIHtcclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicGFzdGVcIiwgYXBpcGFzdGVkKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBjYXRjaGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICBjYXRjaGVyLnNldEF0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiLCBcIlwiKTtcclxuICAgICAgICBjYXRjaGVyLmNsYXNzTmFtZSA9IFwiZm9yY2VoaWRkZW5cIjsgLy9yZXRhcmRlZCBpZSBzYWZldHkvYnVnLCBjYW50IGFwcGx5IHN0eWxlcyB1c2luZyBqcy8vVE9ETyBpIGRvbid0IGV2ZW4ga25vdyB3aGF0J3MgZ29pbmcgb25cclxuICAgICAgICBjYXRjaGVyLm9ucGFzdGUgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBpZiAoZS5jbGlwYm9hcmREYXRhICYmIGUuY2xpcGJvYXJkRGF0YS5pdGVtcykge1xyXG4gICAgICAgICAgICAgICAgYXBpcGFzdGVkKGUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGIgPSBjYXRjaGVyLmNoaWxkcmVuWzBdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFiIHx8IGIudGFnTmFtZSAhPSBcIklNR1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgICAgICAgICAgaW1nLnNyYyA9IGIuc3JjO1xyXG4gICAgICAgICAgICAgICAgdmFyIGEgPSBpbWcuc3JjLm1hdGNoKC9eZGF0YTooW1xcd1xcL10rKTsvKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbWcud2lkdGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFzdGVkKGltZyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkgeyBwYXN0ZWQoaW1nKTsgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoZXIuaW5uZXJIVE1MID0gXCJcIjtcclxuICAgICAgICAgICAgfSwgMSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNhdGNoZXIpO1xyXG4gICAgfVxyXG4gICAgLy9kZXRlY3QgaWYgY3RybC12IGlzIHByZXNzZWQgYW5kIGZvY3VzIGNhdGNoZXIgaWYgbmVlZGVkXHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGlmIChlLnRhcmdldC50YWdOYW1lID09IFwiSU5QVVRcIikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlLmtleUNvZGUgIT0gXCJWXCIuY2hhckNvZGVBdCgwKSB8fCAhZS5jdHJsS2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGFzdGluZyA9IHRydWU7XHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChwYXN0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvcihcIm5vaW1nXCIsIFwiWW91IHByZXNzZWQgQ3RybCtWLCBidXQgbm8gaW1hZ2Ugd2FzIHBhc3RlZCBieSB5b3VyIGJyb3dzZXIsIG1ha2Ugc3VyZSB5b3VyIGNsaXBib2FyZCBjb250YWlucyBhbiBpbWFnZSwgYW5kIG5vdCBhIGxpbmsgdG8gYW4gaW1hZ2UuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgMTAwMCk7XHJcbiAgICAgICAgaWYgKGNhdGNoZXIpIHtcclxuICAgICAgICAgICAgY2F0Y2hlci5mb2N1cygpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBmaWxlRGlhbG9nKCkge1xyXG4gICAgdmFyIGZpbGVpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcclxuICAgIGZpbGVpbnB1dC50eXBlID0gXCJmaWxlXCI7XHJcbiAgICBmaWxlaW5wdXQuYWNjZXB0ID0gXCJpbWFnZS9wbmdcIjtcclxuICAgIGZpbGVpbnB1dC5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHsgaWYgKGZpbGVpbnB1dC5maWxlcyAmJiBmaWxlaW5wdXQuZmlsZXNbMF0pIHtcclxuICAgICAgICBmcm9tRmlsZShmaWxlaW5wdXQuZmlsZXNbMF0pO1xyXG4gICAgfSB9O1xyXG4gICAgZmlsZWlucHV0LmNsaWNrKCk7XHJcbiAgICByZXR1cm4gZmlsZWlucHV0O1xyXG59XHJcbmZ1bmN0aW9uIGZyb21GaWxlKGZpbGUpIHtcclxuICAgIGlmICghZmlsZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG4gICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYnl0ZWFycmF5ID0gbmV3IFVpbnQ4QXJyYXkocmVhZGVyLnJlc3VsdCk7XHJcbiAgICAgICAgaWYgKEltYWdlRGV0ZWN0LmlzUG5nQnVmZmVyKGJ5dGVhcnJheSkpIHtcclxuICAgICAgICAgICAgSW1hZ2VEZXRlY3QuY2xlYXJQbmdDb2xvcnNwYWNlKGJ5dGVhcnJheSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoW2J5dGVhcnJheV0sIHsgdHlwZTogXCJpbWFnZS9wbmdcIiB9KTtcclxuICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgaW1nLm9uZXJyb3IgPSAoKSA9PiBlcnJvcihcImludmFsaWRmaWxlXCIsIFwiVGhlIGZpbGUgeW91IHVwbG9hZGVkIGNvdWxkIG5vdCBiZSBvcGVuZWQgYXMgYW4gaW1hZ2UuXCIpO1xyXG4gICAgICAgIHZhciBibG9idXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuICAgICAgICBpbWcuc3JjID0gYmxvYnVybDtcclxuICAgICAgICBpZiAoaW1nLndpZHRoID4gMCkge1xyXG4gICAgICAgICAgICBwYXN0ZWQoaW1nKTtcclxuICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChibG9idXJsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7IHBhc3RlZChpbWcpOyBVUkwucmV2b2tlT2JqZWN0VVJMKGJsb2J1cmwpOyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoZmlsZSk7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/@alt1/base/dist/pasteinput.js\n");

/***/ }),

/***/ "../node_modules/@alt1/base/dist/rect.js":
/*!***********************************************!*\
  !*** ../node_modules/@alt1/base/dist/rect.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Rect)\n/* harmony export */ });\n//util class for rectangle maths\r\n//TODO shit this sucks can we remove it again?\r\n//more of a shorthand to get {x,y,width,height} than a class\r\n//kinda starting to like it again\r\n//TODO remove rant\r\n;\r\n/**\r\n * Simple rectangle class with some util functions\r\n */\r\nclass Rect {\r\n    constructor(x, y, w, h) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = w;\r\n        this.height = h;\r\n    }\r\n    static fromArgs(...args) {\r\n        if (typeof args[0] == \"object\") {\r\n            return new Rect(args[0].x, args[0].y, args[0].width, args[0].height);\r\n        }\r\n        else if (typeof args[0] == \"number\" && args.length >= 4) {\r\n            return new Rect(args[0], args[1], args[2], args[3]);\r\n        }\r\n        else {\r\n            throw new Error(\"invalid rect args\");\r\n        }\r\n    }\r\n    /**\r\n     * Resizes this Rect to include the full size of a given second rectangle\r\n     */\r\n    union(r2) {\r\n        var x = Math.min(this.x, r2.x);\r\n        var y = Math.min(this.y, r2.y);\r\n        this.width = Math.max(this.x + this.width, r2.x + r2.width) - x;\r\n        this.height = Math.max(this.y + this.height, r2.y + r2.height) - y;\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n    /**\r\n     * Resizes this Rect to include a given point\r\n     */\r\n    includePoint(x, y) {\r\n        this.union(new Rect(x, y, 0, 0));\r\n    }\r\n    /**\r\n     * Grows the rectangle with the given dimensions\r\n     */\r\n    inflate(w, h) {\r\n        this.x -= w;\r\n        this.y -= h;\r\n        this.width += 2 * w;\r\n        this.height += 2 * h;\r\n    }\r\n    /**\r\n     * Resizes this Rect to the area that overlaps a given Rect\r\n     * width and height will be set to 0 if the intersection does not exist\r\n     */\r\n    intersect(r2) {\r\n        if (this.x < r2.x) {\r\n            this.width -= r2.x - this.x;\r\n            this.x = r2.x;\r\n        }\r\n        if (this.y < r2.y) {\r\n            this.height -= r2.y - this.y;\r\n            this.y = r2.y;\r\n        }\r\n        this.width = Math.min(this.x + this.width, r2.x + r2.width) - this.x;\r\n        this.height = Math.min(this.y + this.height, r2.y + r2.height) - this.y;\r\n        if (this.width <= 0 || this.height <= 0) {\r\n            this.width = 0;\r\n            this.height = 0;\r\n        }\r\n    }\r\n    /**\r\n     * Returns wether this Rect has at least one pixel overlap with a given Rect\r\n     */\r\n    overlaps(r2) {\r\n        return this.x < r2.x + r2.width && this.x + this.width > r2.x && this.y < r2.y + r2.height && this.y + this.height > r2.y;\r\n    }\r\n    /**\r\n     * Returns wether a given Rect fits completely inside this Rect\r\n     * @param r2\r\n     */\r\n    contains(r2) {\r\n        return this.x <= r2.x && this.x + this.width >= r2.x + r2.width && this.y <= r2.y && this.y + this.height >= r2.y + r2.height;\r\n    }\r\n    /**\r\n     * Returns wether a given point lies inside this Rect\r\n     */\r\n    containsPoint(x, y) {\r\n        return this.x <= x && this.x + this.width > x && this.y <= y && this.y + this.height > y;\r\n    }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BhbHQxL2Jhc2UvZGlzdC9yZWN0LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0EsOEJBQThCLGtCQUFrQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL1RFU1QvLi4vbm9kZV9tb2R1bGVzL0BhbHQxL2Jhc2UvZGlzdC9yZWN0LmpzPzcxMTUiXSwic291cmNlc0NvbnRlbnQiOlsiLy91dGlsIGNsYXNzIGZvciByZWN0YW5nbGUgbWF0aHNcclxuLy9UT0RPIHNoaXQgdGhpcyBzdWNrcyBjYW4gd2UgcmVtb3ZlIGl0IGFnYWluP1xyXG4vL21vcmUgb2YgYSBzaG9ydGhhbmQgdG8gZ2V0IHt4LHksd2lkdGgsaGVpZ2h0fSB0aGFuIGEgY2xhc3NcclxuLy9raW5kYSBzdGFydGluZyB0byBsaWtlIGl0IGFnYWluXHJcbi8vVE9ETyByZW1vdmUgcmFudFxyXG47XHJcbi8qKlxyXG4gKiBTaW1wbGUgcmVjdGFuZ2xlIGNsYXNzIHdpdGggc29tZSB1dGlsIGZ1bmN0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVjdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih4LCB5LCB3LCBoKSB7XHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB3O1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tQXJncyguLi5hcmdzKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBhcmdzWzBdID09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWN0KGFyZ3NbMF0ueCwgYXJnc1swXS55LCBhcmdzWzBdLndpZHRoLCBhcmdzWzBdLmhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmdzWzBdID09IFwibnVtYmVyXCIgJiYgYXJncy5sZW5ndGggPj0gNCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlY3QoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHJlY3QgYXJnc1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc2l6ZXMgdGhpcyBSZWN0IHRvIGluY2x1ZGUgdGhlIGZ1bGwgc2l6ZSBvZiBhIGdpdmVuIHNlY29uZCByZWN0YW5nbGVcclxuICAgICAqL1xyXG4gICAgdW5pb24ocjIpIHtcclxuICAgICAgICB2YXIgeCA9IE1hdGgubWluKHRoaXMueCwgcjIueCk7XHJcbiAgICAgICAgdmFyIHkgPSBNYXRoLm1pbih0aGlzLnksIHIyLnkpO1xyXG4gICAgICAgIHRoaXMud2lkdGggPSBNYXRoLm1heCh0aGlzLnggKyB0aGlzLndpZHRoLCByMi54ICsgcjIud2lkdGgpIC0geDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IE1hdGgubWF4KHRoaXMueSArIHRoaXMuaGVpZ2h0LCByMi55ICsgcjIuaGVpZ2h0KSAtIHk7XHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNpemVzIHRoaXMgUmVjdCB0byBpbmNsdWRlIGEgZ2l2ZW4gcG9pbnRcclxuICAgICAqL1xyXG4gICAgaW5jbHVkZVBvaW50KHgsIHkpIHtcclxuICAgICAgICB0aGlzLnVuaW9uKG5ldyBSZWN0KHgsIHksIDAsIDApKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR3Jvd3MgdGhlIHJlY3RhbmdsZSB3aXRoIHRoZSBnaXZlbiBkaW1lbnNpb25zXHJcbiAgICAgKi9cclxuICAgIGluZmxhdGUodywgaCkge1xyXG4gICAgICAgIHRoaXMueCAtPSB3O1xyXG4gICAgICAgIHRoaXMueSAtPSBoO1xyXG4gICAgICAgIHRoaXMud2lkdGggKz0gMiAqIHc7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgKz0gMiAqIGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc2l6ZXMgdGhpcyBSZWN0IHRvIHRoZSBhcmVhIHRoYXQgb3ZlcmxhcHMgYSBnaXZlbiBSZWN0XHJcbiAgICAgKiB3aWR0aCBhbmQgaGVpZ2h0IHdpbGwgYmUgc2V0IHRvIDAgaWYgdGhlIGludGVyc2VjdGlvbiBkb2VzIG5vdCBleGlzdFxyXG4gICAgICovXHJcbiAgICBpbnRlcnNlY3QocjIpIHtcclxuICAgICAgICBpZiAodGhpcy54IDwgcjIueCkge1xyXG4gICAgICAgICAgICB0aGlzLndpZHRoIC09IHIyLnggLSB0aGlzLng7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IHIyLng7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnkgPCByMi55KSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0IC09IHIyLnkgLSB0aGlzLnk7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHIyLnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMud2lkdGggPSBNYXRoLm1pbih0aGlzLnggKyB0aGlzLndpZHRoLCByMi54ICsgcjIud2lkdGgpIC0gdGhpcy54O1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5taW4odGhpcy55ICsgdGhpcy5oZWlnaHQsIHIyLnkgKyByMi5oZWlnaHQpIC0gdGhpcy55O1xyXG4gICAgICAgIGlmICh0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gMDtcclxuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3ZXRoZXIgdGhpcyBSZWN0IGhhcyBhdCBsZWFzdCBvbmUgcGl4ZWwgb3ZlcmxhcCB3aXRoIGEgZ2l2ZW4gUmVjdFxyXG4gICAgICovXHJcbiAgICBvdmVybGFwcyhyMikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnggPCByMi54ICsgcjIud2lkdGggJiYgdGhpcy54ICsgdGhpcy53aWR0aCA+IHIyLnggJiYgdGhpcy55IDwgcjIueSArIHIyLmhlaWdodCAmJiB0aGlzLnkgKyB0aGlzLmhlaWdodCA+IHIyLnk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgd2V0aGVyIGEgZ2l2ZW4gUmVjdCBmaXRzIGNvbXBsZXRlbHkgaW5zaWRlIHRoaXMgUmVjdFxyXG4gICAgICogQHBhcmFtIHIyXHJcbiAgICAgKi9cclxuICAgIGNvbnRhaW5zKHIyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMueCA8PSByMi54ICYmIHRoaXMueCArIHRoaXMud2lkdGggPj0gcjIueCArIHIyLndpZHRoICYmIHRoaXMueSA8PSByMi55ICYmIHRoaXMueSArIHRoaXMuaGVpZ2h0ID49IHIyLnkgKyByMi5oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgd2V0aGVyIGEgZ2l2ZW4gcG9pbnQgbGllcyBpbnNpZGUgdGhpcyBSZWN0XHJcbiAgICAgKi9cclxuICAgIGNvbnRhaW5zUG9pbnQoeCwgeSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnggPD0geCAmJiB0aGlzLnggKyB0aGlzLndpZHRoID4geCAmJiB0aGlzLnkgPD0geSAmJiB0aGlzLnkgKyB0aGlzLmhlaWdodCA+IHk7XHJcbiAgICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/@alt1/base/dist/rect.js\n");

/***/ }),

/***/ "../node_modules/@alt1/base/dist/wrapper.js":
/*!**************************************************!*\
  !*** ../node_modules/@alt1/base/dist/wrapper.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NoAlt1Error\": () => (/* binding */ NoAlt1Error),\n/* harmony export */   \"Alt1Error\": () => (/* binding */ Alt1Error),\n/* harmony export */   \"newestversion\": () => (/* binding */ newestversion),\n/* harmony export */   \"hasAlt1\": () => (/* binding */ hasAlt1),\n/* harmony export */   \"skinName\": () => (/* binding */ skinName),\n/* harmony export */   \"openbrowser\": () => (/* binding */ openbrowser),\n/* harmony export */   \"requireAlt1\": () => (/* binding */ requireAlt1),\n/* harmony export */   \"getdisplaybounds\": () => (/* binding */ getdisplaybounds),\n/* harmony export */   \"capture\": () => (/* binding */ capture),\n/* harmony export */   \"captureHold\": () => (/* binding */ captureHold),\n/* harmony export */   \"captureHoldScreen\": () => (/* binding */ captureHoldScreen),\n/* harmony export */   \"captureHoldFullRs\": () => (/* binding */ captureHoldFullRs),\n/* harmony export */   \"transferImageData\": () => (/* binding */ transferImageData),\n/* harmony export */   \"decodeImageString\": () => (/* binding */ decodeImageString),\n/* harmony export */   \"encodeImageString\": () => (/* binding */ encodeImageString),\n/* harmony export */   \"mixColor\": () => (/* binding */ mixColor),\n/* harmony export */   \"unmixColor\": () => (/* binding */ unmixColor),\n/* harmony export */   \"identifyApp\": () => (/* binding */ identifyApp),\n/* harmony export */   \"resetEnvironment\": () => (/* binding */ resetEnvironment),\n/* harmony export */   \"hasAlt1Version\": () => (/* binding */ hasAlt1Version),\n/* harmony export */   \"getMousePosition\": () => (/* binding */ getMousePosition),\n/* harmony export */   \"addResizeElement\": () => (/* binding */ addResizeElement),\n/* harmony export */   \"on\": () => (/* binding */ on),\n/* harmony export */   \"removeListener\": () => (/* binding */ removeListener),\n/* harmony export */   \"once\": () => (/* binding */ once),\n/* harmony export */   \"ImageStreamReader\": () => (/* binding */ ImageStreamReader),\n/* harmony export */   \"captureAsync\": () => (/* binding */ captureAsync),\n/* harmony export */   \"captureMultiAsync\": () => (/* binding */ captureMultiAsync),\n/* harmony export */   \"captureStream\": () => (/* binding */ captureStream)\n/* harmony export */ });\n/* harmony import */ var _rect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rect.js */ \"../node_modules/@alt1/base/dist/rect.js\");\n/* harmony import */ var _imgref_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./imgref.js */ \"../node_modules/@alt1/base/dist/imgref.js\");\n/* harmony import */ var _imagedata_extensions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./imagedata-extensions.js */ \"../node_modules/@alt1/base/dist/imagedata-extensions.js\");\n/* harmony import */ var _alt1api_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./alt1api.js */ \"../node_modules/@alt1/base/dist/alt1api.js\");\n/* harmony import */ var _alt1api_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_alt1api_js__WEBPACK_IMPORTED_MODULE_3__);\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n/**\r\n * Thrown when a method is called that can not be used outside of Alt1\r\n */\r\nclass NoAlt1Error extends Error {\r\n    constructor() {\r\n        super();\r\n        this.message = \"This method can not be ran outside of Alt1\";\r\n    }\r\n}\r\n;\r\n/**\r\n * Thrown when the Alt1 API returns an invalid result\r\n * Errors of a different type are throw when internal Alt1 errors occur\r\n */\r\nclass Alt1Error extends Error {\r\n}\r\n/**\r\n * The latest Alt1 version\r\n */\r\nvar newestversion = \"1.5.5\";\r\n/**\r\n * Whether the Alt1 API is available\r\n */\r\nvar hasAlt1 = (typeof alt1 != \"undefined\");\r\n/**\r\n * The name of the Alt1 interface skin. (Always \"default\" if running in a browser)\r\n */\r\nvar skinName = hasAlt1 ? alt1.skinName : \"default\";\r\n/**\r\n * Max number of bytes that can be sent by alt1 in one function\r\n * Not completely sure why this number is different than window.alt1.maxtranfer\r\n */\r\nvar maxtransfer = 4000000;\r\n/**\r\n * Open a link in the default browser\r\n * @deprecated use window.open instead\r\n */\r\nfunction openbrowser(url) {\r\n    if (hasAlt1) {\r\n        alt1.openBrowser(url);\r\n    }\r\n    else {\r\n        window.open(url, '_blank');\r\n    }\r\n}\r\n/**\r\n * Throw if Alt1 API is not available\r\n */\r\nfunction requireAlt1() {\r\n    if (!hasAlt1) {\r\n        throw new NoAlt1Error();\r\n    }\r\n}\r\n/**\r\n * Returns an object with a rectangle that spans all screens\r\n */\r\nfunction getdisplaybounds() {\r\n    if (!hasAlt1) {\r\n        return false;\r\n    }\r\n    return new _rect_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](alt1.screenX, alt1.screenY, alt1.screenWidth, alt1.screenHeight);\r\n}\r\n/**\r\n * gets an imagebuffer with pixel data about the requested region\r\n */\r\nfunction capture(...args) {\r\n    //TODO change null return on error into throw instead (x3)\r\n    if (!hasAlt1) {\r\n        throw new NoAlt1Error();\r\n    }\r\n    var rect = _rect_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromArgs(...args);\r\n    if (alt1.capture) {\r\n        return new _imagedata_extensions_js__WEBPACK_IMPORTED_MODULE_2__.ImageData(alt1.capture(rect.x, rect.y, rect.width, rect.height), rect.width, rect.height);\r\n    }\r\n    var buf = new _imagedata_extensions_js__WEBPACK_IMPORTED_MODULE_2__.ImageData(rect.width, rect.height);\r\n    if (rect.width * rect.height * 4 <= maxtransfer) {\r\n        var data = alt1.getRegion(rect.x, rect.y, rect.width, rect.height);\r\n        if (!data) {\r\n            return null;\r\n        }\r\n        decodeImageString(data, buf, 0, 0, rect.width, rect.height);\r\n    }\r\n    else {\r\n        //split up the request to to exceed the single transfer limit (for now)\r\n        var x1 = rect.x;\r\n        var ref = alt1.bindRegion(rect.x, rect.y, rect.width, rect.height);\r\n        if (ref <= 0) {\r\n            return null;\r\n        }\r\n        while (x1 < rect.x + rect.width) {\r\n            var x2 = Math.min(rect.x + rect.width, Math.floor(x1 + (maxtransfer / 4 / rect.height)));\r\n            var data = alt1.bindGetRegion(ref, x1, rect.y, x2 - x1, rect.height);\r\n            if (!data) {\r\n                return null;\r\n            }\r\n            decodeImageString(data, buf, x1 - rect.x, 0, x2 - x1, rect.height);\r\n            x1 = x2;\r\n        }\r\n    }\r\n    return buf;\r\n}\r\n/**\r\n * Makes alt1 bind an area of the rs client in memory without sending it to the js client\r\n * returns an imgref object which can be used to get pixel data using the imgreftobuf function\r\n * currently only one bind can exist per app and the ref in (v) will always be 1\r\n */\r\nfunction captureHold(x, y, w, h) {\r\n    x = Math.round(x);\r\n    y = Math.round(y);\r\n    w = Math.round(w);\r\n    h = Math.round(h);\r\n    requireAlt1();\r\n    var r = alt1.bindRegion(x, y, w, h);\r\n    if (r <= 0) {\r\n        throw new Alt1Error(\"capturehold failed\");\r\n    }\r\n    return new _imgref_js__WEBPACK_IMPORTED_MODULE_1__.ImgRefBind(r, x, y, w, h);\r\n}\r\n/**\r\n * Same as captureHoldRegion, but captures the screen instead of the rs client. it also uses screen coordinates instead and can capture outside of the rs client\r\n */\r\nfunction captureHoldScreen(x, y, w, h) {\r\n    x = Math.round(x);\r\n    y = Math.round(y);\r\n    w = Math.round(w);\r\n    h = Math.round(h);\r\n    requireAlt1();\r\n    var r = alt1.bindScreenRegion(x, y, w, h);\r\n    if (r <= 0) {\r\n        return false;\r\n    }\r\n    return new _imgref_js__WEBPACK_IMPORTED_MODULE_1__.ImgRefBind(r, x, y, w, h);\r\n}\r\n/**\r\n * bind the full rs window if the rs window can be detected by alt1, otherwise return the full screen\r\n */\r\nfunction captureHoldFullRs() {\r\n    return captureHold(0, 0, alt1.rsWidth, alt1.rsHeight);\r\n}\r\n/**\r\n * returns a subregion from a bound image\r\n * used internally in imgreftobuf if imgref is a bound image\r\n * @deprecated This should be handled internall by the imgrefbind.toData method\r\n */\r\nfunction transferImageData(handle, x, y, w, h) {\r\n    x = Math.round(x);\r\n    y = Math.round(y);\r\n    w = Math.round(w);\r\n    h = Math.round(h);\r\n    requireAlt1();\r\n    if (alt1.bindGetRegionBuffer) {\r\n        return new _imagedata_extensions_js__WEBPACK_IMPORTED_MODULE_2__.ImageData(alt1.bindGetRegionBuffer(handle, x, y, w, h), w, h);\r\n    }\r\n    var r = new _imagedata_extensions_js__WEBPACK_IMPORTED_MODULE_2__.ImageData(w, h);\r\n    var x1 = x;\r\n    while (true) { //split up the request to to exceed the single transfer limit (for now)\r\n        var x2 = Math.min(x + w, Math.floor(x1 + (maxtransfer / 4 / h)));\r\n        var a = alt1.bindGetRegion(handle, x1, y, x2 - x1, h);\r\n        if (!a) {\r\n            throw new Alt1Error();\r\n        }\r\n        decodeImageString(a, r, x1 - x, 0, x2 - x1, h);\r\n        x1 = x2;\r\n        if (x1 == x + w) {\r\n            break;\r\n        }\r\n        ;\r\n    }\r\n    return r;\r\n}\r\n/**\r\n * decodes a returned string from alt1 to an imagebuffer\r\n */\r\nfunction decodeImageString(imagestring, target, x, y, w, h) {\r\n    var bin = atob(imagestring);\r\n    var bytes = target.data;\r\n    w |= 0;\r\n    h |= 0;\r\n    var offset = 4 * x + 4 * y * target.width;\r\n    var target_width = target.width | 0;\r\n    for (var a = 0; a < w; a++) {\r\n        for (var b = 0; b < h; b++) {\r\n            var i1 = (offset + (a * 4 | 0) + (b * target_width * 4 | 0)) | 0;\r\n            var i2 = ((a * 4 | 0) + (b * 4 * w | 0)) | 0;\r\n            bytes[i1 + 0 | 0] = bin.charCodeAt(i2 + 2 | 0); //fix weird red/blue swap in c#\r\n            bytes[i1 + 1 | 0] = bin.charCodeAt(i2 + 1 | 0);\r\n            bytes[i1 + 2 | 0] = bin.charCodeAt(i2 + 0 | 0);\r\n            bytes[i1 + 3 | 0] = bin.charCodeAt(i2 + 3 | 0);\r\n        }\r\n    }\r\n    return target;\r\n}\r\n/**\r\n * encodes an imagebuffer to a string\r\n */\r\nfunction encodeImageString(buf, sx = 0, sy = 0, sw = buf.width, sh = buf.height) {\r\n    var raw = \"\";\r\n    for (var y = sy; y < sy + sh; y++) {\r\n        for (var x = sx; x < sx + sw; x++) {\r\n            var i = 4 * x + 4 * buf.width * y | 0;\r\n            raw += String.fromCharCode(buf.data[i + 2 | 0]);\r\n            raw += String.fromCharCode(buf.data[i + 1 | 0]);\r\n            raw += String.fromCharCode(buf.data[i + 0 | 0]);\r\n            raw += String.fromCharCode(buf.data[i + 3 | 0]);\r\n        }\r\n    }\r\n    return btoa(raw);\r\n}\r\n/**\r\n * mixes the given color into a single int. This format is used by alt1\r\n */\r\nfunction mixColor(r, g, b, a = 255) {\r\n    return (b << 0) + (g << 8) + (r << 16) + (a << 24);\r\n}\r\nfunction unmixColor(col) {\r\n    var r = (col >> 16) & 0xff;\r\n    var g = (col >> 8) & 0xff;\r\n    var b = (col >> 0) & 0xff;\r\n    return [r, g, b];\r\n}\r\nfunction identifyApp(url) {\r\n    if (hasAlt1) {\r\n        alt1.identifyAppUrl(url);\r\n    }\r\n}\r\nfunction resetEnvironment() {\r\n    hasAlt1 = (typeof alt1 != \"undefined\");\r\n    skinName = hasAlt1 ? alt1.skinName : \"default\";\r\n}\r\nfunction convertAlt1Version(str) {\r\n    var a = str.match(/^(\\d+)\\.(\\d+)\\.(\\d+)$/);\r\n    if (!a) {\r\n        throw new RangeError(\"Invalid version string\");\r\n    }\r\n    return (+a[1]) * 1000 * 1000 + (+a[2]) * 1000 + (+a[3]) * 1;\r\n}\r\nvar cachedVersionInt = -1;\r\n/**\r\n * checks if alt1 is running and at least the given version. versionstr should be a string with the version eg: 1.3.2\r\n * @param versionstr\r\n */\r\nfunction hasAlt1Version(versionstr) {\r\n    if (!hasAlt1) {\r\n        return false;\r\n    }\r\n    if (cachedVersionInt == -1) {\r\n        cachedVersionInt = alt1.versionint;\r\n    }\r\n    return cachedVersionInt >= convertAlt1Version(versionstr);\r\n}\r\n/**\r\n * Gets the current cursor position in the game, returns null if the rs window is not active (alt1.rsActive)\r\n */\r\nfunction getMousePosition() {\r\n    var pos = alt1.mousePosition;\r\n    if (pos == -1) {\r\n        return null;\r\n    }\r\n    return { x: pos >>> 16, y: pos & 0xFFFF };\r\n}\r\n/**\r\n * Registers a given HTML element as a frame border, when this element is dragged by the user the Alt1 frame will resize accordingly\r\n * Use the direction arguements to make a given direction stick to the mouse. eg. Only set left to true to make the element behave as the left border\r\n * Or set all to true to move the whole window. Not all combinations are permitted\r\n */\r\nfunction addResizeElement(el, left, top, right, bot) {\r\n    if (!hasAlt1 || !alt1.userResize) {\r\n        return;\r\n    }\r\n    el.addEventListener(\"mousedown\", function (e) {\r\n        alt1.userResize(left, top, right, bot);\r\n        e.preventDefault();\r\n    });\r\n}\r\n/**\r\n * Add an event listener\r\n */\r\nfunction on(type, listener) {\r\n    requireAlt1();\r\n    if (!alt1.events) {\r\n        alt1.events = {};\r\n    }\r\n    if (!alt1.events[type]) {\r\n        alt1.events[type] = [];\r\n    }\r\n    alt1.events[type].push(listener);\r\n}\r\n/**\r\n * Removes an event listener\r\n */\r\nfunction removeListener(type, listener) {\r\n    var elist = alt1.events && alt1.events[type];\r\n    if (!elist) {\r\n        return;\r\n    }\r\n    var i = elist.indexOf(listener);\r\n    if (i == -1) {\r\n        return;\r\n    }\r\n    elist.splice(i, 1);\r\n}\r\n/**\r\n * Listens for the event to fire once and then stops listening\r\n * @param event\r\n * @param cb\r\n */\r\nfunction once(type, listener) {\r\n    requireAlt1();\r\n    var fn = (e) => {\r\n        removeListener(type, fn);\r\n        listener(e);\r\n    };\r\n    on(type, fn);\r\n}\r\n;\r\n/**\r\n * Used to read a set of images from a binary stream returned by the Alt1 API\r\n */\r\nclass ImageStreamReader {\r\n    constructor(reader, ...args) {\r\n        this.framebuffer = null;\r\n        this.pos = 0;\r\n        this.reading = false;\r\n        this.closed = false;\r\n        //paused state\r\n        this.pausedindex = -1;\r\n        this.pausedbuffer = null;\r\n        this.streamreader = reader;\r\n        if (args[0] instanceof _imagedata_extensions_js__WEBPACK_IMPORTED_MODULE_2__.ImageData) {\r\n            this.setFrameBuffer(args[0]);\r\n        }\r\n        else if (typeof args[0] == \"number\") {\r\n            this.setFrameBuffer(new _imagedata_extensions_js__WEBPACK_IMPORTED_MODULE_2__.ImageData(args[0], args[1]));\r\n        }\r\n    }\r\n    /**\r\n     *\r\n     */\r\n    setFrameBuffer(buffer) {\r\n        if (this.reading) {\r\n            throw new Error(\"can't change framebuffer while reading\");\r\n        }\r\n        this.framebuffer = buffer;\r\n    }\r\n    /**\r\n     * Closes the underlying stream and ends reading\r\n     */\r\n    close() {\r\n        this.streamreader.cancel();\r\n    }\r\n    /**\r\n     * Reads a single image from the stream\r\n     */\r\n    nextImage() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this.reading) {\r\n                throw new Error(\"already reading from this stream\");\r\n            }\r\n            if (!this.framebuffer) {\r\n                throw new Error(\"framebuffer not set\");\r\n            }\r\n            this.reading = true;\r\n            var synctime = -Date.now();\r\n            var starttime = Date.now();\r\n            var r = false;\r\n            while (!r) {\r\n                if (this.pausedindex != -1 && this.pausedbuffer) {\r\n                    r = this.readChunk(this.pausedindex, this.framebuffer.data, this.pausedbuffer);\r\n                }\r\n                else {\r\n                    synctime += Date.now();\r\n                    var res = yield this.streamreader.read();\r\n                    synctime -= Date.now();\r\n                    if (res.done) {\r\n                        throw new Error(\"Stream closed while reading\");\r\n                    }\r\n                    var data = res.value;\r\n                    r = this.readChunk(0, this.framebuffer.data, data);\r\n                }\r\n            }\r\n            synctime += Date.now();\r\n            //console.log(\"Decoded async image, \" + this.framebuffer.width + \"x\" + this.framebuffer.height + \" time: \" + (Date.now() - starttime) + \"ms (\" + synctime + \"ms main thread)\");\r\n            this.reading = false;\r\n            return this.framebuffer;\r\n        });\r\n    }\r\n    readChunk(i, framedata, buffer) {\r\n        //very hot code, explicit int32 casting with |0 speeds it up by ~ x2\r\n        i = i | 0;\r\n        var framesize = framedata.length | 0;\r\n        var pos = this.pos;\r\n        var datalen = buffer.length | 0;\r\n        //var data32 = new Float64Array(buffer.buffer);\r\n        //var framedata32 = new Float64Array(framedata.buffer);\r\n        //fix possible buffer misalignment\r\n        //align to 16 for extra loop unrolling\r\n        while (i < datalen) {\r\n            //slow loop, fix alignment and other issues\r\n            while (i < datalen && pos < framesize && (pos % 16 != 0 || !((i + 16 | 0) <= datalen && (pos + 16 | 0) <= framesize))) {\r\n                var rel = pos;\r\n                if (pos % 4 == 0) {\r\n                    rel = rel + 2 | 0;\r\n                }\r\n                if (pos % 4 == 2) {\r\n                    rel = rel - 2 | 0;\r\n                }\r\n                framedata[rel | 0] = buffer[i | 0];\r\n                i = i + 1 | 0;\r\n                pos = pos + 1 | 0;\r\n            }\r\n            //fast unrolled loop for large chunks i wish js had some sort of memcpy\r\n            if (pos % 16 == 0) {\r\n                while ((i + 16 | 0) <= datalen && (pos + 16 | 0) <= framesize) {\r\n                    framedata[pos + 0 | 0] = buffer[i + 2 | 0];\r\n                    framedata[pos + 1 | 0] = buffer[i + 1 | 0];\r\n                    framedata[pos + 2 | 0] = buffer[i + 0 | 0];\r\n                    framedata[pos + 3 | 0] = buffer[i + 3 | 0];\r\n                    framedata[pos + 4 | 0] = buffer[i + 6 | 0];\r\n                    framedata[pos + 5 | 0] = buffer[i + 5 | 0];\r\n                    framedata[pos + 6 | 0] = buffer[i + 4 | 0];\r\n                    framedata[pos + 7 | 0] = buffer[i + 7 | 0];\r\n                    framedata[pos + 8 | 0] = buffer[i + 10 | 0];\r\n                    framedata[pos + 9 | 0] = buffer[i + 9 | 0];\r\n                    framedata[pos + 10 | 0] = buffer[i + 8 | 0];\r\n                    framedata[pos + 11 | 0] = buffer[i + 11 | 0];\r\n                    framedata[pos + 12 | 0] = buffer[i + 14 | 0];\r\n                    framedata[pos + 13 | 0] = buffer[i + 13 | 0];\r\n                    framedata[pos + 14 | 0] = buffer[i + 12 | 0];\r\n                    framedata[pos + 15 | 0] = buffer[i + 15 | 0];\r\n                    //could speed it up another x2 but wouldn't be able to swap r/b swap and possible alignment issues\r\n                    //framedata32[pos / 8 + 0 | 0] = data32[i / 8 + 0 | 0];\r\n                    //framedata32[pos / 8 + 1 | 0] = data32[i / 8 + 1 | 0];\r\n                    //framedata32[pos / 4 + 2 | 0] = data32[i / 4 + 2 | 0];\r\n                    //framedata32[pos / 4 + 3 | 0] = data32[i / 4 + 3 | 0];\r\n                    pos = pos + 16 | 0;\r\n                    i = i + 16 | 0;\r\n                }\r\n            }\r\n            if (pos >= framesize) {\r\n                this.pausedbuffer = null;\r\n                this.pausedindex = -1;\r\n                this.pos = 0;\r\n                if (i != buffer.length - 1) {\r\n                    this.pausedbuffer = buffer;\r\n                    this.pausedindex = i;\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        this.pos = pos;\r\n        this.pausedbuffer = null;\r\n        this.pausedindex = -1;\r\n        return false;\r\n    }\r\n}\r\n/**\r\n * Asynchronously captures a section of the game screen\r\n */\r\nfunction captureAsync(...args) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        requireAlt1();\r\n        var rect = _rect_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromArgs(...args);\r\n        if (alt1.captureAsync) {\r\n            let img = yield alt1.captureAsync(rect.x, rect.y, rect.width, rect.height);\r\n            return new _imagedata_extensions_js__WEBPACK_IMPORTED_MODULE_2__.ImageData(img, rect.width, rect.height);\r\n        }\r\n        if (!hasAlt1Version(\"1.4.6\")) {\r\n            return capture(rect.x, rect.y, rect.width, rect.height);\r\n        }\r\n        var url = \"https://alt1api/pixel/getregion/\" + encodeURIComponent(JSON.stringify(Object.assign(Object.assign({}, rect), { format: \"raw\", quality: 1 })));\r\n        var res = yield fetch(url);\r\n        var imgreader = new ImageStreamReader(res.body.getReader(), rect.width, rect.height);\r\n        return imgreader.nextImage();\r\n    });\r\n}\r\n/**\r\n * Asynchronously captures multple area's. This method captures the images in the same render frame if possible\r\n * @param areas\r\n */\r\nfunction captureMultiAsync(areas) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        requireAlt1();\r\n        var r = {};\r\n        if (alt1.captureMultiAsync) {\r\n            let bufs = yield alt1.captureMultiAsync(areas);\r\n            for (let a in areas) {\r\n                if (!bufs[a]) {\r\n                    r[a] = null;\r\n                }\r\n                r[a] = new _imagedata_extensions_js__WEBPACK_IMPORTED_MODULE_2__.ImageData(bufs[a], areas[a].width, areas[a].height);\r\n            }\r\n            return r;\r\n        }\r\n        var capts = [];\r\n        var captids = [];\r\n        for (var id in areas) {\r\n            if (areas[id]) {\r\n                capts.push(areas[id]);\r\n                captids.push(id);\r\n            }\r\n            else {\r\n                r[id] = null;\r\n            }\r\n        }\r\n        if (capts.length == 0) {\r\n            return r;\r\n        }\r\n        if (!hasAlt1Version(\"1.5.1\")) {\r\n            var proms = [];\r\n            for (var a = 0; a < capts.length; a++) {\r\n                proms.push(captureAsync(capts[a]));\r\n            }\r\n            var results = yield Promise.all(proms);\r\n            for (var a = 0; a < capts.length; a++) {\r\n                r[captids[a]] = results[a];\r\n            }\r\n        }\r\n        else {\r\n            var res = yield fetch(\"https://alt1api/pixel/getregionmulti/\" + encodeURIComponent(JSON.stringify({ areas: capts, format: \"raw\", quality: 1 })));\r\n            var imgreader = new ImageStreamReader(res.body.getReader());\r\n            for (var a = 0; a < capts.length; a++) {\r\n                var capt = capts[a];\r\n                imgreader.setFrameBuffer(new _imagedata_extensions_js__WEBPACK_IMPORTED_MODULE_2__.ImageData(capt.width, capt.height));\r\n                r[captids[a]] = yield imgreader.nextImage();\r\n            }\r\n        }\r\n        return r;\r\n    });\r\n}\r\n/**\r\n * Starts capturing a realtime stream of the game. Make sure you keep reading the stream and close it when you're done or Alt1 WILL crash\r\n * @param framecb Called whenever a new frame is decoded\r\n * @param errorcb Called whenever an error occurs, the error is rethrown if not defined\r\n * @param fps Maximum fps of the stream\r\n */\r\nfunction captureStream(x, y, width, height, fps, framecb, errorcb) {\r\n    requireAlt1();\r\n    if (!hasAlt1Version(\"1.4.6\")) {\r\n        throw new Alt1Error(\"This function is not supported in this version of Alt1\");\r\n    }\r\n    var url = \"https://alt1api/pixel/streamregion/\" + encodeURIComponent(JSON.stringify({ x, y, width, height, fps, format: \"raw\" }));\r\n    var res = fetch(url).then((res) => __awaiter(this, void 0, void 0, function* () {\r\n        var reader = new ImageStreamReader(res.body.getReader(), width, height);\r\n        try {\r\n            while (!reader.closed && !state.closed) {\r\n                var img = yield reader.nextImage();\r\n                if (!state.closed) {\r\n                    framecb(img);\r\n                    state.framenr++;\r\n                }\r\n            }\r\n        }\r\n        catch (e) {\r\n            if (!state.closed) {\r\n                reader.close();\r\n                if (errorcb) {\r\n                    errorcb(e);\r\n                }\r\n                else {\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n        if (!reader.closed && state.closed) {\r\n            reader.close();\r\n        }\r\n    }));\r\n    var state = {\r\n        x, y, width, height,\r\n        framenr: 0,\r\n        close: () => { state.closed = true; },\r\n        closed: false,\r\n    };\r\n    return state;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BhbHQxL2Jhc2UvZGlzdC93cmFwcGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0IsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDNkI7QUFDWTtBQUNhO0FBQ2hDO0FBQ3RCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0RBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5REFBYTtBQUM1QjtBQUNBLG1CQUFtQiwrREFBUztBQUM1QjtBQUNBLGtCQUFrQiwrREFBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrREFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrREFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrREFBUztBQUM1QjtBQUNBLGdCQUFnQiwrREFBUztBQUN6QjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQix3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsK0RBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLCtEQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLG1CQUFtQix5REFBYTtBQUNoQztBQUNBO0FBQ0EsdUJBQXVCLCtEQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUhBQXVILFdBQVcsMkJBQTJCO0FBQzdKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsK0RBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnSEFBZ0gseUNBQXlDO0FBQ3pKO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBLDZDQUE2QywrREFBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYseUNBQXlDO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9URVNULy4uL25vZGVfbW9kdWxlcy9AYWx0MS9iYXNlL2Rpc3Qvd3JhcHBlci5qcz9hNDY2Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufTtcclxuaW1wb3J0IFJlY3QgZnJvbSBcIi4vcmVjdC5qc1wiO1xyXG5pbXBvcnQgeyBJbWdSZWZCaW5kIH0gZnJvbSBcIi4vaW1ncmVmLmpzXCI7XHJcbmltcG9ydCB7IEltYWdlRGF0YSB9IGZyb20gXCIuL2ltYWdlZGF0YS1leHRlbnNpb25zLmpzXCI7XHJcbmltcG9ydCBcIi4vYWx0MWFwaS5qc1wiO1xyXG4vKipcclxuICogVGhyb3duIHdoZW4gYSBtZXRob2QgaXMgY2FsbGVkIHRoYXQgY2FuIG5vdCBiZSB1c2VkIG91dHNpZGUgb2YgQWx0MVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIE5vQWx0MUVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIlRoaXMgbWV0aG9kIGNhbiBub3QgYmUgcmFuIG91dHNpZGUgb2YgQWx0MVwiO1xyXG4gICAgfVxyXG59XHJcbjtcclxuLyoqXHJcbiAqIFRocm93biB3aGVuIHRoZSBBbHQxIEFQSSByZXR1cm5zIGFuIGludmFsaWQgcmVzdWx0XHJcbiAqIEVycm9ycyBvZiBhIGRpZmZlcmVudCB0eXBlIGFyZSB0aHJvdyB3aGVuIGludGVybmFsIEFsdDEgZXJyb3JzIG9jY3VyXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQWx0MUVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG59XHJcbi8qKlxyXG4gKiBUaGUgbGF0ZXN0IEFsdDEgdmVyc2lvblxyXG4gKi9cclxuZXhwb3J0IHZhciBuZXdlc3R2ZXJzaW9uID0gXCIxLjUuNVwiO1xyXG4vKipcclxuICogV2hldGhlciB0aGUgQWx0MSBBUEkgaXMgYXZhaWxhYmxlXHJcbiAqL1xyXG5leHBvcnQgdmFyIGhhc0FsdDEgPSAodHlwZW9mIGFsdDEgIT0gXCJ1bmRlZmluZWRcIik7XHJcbi8qKlxyXG4gKiBUaGUgbmFtZSBvZiB0aGUgQWx0MSBpbnRlcmZhY2Ugc2tpbi4gKEFsd2F5cyBcImRlZmF1bHRcIiBpZiBydW5uaW5nIGluIGEgYnJvd3NlcilcclxuICovXHJcbmV4cG9ydCB2YXIgc2tpbk5hbWUgPSBoYXNBbHQxID8gYWx0MS5za2luTmFtZSA6IFwiZGVmYXVsdFwiO1xyXG4vKipcclxuICogTWF4IG51bWJlciBvZiBieXRlcyB0aGF0IGNhbiBiZSBzZW50IGJ5IGFsdDEgaW4gb25lIGZ1bmN0aW9uXHJcbiAqIE5vdCBjb21wbGV0ZWx5IHN1cmUgd2h5IHRoaXMgbnVtYmVyIGlzIGRpZmZlcmVudCB0aGFuIHdpbmRvdy5hbHQxLm1heHRyYW5mZXJcclxuICovXHJcbnZhciBtYXh0cmFuc2ZlciA9IDQwMDAwMDA7XHJcbi8qKlxyXG4gKiBPcGVuIGEgbGluayBpbiB0aGUgZGVmYXVsdCBicm93c2VyXHJcbiAqIEBkZXByZWNhdGVkIHVzZSB3aW5kb3cub3BlbiBpbnN0ZWFkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gb3BlbmJyb3dzZXIodXJsKSB7XHJcbiAgICBpZiAoaGFzQWx0MSkge1xyXG4gICAgICAgIGFsdDEub3BlbkJyb3dzZXIodXJsKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHdpbmRvdy5vcGVuKHVybCwgJ19ibGFuaycpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaHJvdyBpZiBBbHQxIEFQSSBpcyBub3QgYXZhaWxhYmxlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcmVxdWlyZUFsdDEoKSB7XHJcbiAgICBpZiAoIWhhc0FsdDEpIHtcclxuICAgICAgICB0aHJvdyBuZXcgTm9BbHQxRXJyb3IoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBhIHJlY3RhbmdsZSB0aGF0IHNwYW5zIGFsbCBzY3JlZW5zXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0ZGlzcGxheWJvdW5kcygpIHtcclxuICAgIGlmICghaGFzQWx0MSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgUmVjdChhbHQxLnNjcmVlblgsIGFsdDEuc2NyZWVuWSwgYWx0MS5zY3JlZW5XaWR0aCwgYWx0MS5zY3JlZW5IZWlnaHQpO1xyXG59XHJcbi8qKlxyXG4gKiBnZXRzIGFuIGltYWdlYnVmZmVyIHdpdGggcGl4ZWwgZGF0YSBhYm91dCB0aGUgcmVxdWVzdGVkIHJlZ2lvblxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNhcHR1cmUoLi4uYXJncykge1xyXG4gICAgLy9UT0RPIGNoYW5nZSBudWxsIHJldHVybiBvbiBlcnJvciBpbnRvIHRocm93IGluc3RlYWQgKHgzKVxyXG4gICAgaWYgKCFoYXNBbHQxKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IE5vQWx0MUVycm9yKCk7XHJcbiAgICB9XHJcbiAgICB2YXIgcmVjdCA9IFJlY3QuZnJvbUFyZ3MoLi4uYXJncyk7XHJcbiAgICBpZiAoYWx0MS5jYXB0dXJlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbWFnZURhdGEoYWx0MS5jYXB0dXJlKHJlY3QueCwgcmVjdC55LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIHZhciBidWYgPSBuZXcgSW1hZ2VEYXRhKHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcclxuICAgIGlmIChyZWN0LndpZHRoICogcmVjdC5oZWlnaHQgKiA0IDw9IG1heHRyYW5zZmVyKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBhbHQxLmdldFJlZ2lvbihyZWN0LngsIHJlY3QueSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xyXG4gICAgICAgIGlmICghZGF0YSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVjb2RlSW1hZ2VTdHJpbmcoZGF0YSwgYnVmLCAwLCAwLCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvL3NwbGl0IHVwIHRoZSByZXF1ZXN0IHRvIHRvIGV4Y2VlZCB0aGUgc2luZ2xlIHRyYW5zZmVyIGxpbWl0IChmb3Igbm93KVxyXG4gICAgICAgIHZhciB4MSA9IHJlY3QueDtcclxuICAgICAgICB2YXIgcmVmID0gYWx0MS5iaW5kUmVnaW9uKHJlY3QueCwgcmVjdC55LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XHJcbiAgICAgICAgaWYgKHJlZiA8PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoeDEgPCByZWN0LnggKyByZWN0LndpZHRoKSB7XHJcbiAgICAgICAgICAgIHZhciB4MiA9IE1hdGgubWluKHJlY3QueCArIHJlY3Qud2lkdGgsIE1hdGguZmxvb3IoeDEgKyAobWF4dHJhbnNmZXIgLyA0IC8gcmVjdC5oZWlnaHQpKSk7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gYWx0MS5iaW5kR2V0UmVnaW9uKHJlZiwgeDEsIHJlY3QueSwgeDIgLSB4MSwgcmVjdC5oZWlnaHQpO1xyXG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlY29kZUltYWdlU3RyaW5nKGRhdGEsIGJ1ZiwgeDEgLSByZWN0LngsIDAsIHgyIC0geDEsIHJlY3QuaGVpZ2h0KTtcclxuICAgICAgICAgICAgeDEgPSB4MjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYnVmO1xyXG59XHJcbi8qKlxyXG4gKiBNYWtlcyBhbHQxIGJpbmQgYW4gYXJlYSBvZiB0aGUgcnMgY2xpZW50IGluIG1lbW9yeSB3aXRob3V0IHNlbmRpbmcgaXQgdG8gdGhlIGpzIGNsaWVudFxyXG4gKiByZXR1cm5zIGFuIGltZ3JlZiBvYmplY3Qgd2hpY2ggY2FuIGJlIHVzZWQgdG8gZ2V0IHBpeGVsIGRhdGEgdXNpbmcgdGhlIGltZ3JlZnRvYnVmIGZ1bmN0aW9uXHJcbiAqIGN1cnJlbnRseSBvbmx5IG9uZSBiaW5kIGNhbiBleGlzdCBwZXIgYXBwIGFuZCB0aGUgcmVmIGluICh2KSB3aWxsIGFsd2F5cyBiZSAxXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2FwdHVyZUhvbGQoeCwgeSwgdywgaCkge1xyXG4gICAgeCA9IE1hdGgucm91bmQoeCk7XHJcbiAgICB5ID0gTWF0aC5yb3VuZCh5KTtcclxuICAgIHcgPSBNYXRoLnJvdW5kKHcpO1xyXG4gICAgaCA9IE1hdGgucm91bmQoaCk7XHJcbiAgICByZXF1aXJlQWx0MSgpO1xyXG4gICAgdmFyIHIgPSBhbHQxLmJpbmRSZWdpb24oeCwgeSwgdywgaCk7XHJcbiAgICBpZiAociA8PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEFsdDFFcnJvcihcImNhcHR1cmVob2xkIGZhaWxlZFwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgSW1nUmVmQmluZChyLCB4LCB5LCB3LCBoKTtcclxufVxyXG4vKipcclxuICogU2FtZSBhcyBjYXB0dXJlSG9sZFJlZ2lvbiwgYnV0IGNhcHR1cmVzIHRoZSBzY3JlZW4gaW5zdGVhZCBvZiB0aGUgcnMgY2xpZW50LiBpdCBhbHNvIHVzZXMgc2NyZWVuIGNvb3JkaW5hdGVzIGluc3RlYWQgYW5kIGNhbiBjYXB0dXJlIG91dHNpZGUgb2YgdGhlIHJzIGNsaWVudFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNhcHR1cmVIb2xkU2NyZWVuKHgsIHksIHcsIGgpIHtcclxuICAgIHggPSBNYXRoLnJvdW5kKHgpO1xyXG4gICAgeSA9IE1hdGgucm91bmQoeSk7XHJcbiAgICB3ID0gTWF0aC5yb3VuZCh3KTtcclxuICAgIGggPSBNYXRoLnJvdW5kKGgpO1xyXG4gICAgcmVxdWlyZUFsdDEoKTtcclxuICAgIHZhciByID0gYWx0MS5iaW5kU2NyZWVuUmVnaW9uKHgsIHksIHcsIGgpO1xyXG4gICAgaWYgKHIgPD0gMCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgSW1nUmVmQmluZChyLCB4LCB5LCB3LCBoKTtcclxufVxyXG4vKipcclxuICogYmluZCB0aGUgZnVsbCBycyB3aW5kb3cgaWYgdGhlIHJzIHdpbmRvdyBjYW4gYmUgZGV0ZWN0ZWQgYnkgYWx0MSwgb3RoZXJ3aXNlIHJldHVybiB0aGUgZnVsbCBzY3JlZW5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjYXB0dXJlSG9sZEZ1bGxScygpIHtcclxuICAgIHJldHVybiBjYXB0dXJlSG9sZCgwLCAwLCBhbHQxLnJzV2lkdGgsIGFsdDEucnNIZWlnaHQpO1xyXG59XHJcbi8qKlxyXG4gKiByZXR1cm5zIGEgc3VicmVnaW9uIGZyb20gYSBib3VuZCBpbWFnZVxyXG4gKiB1c2VkIGludGVybmFsbHkgaW4gaW1ncmVmdG9idWYgaWYgaW1ncmVmIGlzIGEgYm91bmQgaW1hZ2VcclxuICogQGRlcHJlY2F0ZWQgVGhpcyBzaG91bGQgYmUgaGFuZGxlZCBpbnRlcm5hbGwgYnkgdGhlIGltZ3JlZmJpbmQudG9EYXRhIG1ldGhvZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZmVySW1hZ2VEYXRhKGhhbmRsZSwgeCwgeSwgdywgaCkge1xyXG4gICAgeCA9IE1hdGgucm91bmQoeCk7XHJcbiAgICB5ID0gTWF0aC5yb3VuZCh5KTtcclxuICAgIHcgPSBNYXRoLnJvdW5kKHcpO1xyXG4gICAgaCA9IE1hdGgucm91bmQoaCk7XHJcbiAgICByZXF1aXJlQWx0MSgpO1xyXG4gICAgaWYgKGFsdDEuYmluZEdldFJlZ2lvbkJ1ZmZlcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgSW1hZ2VEYXRhKGFsdDEuYmluZEdldFJlZ2lvbkJ1ZmZlcihoYW5kbGUsIHgsIHksIHcsIGgpLCB3LCBoKTtcclxuICAgIH1cclxuICAgIHZhciByID0gbmV3IEltYWdlRGF0YSh3LCBoKTtcclxuICAgIHZhciB4MSA9IHg7XHJcbiAgICB3aGlsZSAodHJ1ZSkgeyAvL3NwbGl0IHVwIHRoZSByZXF1ZXN0IHRvIHRvIGV4Y2VlZCB0aGUgc2luZ2xlIHRyYW5zZmVyIGxpbWl0IChmb3Igbm93KVxyXG4gICAgICAgIHZhciB4MiA9IE1hdGgubWluKHggKyB3LCBNYXRoLmZsb29yKHgxICsgKG1heHRyYW5zZmVyIC8gNCAvIGgpKSk7XHJcbiAgICAgICAgdmFyIGEgPSBhbHQxLmJpbmRHZXRSZWdpb24oaGFuZGxlLCB4MSwgeSwgeDIgLSB4MSwgaCk7XHJcbiAgICAgICAgaWYgKCFhKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBBbHQxRXJyb3IoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVjb2RlSW1hZ2VTdHJpbmcoYSwgciwgeDEgLSB4LCAwLCB4MiAtIHgxLCBoKTtcclxuICAgICAgICB4MSA9IHgyO1xyXG4gICAgICAgIGlmICh4MSA9PSB4ICsgdykge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHI7XHJcbn1cclxuLyoqXHJcbiAqIGRlY29kZXMgYSByZXR1cm5lZCBzdHJpbmcgZnJvbSBhbHQxIHRvIGFuIGltYWdlYnVmZmVyXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlSW1hZ2VTdHJpbmcoaW1hZ2VzdHJpbmcsIHRhcmdldCwgeCwgeSwgdywgaCkge1xyXG4gICAgdmFyIGJpbiA9IGF0b2IoaW1hZ2VzdHJpbmcpO1xyXG4gICAgdmFyIGJ5dGVzID0gdGFyZ2V0LmRhdGE7XHJcbiAgICB3IHw9IDA7XHJcbiAgICBoIHw9IDA7XHJcbiAgICB2YXIgb2Zmc2V0ID0gNCAqIHggKyA0ICogeSAqIHRhcmdldC53aWR0aDtcclxuICAgIHZhciB0YXJnZXRfd2lkdGggPSB0YXJnZXQud2lkdGggfCAwO1xyXG4gICAgZm9yICh2YXIgYSA9IDA7IGEgPCB3OyBhKyspIHtcclxuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGg7IGIrKykge1xyXG4gICAgICAgICAgICB2YXIgaTEgPSAob2Zmc2V0ICsgKGEgKiA0IHwgMCkgKyAoYiAqIHRhcmdldF93aWR0aCAqIDQgfCAwKSkgfCAwO1xyXG4gICAgICAgICAgICB2YXIgaTIgPSAoKGEgKiA0IHwgMCkgKyAoYiAqIDQgKiB3IHwgMCkpIHwgMDtcclxuICAgICAgICAgICAgYnl0ZXNbaTEgKyAwIHwgMF0gPSBiaW4uY2hhckNvZGVBdChpMiArIDIgfCAwKTsgLy9maXggd2VpcmQgcmVkL2JsdWUgc3dhcCBpbiBjI1xyXG4gICAgICAgICAgICBieXRlc1tpMSArIDEgfCAwXSA9IGJpbi5jaGFyQ29kZUF0KGkyICsgMSB8IDApO1xyXG4gICAgICAgICAgICBieXRlc1tpMSArIDIgfCAwXSA9IGJpbi5jaGFyQ29kZUF0KGkyICsgMCB8IDApO1xyXG4gICAgICAgICAgICBieXRlc1tpMSArIDMgfCAwXSA9IGJpbi5jaGFyQ29kZUF0KGkyICsgMyB8IDApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn1cclxuLyoqXHJcbiAqIGVuY29kZXMgYW4gaW1hZ2VidWZmZXIgdG8gYSBzdHJpbmdcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVJbWFnZVN0cmluZyhidWYsIHN4ID0gMCwgc3kgPSAwLCBzdyA9IGJ1Zi53aWR0aCwgc2ggPSBidWYuaGVpZ2h0KSB7XHJcbiAgICB2YXIgcmF3ID0gXCJcIjtcclxuICAgIGZvciAodmFyIHkgPSBzeTsgeSA8IHN5ICsgc2g7IHkrKykge1xyXG4gICAgICAgIGZvciAodmFyIHggPSBzeDsgeCA8IHN4ICsgc3c7IHgrKykge1xyXG4gICAgICAgICAgICB2YXIgaSA9IDQgKiB4ICsgNCAqIGJ1Zi53aWR0aCAqIHkgfCAwO1xyXG4gICAgICAgICAgICByYXcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWYuZGF0YVtpICsgMiB8IDBdKTtcclxuICAgICAgICAgICAgcmF3ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmLmRhdGFbaSArIDEgfCAwXSk7XHJcbiAgICAgICAgICAgIHJhdyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1Zi5kYXRhW2kgKyAwIHwgMF0pO1xyXG4gICAgICAgICAgICByYXcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWYuZGF0YVtpICsgMyB8IDBdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYnRvYShyYXcpO1xyXG59XHJcbi8qKlxyXG4gKiBtaXhlcyB0aGUgZ2l2ZW4gY29sb3IgaW50byBhIHNpbmdsZSBpbnQuIFRoaXMgZm9ybWF0IGlzIHVzZWQgYnkgYWx0MVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG1peENvbG9yKHIsIGcsIGIsIGEgPSAyNTUpIHtcclxuICAgIHJldHVybiAoYiA8PCAwKSArIChnIDw8IDgpICsgKHIgPDwgMTYpICsgKGEgPDwgMjQpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB1bm1peENvbG9yKGNvbCkge1xyXG4gICAgdmFyIHIgPSAoY29sID4+IDE2KSAmIDB4ZmY7XHJcbiAgICB2YXIgZyA9IChjb2wgPj4gOCkgJiAweGZmO1xyXG4gICAgdmFyIGIgPSAoY29sID4+IDApICYgMHhmZjtcclxuICAgIHJldHVybiBbciwgZywgYl07XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aWZ5QXBwKHVybCkge1xyXG4gICAgaWYgKGhhc0FsdDEpIHtcclxuICAgICAgICBhbHQxLmlkZW50aWZ5QXBwVXJsKHVybCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0RW52aXJvbm1lbnQoKSB7XHJcbiAgICBoYXNBbHQxID0gKHR5cGVvZiBhbHQxICE9IFwidW5kZWZpbmVkXCIpO1xyXG4gICAgc2tpbk5hbWUgPSBoYXNBbHQxID8gYWx0MS5za2luTmFtZSA6IFwiZGVmYXVsdFwiO1xyXG59XHJcbmZ1bmN0aW9uIGNvbnZlcnRBbHQxVmVyc2lvbihzdHIpIHtcclxuICAgIHZhciBhID0gc3RyLm1hdGNoKC9eKFxcZCspXFwuKFxcZCspXFwuKFxcZCspJC8pO1xyXG4gICAgaWYgKCFhKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHZlcnNpb24gc3RyaW5nXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICgrYVsxXSkgKiAxMDAwICogMTAwMCArICgrYVsyXSkgKiAxMDAwICsgKCthWzNdKSAqIDE7XHJcbn1cclxudmFyIGNhY2hlZFZlcnNpb25JbnQgPSAtMTtcclxuLyoqXHJcbiAqIGNoZWNrcyBpZiBhbHQxIGlzIHJ1bm5pbmcgYW5kIGF0IGxlYXN0IHRoZSBnaXZlbiB2ZXJzaW9uLiB2ZXJzaW9uc3RyIHNob3VsZCBiZSBhIHN0cmluZyB3aXRoIHRoZSB2ZXJzaW9uIGVnOiAxLjMuMlxyXG4gKiBAcGFyYW0gdmVyc2lvbnN0clxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGhhc0FsdDFWZXJzaW9uKHZlcnNpb25zdHIpIHtcclxuICAgIGlmICghaGFzQWx0MSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChjYWNoZWRWZXJzaW9uSW50ID09IC0xKSB7XHJcbiAgICAgICAgY2FjaGVkVmVyc2lvbkludCA9IGFsdDEudmVyc2lvbmludDtcclxuICAgIH1cclxuICAgIHJldHVybiBjYWNoZWRWZXJzaW9uSW50ID49IGNvbnZlcnRBbHQxVmVyc2lvbih2ZXJzaW9uc3RyKTtcclxufVxyXG4vKipcclxuICogR2V0cyB0aGUgY3VycmVudCBjdXJzb3IgcG9zaXRpb24gaW4gdGhlIGdhbWUsIHJldHVybnMgbnVsbCBpZiB0aGUgcnMgd2luZG93IGlzIG5vdCBhY3RpdmUgKGFsdDEucnNBY3RpdmUpXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TW91c2VQb3NpdGlvbigpIHtcclxuICAgIHZhciBwb3MgPSBhbHQxLm1vdXNlUG9zaXRpb247XHJcbiAgICBpZiAocG9zID09IC0xKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyB4OiBwb3MgPj4+IDE2LCB5OiBwb3MgJiAweEZGRkYgfTtcclxufVxyXG4vKipcclxuICogUmVnaXN0ZXJzIGEgZ2l2ZW4gSFRNTCBlbGVtZW50IGFzIGEgZnJhbWUgYm9yZGVyLCB3aGVuIHRoaXMgZWxlbWVudCBpcyBkcmFnZ2VkIGJ5IHRoZSB1c2VyIHRoZSBBbHQxIGZyYW1lIHdpbGwgcmVzaXplIGFjY29yZGluZ2x5XHJcbiAqIFVzZSB0aGUgZGlyZWN0aW9uIGFyZ3VlbWVudHMgdG8gbWFrZSBhIGdpdmVuIGRpcmVjdGlvbiBzdGljayB0byB0aGUgbW91c2UuIGVnLiBPbmx5IHNldCBsZWZ0IHRvIHRydWUgdG8gbWFrZSB0aGUgZWxlbWVudCBiZWhhdmUgYXMgdGhlIGxlZnQgYm9yZGVyXHJcbiAqIE9yIHNldCBhbGwgdG8gdHJ1ZSB0byBtb3ZlIHRoZSB3aG9sZSB3aW5kb3cuIE5vdCBhbGwgY29tYmluYXRpb25zIGFyZSBwZXJtaXR0ZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGRSZXNpemVFbGVtZW50KGVsLCBsZWZ0LCB0b3AsIHJpZ2h0LCBib3QpIHtcclxuICAgIGlmICghaGFzQWx0MSB8fCAhYWx0MS51c2VyUmVzaXplKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGFsdDEudXNlclJlc2l6ZShsZWZ0LCB0b3AsIHJpZ2h0LCBib3QpO1xyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXJcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBvbih0eXBlLCBsaXN0ZW5lcikge1xyXG4gICAgcmVxdWlyZUFsdDEoKTtcclxuICAgIGlmICghYWx0MS5ldmVudHMpIHtcclxuICAgICAgICBhbHQxLmV2ZW50cyA9IHt9O1xyXG4gICAgfVxyXG4gICAgaWYgKCFhbHQxLmV2ZW50c1t0eXBlXSkge1xyXG4gICAgICAgIGFsdDEuZXZlbnRzW3R5cGVdID0gW107XHJcbiAgICB9XHJcbiAgICBhbHQxLmV2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcclxufVxyXG4vKipcclxuICogUmVtb3ZlcyBhbiBldmVudCBsaXN0ZW5lclxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XHJcbiAgICB2YXIgZWxpc3QgPSBhbHQxLmV2ZW50cyAmJiBhbHQxLmV2ZW50c1t0eXBlXTtcclxuICAgIGlmICghZWxpc3QpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgaSA9IGVsaXN0LmluZGV4T2YobGlzdGVuZXIpO1xyXG4gICAgaWYgKGkgPT0gLTEpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBlbGlzdC5zcGxpY2UoaSwgMSk7XHJcbn1cclxuLyoqXHJcbiAqIExpc3RlbnMgZm9yIHRoZSBldmVudCB0byBmaXJlIG9uY2UgYW5kIHRoZW4gc3RvcHMgbGlzdGVuaW5nXHJcbiAqIEBwYXJhbSBldmVudFxyXG4gKiBAcGFyYW0gY2JcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XHJcbiAgICByZXF1aXJlQWx0MSgpO1xyXG4gICAgdmFyIGZuID0gKGUpID0+IHtcclxuICAgICAgICByZW1vdmVMaXN0ZW5lcih0eXBlLCBmbik7XHJcbiAgICAgICAgbGlzdGVuZXIoZSk7XHJcbiAgICB9O1xyXG4gICAgb24odHlwZSwgZm4pO1xyXG59XHJcbjtcclxuLyoqXHJcbiAqIFVzZWQgdG8gcmVhZCBhIHNldCBvZiBpbWFnZXMgZnJvbSBhIGJpbmFyeSBzdHJlYW0gcmV0dXJuZWQgYnkgdGhlIEFsdDEgQVBJXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgSW1hZ2VTdHJlYW1SZWFkZXIge1xyXG4gICAgY29uc3RydWN0b3IocmVhZGVyLCAuLi5hcmdzKSB7XHJcbiAgICAgICAgdGhpcy5mcmFtZWJ1ZmZlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xyXG4gICAgICAgIHRoaXMucmVhZGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XHJcbiAgICAgICAgLy9wYXVzZWQgc3RhdGVcclxuICAgICAgICB0aGlzLnBhdXNlZGluZGV4ID0gLTE7XHJcbiAgICAgICAgdGhpcy5wYXVzZWRidWZmZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc3RyZWFtcmVhZGVyID0gcmVhZGVyO1xyXG4gICAgICAgIGlmIChhcmdzWzBdIGluc3RhbmNlb2YgSW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0RnJhbWVCdWZmZXIoYXJnc1swXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmdzWzBdID09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRGcmFtZUJ1ZmZlcihuZXcgSW1hZ2VEYXRhKGFyZ3NbMF0sIGFyZ3NbMV0pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIHNldEZyYW1lQnVmZmVyKGJ1ZmZlcikge1xyXG4gICAgICAgIGlmICh0aGlzLnJlYWRpbmcpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FuJ3QgY2hhbmdlIGZyYW1lYnVmZmVyIHdoaWxlIHJlYWRpbmdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZnJhbWVidWZmZXIgPSBidWZmZXI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENsb3NlcyB0aGUgdW5kZXJseWluZyBzdHJlYW0gYW5kIGVuZHMgcmVhZGluZ1xyXG4gICAgICovXHJcbiAgICBjbG9zZSgpIHtcclxuICAgICAgICB0aGlzLnN0cmVhbXJlYWRlci5jYW5jZWwoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSBzaW5nbGUgaW1hZ2UgZnJvbSB0aGUgc3RyZWFtXHJcbiAgICAgKi9cclxuICAgIG5leHRJbWFnZSgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkaW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhbHJlYWR5IHJlYWRpbmcgZnJvbSB0aGlzIHN0cmVhbVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZnJhbWVidWZmZXIpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZyYW1lYnVmZmVyIG5vdCBzZXRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5yZWFkaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdmFyIHN5bmN0aW1lID0gLURhdGUubm93KCk7XHJcbiAgICAgICAgICAgIHZhciBzdGFydHRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICB2YXIgciA9IGZhbHNlO1xyXG4gICAgICAgICAgICB3aGlsZSAoIXIpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhdXNlZGluZGV4ICE9IC0xICYmIHRoaXMucGF1c2VkYnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgciA9IHRoaXMucmVhZENodW5rKHRoaXMucGF1c2VkaW5kZXgsIHRoaXMuZnJhbWVidWZmZXIuZGF0YSwgdGhpcy5wYXVzZWRidWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3luY3RpbWUgKz0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0geWllbGQgdGhpcy5zdHJlYW1yZWFkZXIucmVhZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN5bmN0aW1lIC09IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcy5kb25lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0cmVhbSBjbG9zZWQgd2hpbGUgcmVhZGluZ1wiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSByZXMudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgciA9IHRoaXMucmVhZENodW5rKDAsIHRoaXMuZnJhbWVidWZmZXIuZGF0YSwgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3luY3RpbWUgKz0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkRlY29kZWQgYXN5bmMgaW1hZ2UsIFwiICsgdGhpcy5mcmFtZWJ1ZmZlci53aWR0aCArIFwieFwiICsgdGhpcy5mcmFtZWJ1ZmZlci5oZWlnaHQgKyBcIiB0aW1lOiBcIiArIChEYXRlLm5vdygpIC0gc3RhcnR0aW1lKSArIFwibXMgKFwiICsgc3luY3RpbWUgKyBcIm1zIG1haW4gdGhyZWFkKVwiKTtcclxuICAgICAgICAgICAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyYW1lYnVmZmVyO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmVhZENodW5rKGksIGZyYW1lZGF0YSwgYnVmZmVyKSB7XHJcbiAgICAgICAgLy92ZXJ5IGhvdCBjb2RlLCBleHBsaWNpdCBpbnQzMiBjYXN0aW5nIHdpdGggfDAgc3BlZWRzIGl0IHVwIGJ5IH4geDJcclxuICAgICAgICBpID0gaSB8IDA7XHJcbiAgICAgICAgdmFyIGZyYW1lc2l6ZSA9IGZyYW1lZGF0YS5sZW5ndGggfCAwO1xyXG4gICAgICAgIHZhciBwb3MgPSB0aGlzLnBvcztcclxuICAgICAgICB2YXIgZGF0YWxlbiA9IGJ1ZmZlci5sZW5ndGggfCAwO1xyXG4gICAgICAgIC8vdmFyIGRhdGEzMiA9IG5ldyBGbG9hdDY0QXJyYXkoYnVmZmVyLmJ1ZmZlcik7XHJcbiAgICAgICAgLy92YXIgZnJhbWVkYXRhMzIgPSBuZXcgRmxvYXQ2NEFycmF5KGZyYW1lZGF0YS5idWZmZXIpO1xyXG4gICAgICAgIC8vZml4IHBvc3NpYmxlIGJ1ZmZlciBtaXNhbGlnbm1lbnRcclxuICAgICAgICAvL2FsaWduIHRvIDE2IGZvciBleHRyYSBsb29wIHVucm9sbGluZ1xyXG4gICAgICAgIHdoaWxlIChpIDwgZGF0YWxlbikge1xyXG4gICAgICAgICAgICAvL3Nsb3cgbG9vcCwgZml4IGFsaWdubWVudCBhbmQgb3RoZXIgaXNzdWVzXHJcbiAgICAgICAgICAgIHdoaWxlIChpIDwgZGF0YWxlbiAmJiBwb3MgPCBmcmFtZXNpemUgJiYgKHBvcyAlIDE2ICE9IDAgfHwgISgoaSArIDE2IHwgMCkgPD0gZGF0YWxlbiAmJiAocG9zICsgMTYgfCAwKSA8PSBmcmFtZXNpemUpKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlbCA9IHBvcztcclxuICAgICAgICAgICAgICAgIGlmIChwb3MgJSA0ID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZWwgPSByZWwgKyAyIHwgMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChwb3MgJSA0ID09IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWwgPSByZWwgLSAyIHwgMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZyYW1lZGF0YVtyZWwgfCAwXSA9IGJ1ZmZlcltpIHwgMF07XHJcbiAgICAgICAgICAgICAgICBpID0gaSArIDEgfCAwO1xyXG4gICAgICAgICAgICAgICAgcG9zID0gcG9zICsgMSB8IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9mYXN0IHVucm9sbGVkIGxvb3AgZm9yIGxhcmdlIGNodW5rcyBpIHdpc2gganMgaGFkIHNvbWUgc29ydCBvZiBtZW1jcHlcclxuICAgICAgICAgICAgaWYgKHBvcyAlIDE2ID09IDApIHtcclxuICAgICAgICAgICAgICAgIHdoaWxlICgoaSArIDE2IHwgMCkgPD0gZGF0YWxlbiAmJiAocG9zICsgMTYgfCAwKSA8PSBmcmFtZXNpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICBmcmFtZWRhdGFbcG9zICsgMCB8IDBdID0gYnVmZmVyW2kgKyAyIHwgMF07XHJcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVkYXRhW3BvcyArIDEgfCAwXSA9IGJ1ZmZlcltpICsgMSB8IDBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZyYW1lZGF0YVtwb3MgKyAyIHwgMF0gPSBidWZmZXJbaSArIDAgfCAwXTtcclxuICAgICAgICAgICAgICAgICAgICBmcmFtZWRhdGFbcG9zICsgMyB8IDBdID0gYnVmZmVyW2kgKyAzIHwgMF07XHJcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVkYXRhW3BvcyArIDQgfCAwXSA9IGJ1ZmZlcltpICsgNiB8IDBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZyYW1lZGF0YVtwb3MgKyA1IHwgMF0gPSBidWZmZXJbaSArIDUgfCAwXTtcclxuICAgICAgICAgICAgICAgICAgICBmcmFtZWRhdGFbcG9zICsgNiB8IDBdID0gYnVmZmVyW2kgKyA0IHwgMF07XHJcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVkYXRhW3BvcyArIDcgfCAwXSA9IGJ1ZmZlcltpICsgNyB8IDBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZyYW1lZGF0YVtwb3MgKyA4IHwgMF0gPSBidWZmZXJbaSArIDEwIHwgMF07XHJcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVkYXRhW3BvcyArIDkgfCAwXSA9IGJ1ZmZlcltpICsgOSB8IDBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZyYW1lZGF0YVtwb3MgKyAxMCB8IDBdID0gYnVmZmVyW2kgKyA4IHwgMF07XHJcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVkYXRhW3BvcyArIDExIHwgMF0gPSBidWZmZXJbaSArIDExIHwgMF07XHJcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVkYXRhW3BvcyArIDEyIHwgMF0gPSBidWZmZXJbaSArIDE0IHwgMF07XHJcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVkYXRhW3BvcyArIDEzIHwgMF0gPSBidWZmZXJbaSArIDEzIHwgMF07XHJcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVkYXRhW3BvcyArIDE0IHwgMF0gPSBidWZmZXJbaSArIDEyIHwgMF07XHJcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVkYXRhW3BvcyArIDE1IHwgMF0gPSBidWZmZXJbaSArIDE1IHwgMF07XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb3VsZCBzcGVlZCBpdCB1cCBhbm90aGVyIHgyIGJ1dCB3b3VsZG4ndCBiZSBhYmxlIHRvIHN3YXAgci9iIHN3YXAgYW5kIHBvc3NpYmxlIGFsaWdubWVudCBpc3N1ZXNcclxuICAgICAgICAgICAgICAgICAgICAvL2ZyYW1lZGF0YTMyW3BvcyAvIDggKyAwIHwgMF0gPSBkYXRhMzJbaSAvIDggKyAwIHwgMF07XHJcbiAgICAgICAgICAgICAgICAgICAgLy9mcmFtZWRhdGEzMltwb3MgLyA4ICsgMSB8IDBdID0gZGF0YTMyW2kgLyA4ICsgMSB8IDBdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZnJhbWVkYXRhMzJbcG9zIC8gNCArIDIgfCAwXSA9IGRhdGEzMltpIC8gNCArIDIgfCAwXTtcclxuICAgICAgICAgICAgICAgICAgICAvL2ZyYW1lZGF0YTMyW3BvcyAvIDQgKyAzIHwgMF0gPSBkYXRhMzJbaSAvIDQgKyAzIHwgMF07XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zICsgMTYgfCAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGkgPSBpICsgMTYgfCAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwb3MgPj0gZnJhbWVzaXplKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhdXNlZGJ1ZmZlciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhdXNlZGluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSAhPSBidWZmZXIubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGF1c2VkYnVmZmVyID0gYnVmZmVyO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGF1c2VkaW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XHJcbiAgICAgICAgdGhpcy5wYXVzZWRidWZmZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucGF1c2VkaW5kZXggPSAtMTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFzeW5jaHJvbm91c2x5IGNhcHR1cmVzIGEgc2VjdGlvbiBvZiB0aGUgZ2FtZSBzY3JlZW5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjYXB0dXJlQXN5bmMoLi4uYXJncykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICByZXF1aXJlQWx0MSgpO1xyXG4gICAgICAgIHZhciByZWN0ID0gUmVjdC5mcm9tQXJncyguLi5hcmdzKTtcclxuICAgICAgICBpZiAoYWx0MS5jYXB0dXJlQXN5bmMpIHtcclxuICAgICAgICAgICAgbGV0IGltZyA9IHlpZWxkIGFsdDEuY2FwdHVyZUFzeW5jKHJlY3QueCwgcmVjdC55LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW1hZ2VEYXRhKGltZywgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWhhc0FsdDFWZXJzaW9uKFwiMS40LjZcIikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhcHR1cmUocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHVybCA9IFwiaHR0cHM6Ly9hbHQxYXBpL3BpeGVsL2dldHJlZ2lvbi9cIiArIGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlY3QpLCB7IGZvcm1hdDogXCJyYXdcIiwgcXVhbGl0eTogMSB9KSkpO1xyXG4gICAgICAgIHZhciByZXMgPSB5aWVsZCBmZXRjaCh1cmwpO1xyXG4gICAgICAgIHZhciBpbWdyZWFkZXIgPSBuZXcgSW1hZ2VTdHJlYW1SZWFkZXIocmVzLmJvZHkuZ2V0UmVhZGVyKCksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcclxuICAgICAgICByZXR1cm4gaW1ncmVhZGVyLm5leHRJbWFnZSgpO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIEFzeW5jaHJvbm91c2x5IGNhcHR1cmVzIG11bHRwbGUgYXJlYSdzLiBUaGlzIG1ldGhvZCBjYXB0dXJlcyB0aGUgaW1hZ2VzIGluIHRoZSBzYW1lIHJlbmRlciBmcmFtZSBpZiBwb3NzaWJsZVxyXG4gKiBAcGFyYW0gYXJlYXNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjYXB0dXJlTXVsdGlBc3luYyhhcmVhcykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICByZXF1aXJlQWx0MSgpO1xyXG4gICAgICAgIHZhciByID0ge307XHJcbiAgICAgICAgaWYgKGFsdDEuY2FwdHVyZU11bHRpQXN5bmMpIHtcclxuICAgICAgICAgICAgbGV0IGJ1ZnMgPSB5aWVsZCBhbHQxLmNhcHR1cmVNdWx0aUFzeW5jKGFyZWFzKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgYSBpbiBhcmVhcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFidWZzW2FdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgclthXSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByW2FdID0gbmV3IEltYWdlRGF0YShidWZzW2FdLCBhcmVhc1thXS53aWR0aCwgYXJlYXNbYV0uaGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNhcHRzID0gW107XHJcbiAgICAgICAgdmFyIGNhcHRpZHMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpZCBpbiBhcmVhcykge1xyXG4gICAgICAgICAgICBpZiAoYXJlYXNbaWRdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXB0cy5wdXNoKGFyZWFzW2lkXSk7XHJcbiAgICAgICAgICAgICAgICBjYXB0aWRzLnB1c2goaWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcltpZF0gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjYXB0cy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFoYXNBbHQxVmVyc2lvbihcIjEuNS4xXCIpKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9tcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8IGNhcHRzLmxlbmd0aDsgYSsrKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9tcy5wdXNoKGNhcHR1cmVBc3luYyhjYXB0c1thXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geWllbGQgUHJvbWlzZS5hbGwocHJvbXMpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8IGNhcHRzLmxlbmd0aDsgYSsrKSB7XHJcbiAgICAgICAgICAgICAgICByW2NhcHRpZHNbYV1dID0gcmVzdWx0c1thXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHJlcyA9IHlpZWxkIGZldGNoKFwiaHR0cHM6Ly9hbHQxYXBpL3BpeGVsL2dldHJlZ2lvbm11bHRpL1wiICsgZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHsgYXJlYXM6IGNhcHRzLCBmb3JtYXQ6IFwicmF3XCIsIHF1YWxpdHk6IDEgfSkpKTtcclxuICAgICAgICAgICAgdmFyIGltZ3JlYWRlciA9IG5ldyBJbWFnZVN0cmVhbVJlYWRlcihyZXMuYm9keS5nZXRSZWFkZXIoKSk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwgY2FwdHMubGVuZ3RoOyBhKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjYXB0ID0gY2FwdHNbYV07XHJcbiAgICAgICAgICAgICAgICBpbWdyZWFkZXIuc2V0RnJhbWVCdWZmZXIobmV3IEltYWdlRGF0YShjYXB0LndpZHRoLCBjYXB0LmhlaWdodCkpO1xyXG4gICAgICAgICAgICAgICAgcltjYXB0aWRzW2FdXSA9IHlpZWxkIGltZ3JlYWRlci5uZXh0SW1hZ2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBTdGFydHMgY2FwdHVyaW5nIGEgcmVhbHRpbWUgc3RyZWFtIG9mIHRoZSBnYW1lLiBNYWtlIHN1cmUgeW91IGtlZXAgcmVhZGluZyB0aGUgc3RyZWFtIGFuZCBjbG9zZSBpdCB3aGVuIHlvdSdyZSBkb25lIG9yIEFsdDEgV0lMTCBjcmFzaFxyXG4gKiBAcGFyYW0gZnJhbWVjYiBDYWxsZWQgd2hlbmV2ZXIgYSBuZXcgZnJhbWUgaXMgZGVjb2RlZFxyXG4gKiBAcGFyYW0gZXJyb3JjYiBDYWxsZWQgd2hlbmV2ZXIgYW4gZXJyb3Igb2NjdXJzLCB0aGUgZXJyb3IgaXMgcmV0aHJvd24gaWYgbm90IGRlZmluZWRcclxuICogQHBhcmFtIGZwcyBNYXhpbXVtIGZwcyBvZiB0aGUgc3RyZWFtXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2FwdHVyZVN0cmVhbSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBmcHMsIGZyYW1lY2IsIGVycm9yY2IpIHtcclxuICAgIHJlcXVpcmVBbHQxKCk7XHJcbiAgICBpZiAoIWhhc0FsdDFWZXJzaW9uKFwiMS40LjZcIikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgQWx0MUVycm9yKFwiVGhpcyBmdW5jdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgdmVyc2lvbiBvZiBBbHQxXCIpO1xyXG4gICAgfVxyXG4gICAgdmFyIHVybCA9IFwiaHR0cHM6Ly9hbHQxYXBpL3BpeGVsL3N0cmVhbXJlZ2lvbi9cIiArIGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeSh7IHgsIHksIHdpZHRoLCBoZWlnaHQsIGZwcywgZm9ybWF0OiBcInJhd1wiIH0pKTtcclxuICAgIHZhciByZXMgPSBmZXRjaCh1cmwpLnRoZW4oKHJlcykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgSW1hZ2VTdHJlYW1SZWFkZXIocmVzLmJvZHkuZ2V0UmVhZGVyKCksIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHdoaWxlICghcmVhZGVyLmNsb3NlZCAmJiAhc3RhdGUuY2xvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW1nID0geWllbGQgcmVhZGVyLm5leHRJbWFnZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5jbG9zZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBmcmFtZWNiKGltZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuZnJhbWVucisrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGlmICghc3RhdGUuY2xvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICByZWFkZXIuY2xvc2UoKTtcclxuICAgICAgICAgICAgICAgIGlmIChlcnJvcmNiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JjYihlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFyZWFkZXIuY2xvc2VkICYmIHN0YXRlLmNsb3NlZCkge1xyXG4gICAgICAgICAgICByZWFkZXIuY2xvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9KSk7XHJcbiAgICB2YXIgc3RhdGUgPSB7XHJcbiAgICAgICAgeCwgeSwgd2lkdGgsIGhlaWdodCxcclxuICAgICAgICBmcmFtZW5yOiAwLFxyXG4gICAgICAgIGNsb3NlOiAoKSA9PiB7IHN0YXRlLmNsb3NlZCA9IHRydWU7IH0sXHJcbiAgICAgICAgY2xvc2VkOiBmYWxzZSxcclxuICAgIH07XHJcbiAgICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/@alt1/base/dist/wrapper.js\n");

/***/ }),

/***/ "./images/easy_casket.data.png":
/*!*************************************!*\
  !*** ./images/easy_casket.data.png ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports=(__webpack_require__(/*! @alt1/base */ \"../node_modules/@alt1/base/dist/index.js\").ImageDetect.imageDataFromBase64)(\"iVBORw0KGgoAAAANSUhEUgAAACYAAAAiCAIAAAC8zjzvAAAAAW5vUEUAYtdMlAAAAARub1BFAAAAAEEgjiIAAAAJbm9QRQAAAAAAAAAAAKGKctUAAApkSURBVFhHZVdLjBxHGe7u6nfPs3d2d3Z21+vddRw7KImTEG48hMSJI2fOQYqQAlIkIyH5kJxCEIkQEhEHJCTC1SRBOQRQoiRIgIgSRzbr2F7PPj2PnZmd6elXVVcXX3VvQgTl2XZ1ddX/+P5nqc31C6qiaILzXNEJ0XSSZ1xRFPwR/IdPmsY5w4QYJj5hg1wVOaWZaZk0pV8+JQRXVaJpCmXcNAie8qum5LmScW6aJIyZ2t66NJmeYrduGBljOCApYmArCPAvrRSD6IRnHE8wMwxD1VR5iuiS6udfy52cc8MgjHFCJIXytVapajzLsBl0cyG5RoMjjRBV/ilCUXNFwxy/XFXx5BAiy+Qrjug645I6Tik5xyKUxOvnEwF8GBe6YRJdy4UAP3DNKFMX17emUaIBXEKiBweqip1qZW0bpKWoxchzkedc13VM8DXLMsu2C1k5Vujw+Gzf/w1zsYP9mhRCUUEj545uqn5nI84E8AchfEj6h1DQ6Wxhzig1TBMTfCKaykG9f4DX/xnf/953L19+en1186i33z8+dizN8aor5zbns8lzP7lqLq9rIgdq4AdwK7alLm9sB5RDy7yw2fzgHlhWz13kQgn375REvxjXfvxD066eDvYsp3bpye9QGvf2PqNpOk/C5sKSyMW9nY/TeOB5Ps/54vplIZSXXnkZXOVhsFTUVtVR25sXx/NYhx/CZqoW7N8BSyEAtPLLX7xKk/TksLu8srr50FOD3v3dWx9arl9f2jStymzSp3E4Hh0xlg6Go8ef/jqO7O58kgTHRDfrfsetL6qGlVP28q9edVc3M5oC5Lptqp2ti+MwhpvAXzTdLFm+8NMXLz/6hGGY8Po4mo163fHw+N7tD3TVMDQdpB1vwW2eI8SW4iOQbBseOB72Zqcjf3EJooMYSwJ4vFlbfOnVl+FNzsoGzF8H7rApXABupupWeHivJPH+X954+/rrcRSGUdDrHQIfbCDEUzUTjogIngfD0XB/ONwb9HYfPLjT/exGd+eT4+5OEo6iyUARqmVWISpcVMZPMUABDggqpNJspfAO+UGk0zE89to15Z23nhyMxrc/uwk5ADL8MheG0Bu55uVCT9MsDpPa4qpTqQGDcDaqaaEjohXfavuVmGrByYHKKdGtIAqQLp668tg/PvpYdas5545paOAPJ5buKrOGhvDD+N31t8DlwdH+rRv/jObzKIoQJq7rasSwK35j5UKjvVWpLcFmcTx1nGqr5TcW6gjB6XgaTk+wDRZorW23OuchVqGkQvv7II8AJfXWcsKYYegC0Vqps/n0W1cuP7yxTizH0I3egwORZ7VqkzEGIZLZSTQ55iw2nLpXaXBOg1PAKLQ0nk5OKaWm69r+lr+0Xm+t2F49V5U4DF759WuA0F3dgk/acAbwR8DBPECvxN20PNCH3ohdjdPJyfB0MkbQa/ASxzUsF+fjWR8RwliG3JdmCrdbzbWvLG48urx+ceXcRa/uz2ejw91b+7c/OTncLZREVpa5SdqyudROKIVxVSCNcJ1Ptze3c4UgL/CMGQoXMpXbtWqDaESILKNzyuI0CcyKz7lue35zad1rthvtNU684TQdHd0+6R2OTk7SMFBYkGXsxt0umCFugIdjGRpnTMlSJJpCFDkyBnbQXkftUDQzy+lkMpoFU3xyK3ViO5Cv1dmuNVoLy8vt1bWGv5DEcfd+d+ffO/0H/WAeX/zmt23baPnuQs0raWIImQpk8lQ3Lj02DiOaAVyZRfEpOu5+48mnZF7ULBSwHCjzfHPzoXPrm7qJQhYDG8OyhWalMZsH0zieR0EE1H7w/LOwt9uo//bFF0ydpGnK4uA3b/y5NGTBjy/Wa9KWlDKkUN3QWSbrIkbGEl1T9DxSGFIGMW2Lch4xFoczFCc9F7PRcLB/Z//ep/2j3cFh95nnn33uhatAH/xwHJyiYKJkUSrNJweQK7WERSVLJLgSWISBYVmYyPSXc8txoZVJuGG6lGdBFEZRcnoyON7fO9g76B8f6GzWdtKf/+F1MMOpL0aFMJegsqVJnJQrukym0EuDhwIohLlAxQCqEAQuKHdokAvumIIrXuNwOhn1Rye90yA4Gk57pzPPNtd8d7VhO/KcUZA9G++9+36SsWmcnM7BMT5bLeoXiizUPEsFOAdFESrgZLU3/vrRTcoprJvGkZROM+JoPp0MWRot1r2NpeZCrWoZBs3FafRfv7v+xzd/9qPnb775eyyGKUMxefODfwFLb+1C4SWYSn1kwsE/+S6BzuEassorShqHNE0MhfEUvj6vWlrNtT2dOyTWcxSr0Qh+PJoIlmIzmL129bk77/wpi8dwN5LJ6h8mUUEVjBDk0payZCLZbl5+fDgNNDQ+WaYTLaWZZRmzvbtXzncMXalWPMcyw5QjmVXqrYpDHJUJ9FpZbuOrY2YsjxKZFBL4oE4EsMt5muXX/3ajZOetbQr0L2AIV8r5iu9roIVtjKZwKhCCloAXw7J0iASwwc+yPOAwG/cno/EsogbRfSmJPguS3iQ4CSKGg4W14PPxGT/Z/njrD0EIOVQN2MKCEAvZpxPFIcyLZg5r8ChUGL3avL97f7lWzURG0LVAPEgpc4dZ92y0D1GaTabzeZKgAapYZgJXQ/Li+fUPbtw+6JfKGdUFUCvKBFoRpBeBolH1KsRf7gRRBF05sgEKK5HdIsC3/aWD/b1mrUoFWlC0aJplN+xKI0n5eDSZhwnkgCwYQSqd5e2/39zZl8ywUigH7QS4QQFQQ8sFxkh4svfZfvSr/fEIJkScyFVVZWkqdwBiTQsP7j5yvqMUzR70b1Zdx5YNWDE44xSU3/24bJHOmBVzOeA1Z/UZ+JT45ny52UTEy8B0XBf/QaKMpcgGcFo4niIyt3P+VvcY6RYDwqY0QtZA8UrD0zCJP+d3ZjZ/+xGwKX/yAFbzHFH3xSs8FE/Saq8BWM6FaZpwH1n8CBijSUeDIBtJvdLoHR4u+lVcA2p1H9kD/RVi671Pd7u9ccmsutjGdiQPMJH2w5VAAExpSFCT4CmCYC3P6xVPlmiUIsQnTCjzQ9HloHsAwuivAS6EMBstJLlmw0NLlyv0w5vd+4NJoZxir26jtIJFmlDZ32OAK97hMlAOeMofaKBaQgel5jrqw1e+djQYQDbsgDk5XEhmYVZeUcpnmfQRrJKiHJK01T6PJzZAqqLeyVJvO3aZMr88RCZDGdqjrzzfWYHK8EaJMsIxTlLpaVCzuLiAU8kVtPDqrV8omAkwA5iFHFIgHJRgwrsMo8zjWMQTziEvXcCtCJXSkPJeJndALlw5DISlbLfgJ3gFFmWuxwTPFLALYa9eOEuYMkvC5BRzpGJ8giqoSGiG8USWwIpl6AhV7IQOumnpELHItBplDBdB09AhBZQDApACSQKTJGVIlpgg48MW0h55BpPIH2fFvRELtNwAb5BAFc8koRKAXMgLI4fHIlOcIY/0pK5degLWMHAnRbsnRUcBli4A6eRFRQ6YVwIrNwBw3HAL3MpRlAR03nLgFM7KS5x0QRR86T6oEmVNBDn0Aoxn/wGP33qTsLS2zgAAAABJRU5ErkJggg==\")//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9pbWFnZXMvZWFzeV9jYXNrZXQuZGF0YS5wbmcuanMiLCJtYXBwaW5ncyI6IkFBQUEsZUFBZSxtSEFBcUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9URVNULy4vaW1hZ2VzL2Vhc3lfY2Fza2V0LmRhdGEucG5nP2E4NWMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHM9cmVxdWlyZShcIkBhbHQxL2Jhc2VcIikuSW1hZ2VEZXRlY3QuaW1hZ2VEYXRhRnJvbUJhc2U2NChcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDWUFBQUFpQ0FJQUFBQzh6anp2QUFBQUFXNXZVRVVBWXRkTWxBQUFBQVJ1YjFCRkFBQUFBRUVnamlJQUFBQUpibTlRUlFBQUFBQUFBQUFBQUtHS2N0VUFBQXBrU1VSQlZGaEhaVmRMakJ4SEdlN3U2bmZQczNkMmQzWjIxK3ZkZFJ3N0tJbVRFRzQ4aE1TSkkyZk9RWXFRQWxJa0l5SDVrSnhDRUlrUUVoRUhKQ1RDMVNSQk9RUlFvaVJJZ0lnU1J6YnIyRjdQUGoyUG5abWQ2ZWxYVlZjWFgzVnZRZ1RsMlhaMWRkWC8rUDVucWMzMUM2cWlhSUx6WE5FSjBYU1NaMXhSRlB3Ui9JZFBtc1k1dzRRWUpqNWhnMXdWT2FXWmFaazBwVjgrSlFSWFZhSnBDbVhjTkFpZThxdW01TG1TY1c2YUpJeVoydDY2TkptZVlyZHVHQmxqT0NBcFltQXJDUEF2clJTRDZJUm5IRTh3TXd4RDFWUjVpdWlTNnVkZnk1MmNjOE1nakhGQ0pJWHl0VmFwYWp6THNCbDBjeUc1Um9NampSQlYvaWxDVVhORnd4eS9YRlh4NUJBaXkrUXJqdWc2NDVJNlRpazV4eUtVeE92bkV3RjhHQmU2WVJKZHk0VUFQM0ROS0ZNWDE3ZW1VYUlCWEVLaUJ3ZXFpcDFxWlcwYnBLV294Y2h6a2VkYzEzVk04RFhMTXN1MkMxazVWdWp3K0d6Zi93MXpzWVA5bWhSQ1VVRWo1NDV1cW41bkk4NEU4QWNoZkVqNmgxRFE2V3hoemlnMVRCTVRmQ0theWtHOWY0RFgveG5mLzk1M0wxOStlbjExODZpMzN6OCtkaXpOOGFvcjV6Ym5zOGx6UDdscUxxOXJJZ2RxNEFkd0s3YWxMbTlzQjVSRHk3eXcyZnpnSGxoV3oxM2tRZ24zNzVSRXZ4alhmdnhEMDY2ZUR2WXNwM2JweWU5UUd2ZjJQcU5wT2svQzVzS1N5TVc5blkvVGVPQjVQcy81NHZwbElaU1hYbmtaWE9WaHNGVFVWdFZSMjVzWHgvTlloeC9DWnFvVzdOOEJTeUVBdFBMTFg3eEtrL1Rrc0x1OHNycjUwRk9EM3YzZFd4OWFybDlmMmpTdHltelNwM0U0SGgweGxnNkdvOGVmL2pxTzdPNThrZ1RIUkRmcmZzZXRMNnFHbFZQMjhxOWVkVmMzTTVvQzVMcHRxcDJ0aStNd2hwdkFYelRkTEZtKzhOTVhMei82aEdHWThQbzRtbzE2M2ZIdytON3REM1RWTURRZHBCMXZ3VzJlSThTVzRpT1FiQnNlT0I3MlpxY2pmM0VKb29NWVN3SjR2RmxiZk9uVmwrRk56c29HekY4SDdyQXBYQUJ1cHVwV2VIaXZKUEgrWDk1NCsvcnJjUlNHVWREckhRSWZiQ0RFVXpVVGpvZ0luZ2ZEMFhCL09Od2I5SFlmUExqVC9leEdkK2VUNCs1T0VvNml5VUFScW1WV0lTcGNWTVpQTVVBQkRnZ3FwTkpzcGZBTytVR2swekU4OXRvMTVaMjNuaHlNeHJjL3V3azVBREw4TWhlRzBCdTU1dVZDVDlNc0RwUGE0cXBUcVFHRGNEYXFhYUVqb2hYZmF2dVZtR3JCeVlIS0tkR3RJQXFRTHA2Njh0Zy9QdnBZZGFzNTU0NXBhT0FQSjVidUtyT0dodkREK04zMXQ4RGx3ZEgrclJ2L2pPYnpLSW9RSnE3cmFzU3dLMzVqNVVLanZWV3BMY0ZtY1R4MW5HcXI1VGNXNmdqQjZYZ2FUayt3RFJab3JXMjNPdWNoVnFHa1F2djdJSThBSmZYV2NzS1lZZWdDMFZxcHMvbjBXMWN1UDd5eFRpekgwSTNlZ3dPUlo3VnFrekVHSVpMWlNUUTU1aXcybkxwWGFYQk9nMVBBS0xRMG5rNU9LYVdtNjlyK2xyKzBYbSt0MkY0OVY1VTRERjc1OVd1QTBGM2Rnay9hY0Fid1I4REJQRUN2eE4yMFBOQ0gzb2hkamRQSnlmQjBNa2JRYS9BU3h6VXNGK2ZqV1I4UndsaUczSmRtQ3JkYnpiV3ZMRzQ4dXJ4K2NlWGNSYS91ejJlanc5MWIrN2MvT1RuY0xaUkVWcGE1U2RxeXVkUk9LSVZ4VlNDTmNKMVB0emUzYzRVZ0wvQ01HUW9YTXBYYnRXcURhRVNJTEtOenl1STBDY3lLejdsdWUzNXphZDFydGh2dE5VNjg0VFFkSGQwKzZSMk9UazdTTUZCWWtHWHN4dDB1bUNGdWdJZGpHUnBuVE1sU0pKcENGRGt5Qm5iUVhrZnRVRFF6eStsa01wb0ZVM3h5SzNWaU81Q3YxZG11TlZvTHk4dnQxYldHdjVERWNmZCtkK2ZmTy8wSC9XQWVYL3ptdDIzYmFQbnVRczByYVdJSW1RcGs4bFEzTGowMkRpT2FBVnlaUmZFcE91NSs0OG1uWkY3VUxCU3dIQ2p6ZkhQem9YUHJtN3FKUWhZREc4T3loV2FsTVpzSDB6aWVSMEVFMUg3dy9MT3d0OXVvLy9iRkYweWRwR25LNHVBM2IveTVOR1RCankvV2E5S1dsREtrVU4zUVdTYnJJa2JHRWwxVDlEeFNHRklHTVcyTGNoNHhGb2N6RkNjOUY3UFJjTEIvWi8vZXAvMmozY0ZoOTVubm4zM3VoYXRBSC94d0hKeWlZS0prVVNyTkp3ZVFLN1dFUlNWTEpMZ1NXSVNCWVZtWXlQU1hjOHR4b1pWSnVHRzZsR2RCRkVaUmNub3lPTjdmTzlnNzZCOGY2R3pXZHRLZi8rRjFNTU9wTDBhRk1KZWdzcVZKbkpRcnVreW0wRXVEaHdJb2hMbEF4UUNxRUFRdUtIZG9rQXZ1bUlJclh1TndPaG4xUnllOTB5QTRHazU3cHpQUE50ZDhkN1ZoTy9LY1VaQTlHKys5KzM2U3NXbWNuTTdCTVQ1Ykxlb1hpaXpVUEVzRk9BZEZFU3JnWkxVMy92clJUY29wckp2R2taUk9NK0pvUHAwTVdSb3QxcjJOcGVaQ3JXb1pCczNGYWZSZnY3dit4emQvOXFQbmI3NzVleXlHS1VNeGVmT0Rmd0ZMYisxQzRTV1lTbjFrd3NFLytTNkJ6dUVhc3NvclNocUhORTBNaGZFVXZqNnZXbHJOdFQyZE95VFdjeFNyMFFoK1BKb0lsbUl6bUwxMjliazc3L3dwaThkd041TEo2aDhtVVVFVmpCRGswcGF5WkNMWmJsNStmRGdOTkRRK1dhWVRMYVdaWlJtenZidFh6bmNNWGFsV1BNY3l3NVFqbVZYcXJZcERISlVKOUZwWmJ1T3JZMllzanhLWkZCTDRvRTRFc010NW11WFgvM2FqWk9ldGJRcjBMMkFJVjhyNWl1OXJvSVZ0aktad0toQ0Nsb0FYdzdKMGlBU3d3Yyt5UE9Bd0cvY25vL0Vzb2diUmZTbUpQZ3VTM2lRNENTS0dnNFcxNFBQeEdUL1ovbmpyRDBFSU9WUU4yTUtDRUF2WnB4UEZJY3lMWmc1cjhDaFVHTDNhdkw5N2Y3bFd6VVJHMExWQVBFZ3BjNGRaOTJ5MEQxR2FUYWJ6ZVpLZ0FhcFlaZ0pYUS9MaStmVVBidHcrNkpmS0dkVUZVQ3ZLQkZvUnBCZUJvbEgxS3NSZjdnUlJCRjA1c2dFS0s1SGRJc0MzL2FXRC9iMW1yVW9GV2xDMGFKcGxOK3hLSTBuNWVEU1pod25rZ0N3WVFTcWQ1ZTIvMzl6Wmw4eXdVaWdIN1FTNFFRRlFROHNGeGtoNHN2ZlpmdlNyL2ZFSUprU2N5RlZWWldrcWR3QmlUUXNQN2o1eXZxTVV6UjcwYjFaZHg1WU5XREU0NHhTVTMvMjRiSkhPbUJWek9lQTFaL1VaK0pUNDVueTUyVVRFeThCMFhCZi9RYUtNcGNnR2NGbzRuaUl5dDNQK1Z2Y1k2UllEd3FZMFF0WkE4VXJEMHpDSlArZDNaalovK3hHd0tYL3lBRmJ6SEZIM3hTczhGRS9TYXE4QldNNkZhWnB3SDFuOENCaWpTVWVESUJ0SnZkTG9IUjR1K2xWY0EycDFIOWtEL1JWaTY3MVBkN3U5Y2Ntc3V0akdkaVFQTUpIMnc1VkFBRXhwU0ZDVDRDbUNZQzNQNnhWUGxtaVVJc1FuVENqelE5SGxvSHNBd3VpdkFTNkVNQnN0SkxsbXcwTkxseXYwdzV2ZCs0TkpvWnhpcjI2anRJSkZtbERaMzJPQUs5N2hNbEFPZU1vZmFLQmFRZ2VsNWpycXcxZStkalFZUURic2dEazVYRWhtWVZaZVVjcG5tZlFSckpLaUhKSzAxVDZQSnpaQXFxTGV5Vkp2TzNhWk1yODhSQ1pER2RxanJ6emZXWUhLOEVhSk1zSXhUbExwYVZDenVMaUFVOGtWdFBEcXJWOG9tQWt3QTVpRkhGSWdISlJnd3JzTW84empXTVFUemlFdlhjQ3RDSlhTa1BKZUpuZEFMbHc1RElTbGJMZmdKM2dGRm1XdXh3VFBGTEFMWWE5ZU9FdVlNa3ZDNUJSenBHSjhnaXFvU0dpRzhVU1d3SXBsNkFoVjdJUU91bW5wRUxISXRCcGxEQmRCMDlBaEJaUURBcEFDU1FLVEpHVklscGdnNDhNVzBoNTVCcFBJSDJmRnZSRUx0TndBYjVCQUZjOGtvUktBWE1nTEk0ZkhJbE9jSVkvMHBLNWRlZ0xXTUhBblJic25SVWNCbGk0QTZlUkZSUTZZVndJck53QnczSEFMM01wUmxBUjAzbkxnRk03S1M1eDBRUlI4NlQ2b0VtVk5CRG4wQW94bi93R1AzM3FUc0xTMnpnQUFBQUJKUlU1RXJrSmdnZz09XCIpIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./images/easy_casket.data.png\n");

/***/ }),

/***/ "../node_modules/file-loader/dist/cjs.js?name=[name].[ext]!./appconfig.json":
/*!**********************************************************************************!*\
  !*** ../node_modules/file-loader/dist/cjs.js?name=[name].[ext]!./appconfig.json ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"appconfig.json\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2ZpbGUtbG9hZGVyL2Rpc3QvY2pzLmpzP25hbWU9W25hbWVdLltleHRdIS4vYXBwY29uZmlnLmpzb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLHFCQUF1QixtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9URVNULy4vYXBwY29uZmlnLmpzb24/ZmIyMyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiYXBwY29uZmlnLmpzb25cIjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/file-loader/dist/cjs.js?name=[name].[ext]!./appconfig.json\n");

/***/ }),

/***/ "../node_modules/file-loader/dist/cjs.js?name=[name].[ext]!./index.html":
/*!******************************************************************************!*\
  !*** ../node_modules/file-loader/dist/cjs.js?name=[name].[ext]!./index.html ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"index.html\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2ZpbGUtbG9hZGVyL2Rpc3QvY2pzLmpzP25hbWU9W25hbWVdLltleHRdIS4vaW5kZXguaHRtbC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUscUJBQXVCLGVBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9URVNULy4vaW5kZXguaHRtbD8xMmRlIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJpbmRleC5odG1sXCI7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/file-loader/dist/cjs.js?name=[name].[ext]!./index.html\n");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"testing\": () => (/* binding */ testing),\n/* harmony export */   \"showSubImage\": () => (/* binding */ showSubImage)\n/* harmony export */ });\n/* harmony import */ var _alt1_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @alt1/base */ \"../node_modules/@alt1/base/dist/index.js\");\n\n__webpack_require__(/*! !file-loader?name=[name].[ext]!./index.html */ \"../node_modules/file-loader/dist/cjs.js?name=[name].[ext]!./index.html\");\n__webpack_require__(/*! !file-loader?name=[name].[ext]!./appconfig.json */ \"../node_modules/file-loader/dist/cjs.js?name=[name].[ext]!./appconfig.json\");\nvar images = _alt1_base__WEBPACK_IMPORTED_MODULE_0__.ImageDetect.webpackImages({\n    easyCasket: __webpack_require__(/*! ./images/easy_casket.data.png */ \"./images/easy_casket.data.png\")\n});\nfunction testing() {\n    var fullScreenImage = _alt1_base__WEBPACK_IMPORTED_MODULE_0__.captureHoldFullRs();\n    var position = fullScreenImage.findSubimage(images.easyCasket);\n    console.log(\"POSITION:\");\n    console.log(position);\n}\nfunction showSubImage(x, y, w, h) {\n    _alt1_base__WEBPACK_IMPORTED_MODULE_0__.capture(x, y, w, h).show();\n}\nif (window.alt1) {\n    alt1.identifyAppUrl(\"./appconfig.json\");\n}\n// \"use strict\";\n// A1lib.identifyApp(\"appconfig.json\");\n// let ectoplasmator = \"iVBORw0KGgoAAAANSUhEUgAAACcAAAAkCAYAAAAKNyObAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAsdSURBVFhHfVhbbBxXGf5nZmdmb7ZjOxensWPHXdNcSNQgkUQJClGIGlJQpQKvPCCkIiChL/DCA8pTnyqhKGnTFilCqEICibZcXihVVaGUQKpKVQilSRNix7mYJL7t2uvdmdkdvu8/c9ZuLnzW8Zk5c85//vPfzzql9SNpmsSStES6evukNjsjYRBKO4lEHE9cz5OcJ7K41BSiVAglwPc63jl+P9ycL1Ez1ud2q4W5nq5ttxLpKneLm8/LYrUqPug2o6buZXuiETUkCANJW21xyuuGU99zxHMdwbsEvi8xCKXtVCcTnAzq0uICxwUDHpjHaYCkFWOtq2tz2JBopW3xQcesaWGNh3ktfHfQL9PlfNIiLD1xQBNT2u1EnN7HRtJ6s6EECBIjApwwajTEyzb0QCRqQpp8zsbS1DAcBL72nudKHJv1vu+J45o1fOa4XWf3cCAQl4d1eci2CoRzCqC3uBSB8VxOCesCcB2Evm7iOHjhKkkhiVTa4kpYKKgU+c6NOeZ4OanfuS1+mNcxruE8NxdIFCf6HFNaGS0eUp/RiqWytLFPCgY98KG0KWkygnFnzcZKOrewoKppZ9IjETLdxkmoiiZO7+A7x4gkSUDb0e/R3VsYgU7BqIXfPyAhNiLjObQYdsTvbaibawlLn3QIMteEpvjWWy5JM8ae64Yr6cxCXSfki0VpYXGLUoJoSYgtbcOGAtgdYBlsgFAY5KQ2eU1efOFnOkb8+KfH8X+ZUcJfs0HXkxbXs+faBHbWUgFQe3SeHI8gudSRWr0hbjtTERlLEnyA16SZTdBbQz/XYSyGV6VwlsYSTghJ0glWYvzYP+Ro7UjGbFuefeYbUqmMSXz3pjJlmzpQCpv0AnNYiIvqJm2aGG00XyqJS6nk8IESg4jQx9iYqmyKn+M5IAXM4ckKsJ8Ip+V3eIN6rgUZW4kXX6AERbZv3a4MVic+1fncnAIReDmsTemykUkIURvf+R1hDB4WRapKiphGTK/J+YEs1ZdUBfXbE9Kcuq5hIBcWsKWj3z3Yo8XIyd3Z0zL27fm89nt37dN+8cYVpadhCgavagYdC3UWwEefgwBwdEfVliIm5ahCBFE/DCWJKUEXTE3I4UOHsaQt9Zv/kcWJS0qAaGSBefJmTSZv1GBwmx9gkgz+6te/xFMqPZs26xjpsxGQjeQRtmKEM0qMgoqhnRr8AN76eFptJtCcMXoVMU5jA+bi5JWHGnzPpidk/toyo8TR7z2PeBbJWGXNZ9R8du9t+eifF6T42IgKoIkMki/k1XaJNgVDU4E0qYzufCDT1TpsDnbG7GCN3mIJ3kLGjhz+mr7bzWhLNHQydrR2+DPt1KsndM7lK3cpqA42bargPyR/axz7G1NoLNV13xBx1c3CFM2KoOQCcOmGsCHqno3wGBThNXQSogQvtoyxP/fBx/LmH97Q9/tBBl89c1rm52dl5JRRr1Xzs898Sw4dOCTz458qQ5CJMqNShFqRP7TX2AjNMXCru9FjeQoLTvAR5x6G6Zl72pORR4EpibCMWcfAB+3oubS5ru5u7IW8y7yKVJginxIsNphbXUqMkmasS+CpTE10hk6CRsdNbFuprkfhv/emsqf/jwaMnzEP3EBqjAKiWYLVDKMCigIkXuXephWKvK32VqmMQvRZQM7w9a/ulye375BTXX/ORpbBsYMHDsrTT31JTcCaw/kPL8nghiHZtiWTYAYbiRKktwTxNUI5wiLCh9OUu1Be0fNccE6GiAhZII9gS+zfe1D7+2HZXcmgfc7IPICTp0/IiZd+jqdUwgF4bWbTtG9GCnpukDP5mpG43VwQZ3BsW3pnbh5LjMfGUCmZZXz7zre/q941OzejdmMlQbw+dE77ubk57XnIY8d+Is3FBfkcQokFpUb89ne/wf9USkNjajY5VDFpbOJkDK2x/mPMa8H++pD4F1CMOMObd6S37t5DTkUogb2hnMR0eCxOE92Z1MU/eO6YjI70dpizhr4Sr5x5XY4c+aasXrNObo5f7TD41p/e0/7s3/6K/6l0D49lHsoMZHI0x1kp5/MMzI70oI9g896q1QPHG3QKOgT0rjYHJinFoKdP4uq0fPDheRl7fIdsulyRVecHuZeCzM7tvqntUPy0zC8g1dUXZQD2FbhGKp9cHkeAdWX8+ri+S6EboYKxDfUa9qRKuWdLwxdiHSRXLhShkaoJJdYZ/KyOZ8CkLbBRDcHaIXnptZPy/t8vansUhtcbW70f7519N3tCQQFzofoYDRKolYwSzBjNKNG6jlmqWArF2fjE9nRqZlbdmZyzcjDM4kT+cv6rTlyRHz73I7k1dUPHOrHrIZi4vaTqLeWq2YiBSX2ESX/M51QxazuaUROhjPeO9f39UkVu9Vb1r1W1ugi8GucgLVMKIX2wYoCKWeHE1RnZvWuPdJW69RZ1fXIKh8jJ9Gxd5uYbcu9eTfr7Srr1qi5cktphp1kVP/WVA6BXkKvXrkpzDnbe3a+1G0EmHQoHzz3loszX4BAjW3emU9MzvEzoJJv4CXqVBVMOpUcc/f7zcgqhYSXoNAQdh7DSI1ZK8O13zsnb7/4FTyakUJ00nxiCoZ0nCGVre3tl6s5dY3OsCihi2oAFGaOoaRMqcop/YBhf0owxporl9jJs8tZto3IyRvzr4gXtr16b7rTBQdIwIO0YRe1SowmhmADJDKc3sGJBnNFtO9Mb4JJxjuo01YHJtZqEESxJAK6lDNP1uTiHKpn1nAkFUAsMfWVpRZz/yHjoridH5I3fvyMfX7qoXmhg6jtTNpkrIW2dpdP6/j5Iblq8voHB4wtwf25ulpgqGOLSjXnvDFkMRggz8Iw2TkhZaRigCeAwvJg052dgU19WGsSFi9flCzuGcUEO1Qa3bB6V/fv2wPh7ZOuWrQgxn4hX7IJ3+pqyHJYpoJwg3/YgCDegXu6mKYObsBBkzKGkWM5oJIfobVHIA+QLcHGeMpMibZS2yBpvYtJIhYwRDDsML4tJt75bvPXHN/EfgRf0uFe9XtcwYus5dn5Y5O1L3xX0VqqR5QwdgEzw3ajYhBrOYSVBO2TTghG2aGq8FAzOS6lURJld7YQbOsTkDcO4vScQvOVxL/72QsEwpPA7A/QSilEUoSZVMZbx5wWqj95D+yQTlBpPFMDGeCOz6icoOdol0T1c0eTOdvoXL2PDvIxP2LzLTPFvVMh3sjcD7qvayRhuNCKYDq6M2IM3M9SF5gOZoUpp6GSGDHIhQSnSW1WCYIggQSs9Nq4vDbEcN6pY079a51LVbKt6euW1M690VMocy+82Q/BOzHxLTVKK6qCVHV9E4qe3MsalalP2VkWRk0FuzmcyxKqVdsJ39oUiLio8cRYWOEfLb3jvgzCMMyVqCmNGADQ6QGJE0lySoYH1MItFVa/GFl6qeYclg7w0Ow7usLiukaD+wT5IjGMMluw5r4EYxWrCjjOd8OYWDmzUtSsbbbM0WAGdCDbV0FKJmlPJZ9NCJP2AQgEdN05QGsX0WBM6eBtj+eKijmONxQuw6VEUJpAQGHJdFTrUTceBBCFdHwfjWu4RIRxwXbB2Y6cVN4zqGGmQPudjgOEC6xDnICAmAQqJtl0ul1Fsbt6ZciJjDU9AWLtimCCTyjRPhxZAOjwIv1l0AigDOD0QqqXtEHzn5gHsyGrl/rn8lYHOx30iOGQDbW52Bpfq0S0oSHmhwV0xRG6DZecDZAPsTUYoBQZi+5NsuauMk5sfERdqdTVi2hwLB0qE4I9CDcQu+8yfdQlHA26AdQu6l/0xUn85BaJGXVIHdDDf9Tz5H9x9LX1YcEw4AAAAAElFTkSuQmCC\";\n// let shark = \"iVBORw0KGgoAAAANSUhEUgAAAB4AAAAQCAIAAACOWFiFAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAANOSURBVDhPbVRdSFRBFL535t67q6JBFBVYCmHSj0FGUEFBT6EvPQQRtfmTa1YSEZZWVFSUaZha/qygxq6YURhG5ItBRA8RRGGIhmj/Jr2WrXd33Z3bNzP3XlfwY/WeOXPON9+cOTNqWmZOeOrz/cajzGKKpViWxZhSURNqOXf436wZZ3z8aWJSScKeHVsJIdHo3N+wOfpleuz79IexHwPdpzwejRIViCdYoa+JgDfY7FdVO43DsS1LYQlw20Ng+5a8Xdu28GxV0TSa6jVyVq9Ynp6OKZWINJXL44aiEPkBVMeWzJqmIkgSb16fm5+3AbyqSk7W9yIAwZpGNEpTU4wl6V43i8NSIBkfSScIRAb0HKsOdV4qBgtKBHWUwrDi8cRsNGZGYwj03whx1ZRqOjU0umlt5u78nH2l9wSVsvdQIwgz1qzj1OCdX1NClALSzNhc2IzMmrGwGTMjsZqW/kBdUUd9Uem1+6iqTomu0RSvsTQjDUnJJGbETC7I/Byh6sn6HhiMMTM69y8SDUei17ueB275ZEBXQ8mRK10QTijFDrJXLYNTnsrQwyowGYZnnppDJZJeIzRwoQiR6JoEY5FIrKnvRbvD6yoYHhl1z79g58bCI02oqByGpyado0OIcPqrgqGrZTgilgAzRDOG4gg5Ak4fSFiwbHtmZkY40L129CIFwS7RmLzrGEjR1qzz6evWm0KyDLLZ+CF9HBmD8fPXVKquSZcrY2FBBHhLoDkYZ0c1Av2v2mt9Tqk4YPjPBqsP7IQNovGJL7grXi+VQxec2smxN4cPIfgRKG559BIn5sxwuAZYsK32Z+86B997dB1dKL3uFZOqeaqsNm78wYsduK/4oSV6W8sx7UbbSwvA1zzwtq+t4mHgeHBo2GsY0mn/W7Qg3XdKfJe7Km8/QBq/ji6xDBYigk1lDY/f8IWdDRlUzCI4SQcJNpfJgaTBH5q15HS3dHbUFSeshCgcbgnvJeQY2D9GfHP8QTJ0ur+8bbDnDOYKxC3PyMqxXz7JshCuWLW11oemE+r4aZ443xO6W8aPA8T44FpqRNfxXnEBknpJdi6njsfj0d/feGISsCyeTW8Kf3r+fB2XTgdY1a64xJPOSuwD1JiQb5NnZdZ/qtBfTMJbfykAAAAASUVORK5CYII=\";\n// let fontDigits = \"iVBORw0KGgoAAAANSUhEUgAAAGQAAAAKCAYAAABCHPt+AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwQAADsEBuJFr7QAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMS41ZEdYUgAAAZBJREFUWEe1jgtuBCEMQ+cY3fsfdIpZjIxJ+FSqJU/Ic8jwvO9LQ9qroYhRnmkecWfkqtVMxqlV7tlJvjMUna/NA6RVXfXU0YEV9JBDzIa8acgaV9a5WrLaoDYOaVY5s1aZQUNexOwk3xmq91GbIZ6vjA+kC1nVfGxn/oBF7tk025zxClE1z3agWuZ7b/udo/nbHd34nDxo9QOoxPXoHPKMuyCyDpqU10zuQJ7T2TtV/h7m/bzIWYcsmk/esTU+fvnmB1CJwowcUs5d00702Z2mOtOkOSHzkC/u9gCyHVBUex79M2BHxmd6wOEPoIIn7p72m8jV4ZuEeZ6xiGdzBVeezXv1nH3GjswD1OvBD6Bojob62edaH+5snrJdj2qsZ5u77mzeq+fsM3ZkbaCypx6dUxGj9I7ORDu/IP/X9h2WR7vUqmi32nex9+o5+4wdeWySJeCekak11xnn9O0dZlEeMTXv7eZgn2HvFf75fHCGav89zjtOjU+qtnRQxFSrPMv+cof6r7vQbY5eGftzP+8vIcBdiIYxxU8AAAAASUVORK5CYII=\";\n// // yellow:\n// // let fontDigits = \"iVBORw0KGgoAAAANSUhEUgAAAEcAAAAKCAYAAADmdkOtAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAFVSURBVEhLtZOBjsMwCEPT/f8/d3FkkEOBtpP2pF4CjoGuuWOQ8xzncQyPlUxDjtuR+UzPfN15421Nbhedftf7opsYmwDkmHdNzq189KleaFsOSF4fp6tJlifWVx+e6G31IGrsMBfzHnd61IqzZR5QW1uuoKqxtlxv+3fxB38mCPQ6+eGGdR7FiqtaaoBDbJiHYQRfVfW07gS6a+hvPjxxHtNT2MzlGIMsB5hfW66R6hpbPvpUcxBL7qID1bkuQj71AuTtQYic3ZzXoAi/AgpVX9Hy20DTu60Czqee2Qtor6t71xXLl168C3s4H71W8sItdz8MdG4v6BC2gs4jpLM9nfsBWw0PqhfWoW2A7EXicHYmqwnYD3i+8yRzuJ7VUjpvRGvFA5XJiqvmDYWsHshqgqxf59Gema/qAzpvZNWa/1LztyrA/Y9yllM6vdJ+8Rj/8o4xxhf9/mhSgxnKogAAAABJRU5ErkJggg==\";\n// let fontImage;\n// let sharkImage;\n// A1lib.ImageDetect.imageDataFromBase64(\"iVBORw0KGgoAAAANSUhEUgAAAB0AAAAUCAYAAABxnDbHAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAVtSURBVEhLbVVLb9xUGD1+v+aRTNI2bZKmSdq0FFWqYIsQiD8DEmxYwKKbSrBEYgESC4TYgtRFoSxYQNRKCAkhIWil0Kql5NWSNDOZZDwztsf2mPNdz5C24kSOPfb1Pd8538Paa5cvFo7jwgwmkGUZ9ttNLC2fx9LSBYxxuLeNOGzCtF04lWk0pk9iMAjxaP0ODM1Aw0gRRT1YlgW3UkXunUZQqfO6BturotNto9dp46NPP+FuBXTbCZCmQ0VYDIfQ8wHazT0ctPcxzPmbf67nw3J89ULU2SVhxHcyZLmBJANydxqTcy/i2MIlnJhfwcnTKwjqDXQ7LWw/XMPmvT/Q3H6oBAiM5cWzV4cwwHeRZyks5CiyHLrpoladgKEbKAoSDLoYpBGSOIRdaSDPTbhBA5PH5xFMzmBiZg65EWDvMEHr0T00d7bRajaR9EIgDSkqxe0H64pUzxgxTzxMhmDx0kY2pNp2C53wUC3yaZXheoCmY/rUMmoT05g6cQIzs3OYaEwhjiKs/72Ou3/exe4/uwi7ES68/gZc18J0w8dULVD7jKGRpXj1pZdBQbx0SAwM01RZu7h4DqfnF5lLncoiGIZBm10UXJdEKboMKoq66Id9Gg+89d7bKkX+xCS++OAqbJP2JwnSKMTn3/7AFQX82SUlEVkaw+SVOezTigQ6I7BdB4M8R58BRL0OjDzj8wKd1h6ebN7H5l93sPvoIZ5sr+NNkr374RV4tboiFAhRP2xz8z4SiWgEcVaRMiDowxwOC8bWc9hGDsv2SZoh7PfQ78c4aD7B480NbG1sYffxFsy0gxkvwcdff6XInkeFFe3zyPOE9seju8KljUj5P6OiLEsUsSDqHaLd2mUx7OAgZHvsHWLnoIPAtTHHPM1OuPBsU7XJ87h18xZiFs4hyQ66MaI4Gj0h6KLmzCwWyc4GXrl0Dr5fJlyzXCSpjijpst9qODbZQMOz4ZDEsWy2VYghiy2MBrjy5TXavK3eu3HjO6z9uIpADxGzJnK6xxOurf7KpwWCubOsCzahOYo0YXMPkpgtQ0sSKfMuqo6Omu8iMHN4RsScdhH3Wmi122i12iiYf4GQffb+O1j7/htkEfubrhlsu2yQohezTkYomC6ZB1ptYaXobDzA5TOnYLFrqpUAnmOjl+QwqapSn0bFM+BpKft1iEE2hCvrqDzjUOnHA0QkiUlgsDi4BBoVJlx3/efbYzqqXCRpofbQRb7AcUyOBXDa5IrQ4aSShHf2d5nbfXT6A1iGiUbgKZs7YYyddogm2yUlgQwRQcpcRv8RStmScP6cCkaBva7VF18oMlrR2yrV6lThc8aatj1aBdSofqoesGh0NTJ7vZ7aXDaqsLV6VFmg3PX6T8+pK0hiMoVUzx8YZoOykKShLYcvk/giiQ2TVWk4PAwE/BDU6lWWd8KRdqC2kzJQZU8k7OUkzbH6293RnbIplTrmUKDRIZPWp8lAjSPNPr5QaDqjIYHB85hYDWNCApis+vDYKkfIkfLDwFhx8/f7o3tHZE9DiIW0/FHmVAvmV9TqlOPKsstC6D9ef4a4Gpios3/ZBKzIBJlEziBLwiMyx7bUHB5DyJRa5jGnI5wLtIgChVQGg8DQNfZVuYn0rrKaH4KpRoNTipUbd5Wtq3fGn6mySIQsp2ypjWeVCeHoWvC0UvFbXpARVfCBzEd5Uaw+T2Ix1vdN/LK2Wb48UufOLpNEKt3iYGfLMOgxxsTjvJaQ/UekolSGxNNn2cBk40oPH6Ekc2bOqLOs5YBRQQrEJddzlYD/A4kUKWcSC4j5EQjRmHhsczB/lv/lulBkYmcZUBmc9LmokkPujYe7PBOI7VKgArVO0/Av6onYq0XNu+EAAAAASUVORK5CYII=\").then(function (i) { TreasureTrailLogger.easyCasketFinderImage = i }, function (i) { console.log(\"Could not load the easy casket finder image.\") });\n// A1lib.ImageDetect.imageDataFromBase64(\"iVBORw0KGgoAAAANSUhEUgAAACMAAAAVCAIAAABDmMC+AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAY2SURBVEhLTVXNjxxHFa+u6uqv6Z6d/RhnZndG3l0vcWyBgw0IBBEScCK5ICGQcohPOURI/AmIIxcEN64IBIdIfAglUrAQiu3IIMeJ2ZCEWLublddr787szuzOV/d0dVdV86ueteQnTan6VdX7vY/fe2NF7QtKE6J1crj3/a8vN855q00/TdX2bv/Hr774o+svEk7VcXr7n4/+c+/gytXl1dXa+lrYOZr86a/bR51JGLm93jgInOX20vOrtVaz2j4/7/u26E06x8nqy78jpAhW1olWzI4WlNaM2fno9DvX6nlGKh4lmjw5mFLLPr9QqXHGHKaL4vOd4cPdYe80ubhR14psbfXTaV4LnatXW1+81PjmNza+dKWxuFgRcba5eXj/k95773f/cW+PEGKHNYsUNna00FLm2CxFDlYrJ8lUce5/vjP6aLN7oRGSRM07bmNl4YMPHp9uDU77uuK73/raei51vea0XzinJ2I0TB+892QU53udZL8rRhlRJldGLGrBdUa8kFKrIJaaDC+15is+9VyGI6XpcJQHAV1rVauR64dBb5ANRulXv9Jab9fmql7zuWqzWS2U7nVGuzvHOw+OOj3xsfdyf+vDSarDwCsK/e79WUxVC3huc71QyrYRXJEcPPzpD16QQtVqzGbkdKImiXrth5e++1KbcG+/m01icb5V8x270Hpn+7jTnaTDGLbCl34GTVCb/9svXg99djKWqaK/fvNfZ0WCaGUb/6md5zk3YOTwJGvU2P5htjTPqi5bDP14LIYnk6hSNHyb+N74NN5+PO4NxMP94cHh+Htv/MqvzhlbpcCzqZBRxfXOFETmkjELMdE8y/AdBAF3XWwUYUVBVprOyVAkQi3O8WmSoQbjk3jrf0ebHx7eubN/+86Tzc2j7tH0+i/ffhYG4nscMp7KwWQ609iAoQiHUu44SF2hlZQKB45Nun0hc9V8LogT9agTf7rdv/1+5+a97p2PTv/9yeCz3XicyIIQj1MYnZmbya2bt9JMDScC5RzG6ZmWMiyaWFb1/EWERZktpYRKdPZeuba8WLMd116IHG6xg/7Y4/bC/LwfVMqnxGEknkqp9U9+c6P75DE0b7319vDuH4XiQoBxhnK/vfFfFKnS2mCMGsta0fItQT0Zeqr0MU7z44Ecx/JkrAZTda4eXX6+urTALUtLE7k8Hkx7o2SamRwA4w8/v/743d/3hlkicphMctWPTUUgBe5LiYRprUxM+AAxRCZdl4/2dr59uY5LFY9XQi8TZC5il9cqc1HQPSEgglTKd1nku5nSMJ2meSrAK4LqCk0ySf5889MZSqW1VqgCXFfINWYEDSKFRBCLUYquykcn7XolzfBSU4st1Xiek71O2h+oJNWBT+dC16JkksreMImnAjkBsUSmlCpSSf9yCzAwTCrtLyBPBtGykC3orGDlQp4JbnPLBs8ZshPv73x5tcptN/K573m+Sxhl1Tl/LnAxFFBzkyUkxJgh1BQXBSdv3nxQKspQCgwyjjiMvzIDmOlcZC+dphgYNndknsMR0L0EMzmErC3zaxve2op/NFJ3P8tGMQlcZpeMyrIsVeSdu7vlxaehKANuMTCa5QIw5SHqxOttEB2cB3IuBHhvoqX0KZjAtVrkVgK/9N6IS9Dp5uud+49KxRlGuTcCMCCVO1Mns0Gdwnozl9JxOPzjjksZU1mGxPKwtr9/sLxURUUzbSO7ruPo8lkmMnj2dwNzhhHVGxITAKeFhq9mgyEgpYWNyRwmRW75zXUOGKnhCFgOFQ7Q00obK2ivaxv10CFXLkZ5QR4eQkduPE0XMFyHg8Ko7jNxSGKVG7M3MTFK0LKGERhNZrDjnJ+RAiMEV4ye2SaNG3VwLPT57Y8PZgbw81YuYDSjMYTIzfAsZQY2K1UpsFNGiToBCQcolSrOwpxFNlthApREk83ezTDcxipWXICz8AZ7JMDzvdk8e1bgrEHCAMoEs4Iqmg6looYLNv4cwUmsaBDYMqvN7OpCPurjJTC8+TpOMU5M6ikzDMJLxlA8rFCaSoPADJMapkzNJDoCe6fewowrLZpRNEv3LIelWwR/xzhCn7NZhsBvM46NEi0BmLLANoLDinOYPXtedgLqgIAIIf8Hxu+VpsmgWFoAAAAASUVORK5CYII=\").then(function (i) { TreasureTrailLogger.eliteCasketFinderImage = i }, function (i) { console.log(\"Could not load the elite casket finder image.\") });\n// A1lib.ImageDetect.imageDataFromBase64(ectoplasmator).then(function (i) { TreasureTrailLogger.ectoImg = i }, function (i) { console.log(\"Could not load the ectoplasmator image.\") });\n// A1lib.ImageDetect.imageDataFromBase64(shark).then(function (i) { TreasureTrailLogger.shark = i }, function (i) { console.log(\"Could not load the shark image.\") });\n// A1lib.ImageDetect.imageDataFromBase64(fontDigits).then(function (i) { TreasureTrailLogger.fontDigits = i }, function (i) { console.log(\"Could not load the font digits image.\") });\n// A1lib.ImageDetect.imageDataFromBase64(fontDigits).then(function (i) { fontImage = i }, function (i) { console.log(\"Could not load the font digits image.\") });\n// A1lib.ImageDetect.imageDataFromBase64(shark).then(function (i) { sharkImage = i }, function (i) { console.log(\"Could not load the shark image.\") });\n// // let font = OCR.generatefont(fontImage, \"0123456789m()\", \"\", {}, 7, 4, 0.9, true);\n// // Inventory spot dimensions: 38x34\n// function TreasureTrailLogger() {\n// \tvar me = this;\n// \tthis.findShark = function () {\n// \t\tlet screenImage = A1lib.captureHoldFullRs();\n// \t\tlet position = screenImage.findSubimage(TreasureTrailLogger.shark);\n// \t\tconsole.log(\"shark position\");\n// \t\tconsole.log(position);\n// \t\tconsole.log(\"---\");\n// \t\treturn position;\n// \t}\n// \tthis.testing = function () {\n// \t\tlet screenImage = A1lib.captureHoldFullRs();\n// \t\tlet position = screenImage.findSubimage(TreasureTrailLogger.ectoImg);\n// \t\tconsole.log(\"ecto position\");\n// \t\tconsole.log(position);\n// \t\tconsole.log(\"@@@\");\n// \t\treturn 0;\n// \t}\n// \tthis.findEasyCaskets = function () {\n// \t\tlet screenImage = A1lib.captureHoldFullRs();\n// \t\tlet position = screenImage.findSubimage(TreasureTrailLogger.easyCasketFinderImage);\n// \t\tconsole.log(\"easy position\");\n// \t\tconsole.log(position);\n// \t\tconsole.log(\"===\");\n// \t\treturn 0;\n// \t}\n// \tthis.findEliteCaskets = function () {\n// \t\tlet screenImage = A1lib.captureHoldFullRs();\n// \t\tlet position = screenImage.findSubimage(TreasureTrailLogger.eliteCasketFinderImage);\n// \t\tconsole.log(\"elite position\");\n// \t\tconsole.log(position);\n// \t\tconsole.log(\"###\");\n// \t\treturn 0;\n// \t}\n// }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9pbmRleC50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBb0M7QUFDcEMsbUJBQU8sQ0FBQywySEFBNkM7QUFDckQsbUJBQU8sQ0FBQyxtSUFBaUQ7QUFDekQsYUFBYSxpRUFBK0I7QUFDNUMsZ0JBQWdCLG1CQUFPLENBQUMsb0VBQStCO0FBQ3ZELENBQUM7QUFDTTtBQUNQLDBCQUEwQix5REFBdUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksK0NBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Z0VBQTZnRSwrQ0FBK0MsaUJBQWlCLDZEQUE2RDtBQUMxb0UseXhFQUF5eEUsZ0RBQWdELGlCQUFpQiw4REFBOEQ7QUFDeDVFLDRFQUE0RSxpQ0FBaUMsaUJBQWlCLHdEQUF3RDtBQUN0TCxvRUFBb0UsK0JBQStCLGlCQUFpQixnREFBZ0Q7QUFDcEsseUVBQXlFLG9DQUFvQyxpQkFBaUIsc0RBQXNEO0FBQ3BMLHlFQUF5RSxlQUFlLGlCQUFpQixzREFBc0Q7QUFDL0osb0VBQW9FLGdCQUFnQixpQkFBaUIsZ0RBQWdEO0FBQ3JKLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9URVNULy4vaW5kZXgudHM/MDY4YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBMWxpYiBmcm9tIFwiQGFsdDEvYmFzZVwiO1xucmVxdWlyZShcIiFmaWxlLWxvYWRlcj9uYW1lPVtuYW1lXS5bZXh0XSEuL2luZGV4Lmh0bWxcIik7XG5yZXF1aXJlKFwiIWZpbGUtbG9hZGVyP25hbWU9W25hbWVdLltleHRdIS4vYXBwY29uZmlnLmpzb25cIik7XG52YXIgaW1hZ2VzID0gQTFsaWIuSW1hZ2VEZXRlY3Qud2VicGFja0ltYWdlcyh7XG4gICAgZWFzeUNhc2tldDogcmVxdWlyZShcIi4vaW1hZ2VzL2Vhc3lfY2Fza2V0LmRhdGEucG5nXCIpXG59KTtcbmV4cG9ydCBmdW5jdGlvbiB0ZXN0aW5nKCkge1xuICAgIHZhciBmdWxsU2NyZWVuSW1hZ2UgPSBBMWxpYi5jYXB0dXJlSG9sZEZ1bGxScygpO1xuICAgIHZhciBwb3NpdGlvbiA9IGZ1bGxTY3JlZW5JbWFnZS5maW5kU3ViaW1hZ2UoaW1hZ2VzLmVhc3lDYXNrZXQpO1xuICAgIGNvbnNvbGUubG9nKFwiUE9TSVRJT046XCIpO1xuICAgIGNvbnNvbGUubG9nKHBvc2l0aW9uKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzaG93U3ViSW1hZ2UoeCwgeSwgdywgaCkge1xuICAgIEExbGliLmNhcHR1cmUoeCwgeSwgdywgaCkuc2hvdygpO1xufVxuaWYgKHdpbmRvdy5hbHQxKSB7XG4gICAgYWx0MS5pZGVudGlmeUFwcFVybChcIi4vYXBwY29uZmlnLmpzb25cIik7XG59XG4vLyBcInVzZSBzdHJpY3RcIjtcbi8vIEExbGliLmlkZW50aWZ5QXBwKFwiYXBwY29uZmlnLmpzb25cIik7XG4vLyBsZXQgZWN0b3BsYXNtYXRvciA9IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNjQUFBQWtDQVlBQUFBS055T2JBQUFBQVhOU1IwSUFyczRjNlFBQUFBUm5RVTFCQUFDeGp3djhZUVVBQUFBSmNFaFpjd0FBRHNNQUFBN0RBY2R2cUdRQUFBc2RTVVJCVkZoSGZWaGJiQnhYR2Y1blptZG1iN1pqT3hlbnNXUEhYZE5jU05RZ2tVUUpDbEdJR2xKUXBRS3ZQQ0NrSWlDaEwvRENBOHBUbnlxaEtHblRGaWxDcUVJQ2liWmNYaWhWVmFHVVFLcEtWUWlsU1JOaXg3bVlKTDd0MnV2ZG1ka2R2dTgvYzladUxuelc4Wms1Yzg1Ly92UGZ6enFsOVNOcG1zU1N0RVM2ZXZ1a05qc2pZUkJLTzRsRUhFOWN6NU9jSjdLNDFCU2lWQWdsd1BjNjNqbCtQOXljTDFFejF1ZDJxNFc1bnE1dHR4THBLbmVMbTgvTFlyVXFQdWcybzZidVpYdWlFVFVrQ0FOSlcyMXh5dXVHVTk5enhITWR3YnNFdmk4eENLWHRWQ2NUbkF6cTB1SUN4d1VESHBqSGFZQ2tGV090cTJ0ejJKQm9wVzN4UWNlc2FXR05oM2t0ZkhmUUw5UGxmTklpTEQxeFFCTlQydTFFbk43SFJ0SjZzNkVFQ0JJakFwd3dhalRFeXpiMFFDUnFRcHA4enNiUzFEQWNCTDcybnVkS0hKdjF2dStKNDVvMWZPYTRYV2YzY0NBUWw0ZDFlY2kyQ29SekNxQzN1QlNCOFZ4T0Nlc0NjQjJFdm03aU9IamhLa2toaVZUYTRrcFlLS2dVK2M2Tk9lWjRPYW5mdVMxK21OY3hydUU4TnhkSUZDZjZIRk5hR1MwZVVwL1JpcVd5dExGUENnWTk4S0cwS1dreWduRm56Y1pLT3Jld29LcHBaOUlqRVRMZHhrbW9paVpPNytBN3g0Z2tTVURiMGUvUjNWc1lnVTdCcUlYZlB5QWhOaUxqT2JRWWRzVHZiYWliYXdsTG4zUUlNdGVFcHZqV1d5NUpNOGFlNjRZcjZjeENYU2ZraTBWcFlYR0xVb0pvU1lndGJjT0dBdGdkWUJsc2dGQVk1S1EyZVUxZWZPRm5Pa2I4K0tmSDhYK1pVY0pmczBIWGt4YlhzK2ZhQkhiV1VnRlFlM1NlSEk4Z3VkU1JXcjBoYmp0VEVSbExFbnlBMTZTWlRkQmJRei9YWVN5R1Y2Vndsc1lTVGdoSjBnbFdZdnpZUCtSbzdVakdiRnVlZmVZYlVxbU1TWHozcGpKbG16cFFDcHYwQW5OWWlJdnFKbTJhR0cwMFh5cUpTNm5rOElFU2c0alF4OWlZcW15S24rTTVJQVhNNGNrS3NKOElwK1YzZUlONnJnVVpXNGtYWDZBRVJiWnYzYTRNVmljKzFmbmNuQUlSZURtc1RlbXlrVWtJVVJ2ZitSMWhEQjRXUmFwS2lwaEdUSy9KK1lFczFaZFVCZlhiRTlLY3VxNWhJQmNXc0tXajN6M1lvOFhJeWQzWjB6TDI3Zm04OW50MzdkTis4Y1lWcGFkaENnYXZhZ1lkQzNVV3dFZWZnd0J3ZEVmVmxpSW01YWhDQkZFL0RDV0pLVUVYVEUzSTRVT0hzYVF0OVp2L2tjV0pTMHFBYUdTQmVmSm1UU1p2MUdCd214OWdrZ3orNnRlL3hGTXFQWnMyNnhqcHN4R1FqZVFSdG1LRU0wcU1nb3FoblJyOEFONzZlRnB0SnRDY01Yb1ZNVTVqQStiaTVKV0hHbnpQcGlkay90b3lvOFRSN3oyUGVCYkpXR1hOWjlSOGR1OXQrZWlmRjZUNDJJZ0tvSWtNa2kvazFYYUpOZ1ZEVTRFMHFZenVmQ0RUMVRwc0RuYkc3R0NOM21JSjNrTEdqaHorbXI3YnpXaExOSFF5ZHJSMitEUHQxS3NuZE03bEszY3BxQTQyYmFyZ1B5Ui9heHo3RzFOb0xOVjEzeEJ4MWMzQ0ZNMktvT1FDY09tR3NDSHFubzN3R0JUaE5YUVNvZ1F2dG95eFAvZkJ4L0xtSDk3UTkvdEJCbDg5YzFybTUyZGw1SlJScjFYenM4OThTdzRkT0NUejQ1OHFRNUNKTXFOU2hGcVJQN1RYMkFqTk1YQ3J1OUZqZVFvTFR2QVI1eDZHNlpsNzJwT1JSNEVwaWJDTVdjZkFCKzNvdWJTNXJ1NXU3SVc4eTd5S1ZKZ2lueElzTnBoYlhVcU1rbWFzUytDcFRFMTBoazZDUnNkTmJGdXBya2Zodi9lbXNxZi9qd2FNbnpFUDNFQnFqQUtpV1lMVkRLTUNpZ0lrWHVYZXBoV0t2SzMyVnFtTVF2UlpRTTd3OWEvdWx5ZTM3NUJUWFgvT1JwYkJzWU1IRHNyVFQzMUpUY0Nhdy9rUEw4bmdoaUhadGlXVFlBWWJpUktrdHdUeE5VSTV3aUxDaDlPVXUxQmUwZk5jY0U2R2lBaFpJSTlnUyt6ZmUxRDcrMkhaWGNtZ2ZjN0lQSUNUcDAvSWlaZCtqcWRVd2dGNGJXYlR0RzlHQ25wdWtEUDVtcEc0M1Z3UVozQnNXM3BuYmg1TGpNZkdVQ21aWlh6N3pyZS9xOTQxT3plamRtTWxRYncrZEU3N3ViazU3WG5JWThkK0lzM0ZCZmtjUW9rRnBVYjg5bmUvd2Y5VVNrTmphalk1VkRGcGJPSmtESzJ4L21QTWE4SCsrcEQ0RjFDTU9NT2JkNlMzN3Q1RFRrVW9nYjJobk1SMGVDeE9FOTJaMU1VL2VPNllqSTcwZHBpemhyNFNyNXg1WFk0YythYXNYck5PYm81ZjdURDQxcC9lMC83czMvNksvNmwwRDQ5bEhzb01aSEkweDFrcDUvTU16STcwb0k5Zzg5NnExUVBIRzNRS09nVDByallISmluRm9LZFA0dXEwZlBEaGVSbDdmSWRzdWx5UlZlY0h1WmVDek03dHZxbnRVUHkwekM4ZzFkVVhaUUQyRmJoR0twOWNIa2VBZFdYOCtyaStTNkVib1lLeERmVWE5cVJLdVdkTHd4ZGlIU1JYTGhTaGthb0pKZFlaL0t5T1o4Q2tMYkJSRGNIYUlYbnB0WlB5L3Q4dmFuc1VodGNiVzcwZjc1MTlOM3RDUVFGem9mb1lEUktvbFl3U3pCak5LTkc2amxtcVdBckYyZmpFOW5ScVpsYmRtWnl6Y2pETTRrVCtjdjZyVGx5Ukh6NzNJN2sxZFVQSE9ySHJJWmk0dmFUcUxlV3EyWWlCU1gyRVNYL001MVF4YXp1YVVST2hqUGVPOWYzOVVrVnU5VmIxcjFXMXVnaThHdWNnTFZNS0lYMndZb0NLV2VIRTFSblp2V3VQZEpXNjlSWjFmWElLaDhqSjlHeGQ1dVliY3U5ZVRmcjdTcnIxcWk1Y2t0cGhwMWtWUC9XVkE2QlhrS3ZYcmtwekRuYmUzYSsxRzBFbUhRb0h6ejNsb3N6WDRCQWpXM2VtVTlNenZFem9KSnY0Q1hxVkJWTU9wVWNjL2Y3emNncWhZU1hvTkFRZGg3RFNJMVpLOE8xM3pzbmI3LzRGVHlha1VKMDBueGlDb1owbkNHVnJlM3RsNnM1ZFkzT3NDaWhpMm9BRkdhT29hUk1xY29wL1lCaGYwb3d4cG9ybDlqSnM4dFp0bzNJeVJ2enI0Z1h0cjE2YjdyVEJRZEl3SU8wWVJlMVNvd21obUFESkRLYzNzR0pCbk5GdE85TWI0Skp4anVvMDFZSEp0WnFFRVN4SkFLNmxETlAxdVRpSEtwbjFuQWtGVUFzTWZXVnBSWnoveUhqb3JpZEg1STNmdnlNZlg3cW9YbWhnNmp0VE5wa3JJVzJkcGRQNi9qNUlibHE4dm9IQjR3dHdmMjV1bHBncUdPTFNqWG52REZrTVJnZ3o4SXcyVGtoWmFSaWdDZUF3dkpnMDUyZGdVMTlXR3NTRmk5ZmxDenVHY1VFTzFRYTNiQjZWL2Z2MndQaDdaT3VXclFneG40aFg3SUozK3BxeUhKWXBvSndnMy9ZZ0NEZWdYdTZtS1lPYnNCQmt6S0drV001b0pJZm9iVkhJQStRTGNIR2VNcE1pYlpTMnlCcHZZdEpJaFl3UkREc01MNHRKdDc1YnZQWEhOL0VmZ1JmMHVGZTlYdGN3WXVzNWRuNVk1TzFMM3hYMFZxcVI1UXdkZ0V6dzNhalloQnJPWVNWQk8yVFRnaEcyYUdxOEZBek9TNmxVUkpsZDdZUWJPc1RrRGNPNHZTY1F2T1Z4TC83MlFzRXdwUEE3QS9RU2lsRVVvU1pWTVpieDV3V3FqOTVEK3lRVGxCcFBGTURHZUNPejZpY29PZG9sMFQxYzBlVE9kdm9YTDJQRHZJeFAyTHpMVFBGdlZNaDNzamNEN3F2YXlSaHVOQ0tZRHE2TTJJTTNNOVNGNWdPWm9VcHA2R1NHREhJaFFTblNXMVdDWUlnZ1FTczlOcTR2RGJFY042cFkwNzlhNTFMVmJLdDZldVcxTTY5MFZNb2N5KzgyUS9CT3pIeExUVktLNnFDVkhWOUU0cWUzTXNhbGFsUDJWa1dSazBGdXptY3l4S3FWZHNKMzlvVWlMaW84Y1JZV09FZkxiM2p2Z3pDTU15VnFDbU5HQURRNlFHSkUwbHlTb1lIMU1JdEZWYS9HRmw2cWVZY2xnN3cwT3c3dXNMaXVrYUQrd1Q1SWpHTU1sdXc1cjRFWXhXckNqak9kOE9ZV0RtelV0U3NiYmJNMFdBR2RDRGJWMEZLSm1sUEpaOU5DSlAyQVFnRWROMDVRR3NYMFdCTTZlQnRqK2VLaWptT054UXV3NlZFVUpwQVFHSEpkRlRyVVRjZUJCQ0ZkSHdmald1NFJJUnh3WGJCMlk2Y1ZONHpxR0dtUVB1ZGpnT0VDNnhEbklDQW1BUXFKdGwwdWwxRnNidDZaY2lKakRVOUFXTHRpbUNDVHlqUlBoeFpBT2p3SXYxbDBBaWdET0QwUXFxWHRFSHpuNWdIc3lHcmwvcm44bFlIT3gzMGlPR1FEYlc1MkJwZnEwUzBvU0htaHdWMHhSRzZEWmVjRFpBUHNUVVlvQlFaaSs1TnN1YXVNazVzZkVSZHFkVFZpMmh3TEIwcUU0STlDRGNRdSs4eWZkUWxIQTI2QWRRdTZsLzB4VW44NUJhSkdYVklIZEREZjlUejVIOXg5TFgxWWNFdzRBQUFBQUVsRlRrU3VRbUNDXCI7XG4vLyBsZXQgc2hhcmsgPSBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCNEFBQUFRQ0FJQUFBQ09XRmlGQUFBQUFYTlNSMElBcnM0YzZRQUFBQVJuUVUxQkFBQ3hqd3Y4WVFVQUFBQUpjRWhaY3dBQURzTUFBQTdEQWNkdnFHUUFBQU5PU1VSQlZEaFBiVlJkU0ZSQkZMNTM1dDY3cTZKQkZCVllDbUhTajBGR1VFRkJUNkV2UFFRUnRmbVRhMVlTRVpaV1ZGU1VhWmhhL3F5Z3hxNllVUmhHNUl0QlJBOFJSR0dJaG1qL0pyMldyWGQzM1ozYk56UDNYbGZ3WS9XZU9YUE9OOStjT1ROcVdtWk9lT3J6L2NhanpHS0twVmlXeFpoU1VSTnFPWGY0MzZ3WlozejhhV0pTU2NLZUhWc0pJZEhvM04rd09mcGxldXo3OUlleEh3UGRwendlalJJVmlDZFlvYStKZ0RmWTdGZFZPNDNEc1MxTFlRbHcyME5nKzVhOFhkdTI4R3hWMFRTYTZqVnlWcTlZbnA2T0taV0lOSlhMNDRhaUVQa0JWTWVXekpxbUlrZ1NiMTZmbTUrM0FieXFTazdXOXlJQXdacEdORXBUVTR3bDZWNDNpOE5TSUJrZlNTY0lSQWIwSEtzT2RWNHFCZ3RLQkhXVXdyRGk4Y1JzTkdaR1l3ajAzd2h4MVpScU9qVTB1bWx0NXU3OG5IMmw5d1NWc3ZkUUl3Z3oxcXpqMU9DZFgxTkNsQUxTek5oYzJJek1tckd3R1RNanNacVcva0JkVVVkOVVlbTErNmlxVG9tdTBSU3ZzVFFqRFVuSkpHYkVUQzdJL0J5aDZzbjZIaGlNTVRNNjl5OFNEVWVpMTd1ZUIyNzVaRUJYUThtUksxMFFUaWpGRHJKWExZTlRuc3JRd3lvd0dZWm5ucHBESlpKZUl6UndvUWlSNkpvRVk1RklyS252UmJ2RDZ5b1lIaGwxejc5ZzU4YkNJMDJvcUJ5R3B5YWRvME9JY1BxcmdxR3JaVGdpbGdBelJET0c0Z2c1QWs0ZlNGaXdiSHRtWmtZNDBMMTI5Q0lGd1M3Um1MenJHRWpSMXF6ejZldldtMEt5RExMWitDRjlIQm1EOGZQWFZLcXVTWmNyWTJGQkJIaExvRGtZWjBjMUF2MnYybXQ5VHFrNFlQalBCcXNQN0lRTm92R0pMN2dyWGkrVlF4ZWMyc214TjRjUElmZ1JLRzU1OUJJbjVzeHd1QVpZc0szMlorODZCOTk3ZEIxZEtMM3VGWk9xZWFxc05tNzh3WXNkdUsvNG9TVjZXOHN4N1ViYlN3dkExenp3dHErdDRtSGdlSEJvMkdzWTBtbi9XN1FnM1hkS2ZKZTdLbTgvUUJxL2ppNnhEQllpZ2sxbERZL2Y4SVdkRFJsVXpDSTRTUWNKTnBmSmdhVEJINXExNUhTM2RIYlVGU2VzaENnY2JnbnZKZVFZMkQ5R2ZIUDhRVEowdXIrOGJiRG5ET1lLeEMzUHlNcXhYejdKc2hDdVdMVzExb2VtRStyNGFaNDQzeE82VzhhUEE4VDQ0RnBxUk5meFhuRUJrbnBKZGk2bmpzZmowZC9mZUdJU3NDeWVUVzhLZjNyK2ZCMlhUZ2RZMWE2NHhKUE9TdXdEMUppUWI1Tm5aZFovcXRCZlRNSmJmeWtBQUFBQVNVVk9SSzVDWUlJPVwiO1xuLy8gbGV0IGZvbnREaWdpdHMgPSBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFHUUFBQUFLQ0FZQUFBQkNIUHQrQUFBQUJHZEJUVUVBQUxHUEMveGhCUUFBQUFsd1NGbHpBQUFPd1FBQURzRUJ1SkZyN1FBQUFCaDBSVmgwVTI5bWRIZGhjbVVBY0dGcGJuUXVibVYwSURRdU1TNDFaRWRZVWdBQUFaQkpSRUZVV0VlMWpndHVCQ0VNUStjWTNmc2ZkSXBaakl4SitGU3FKVS9JYzhqd3ZPOUxROXFyb1loUm5ta2VjV2ZrcXRWTXhxbFY3dGxKdmpNVW5hL05BNlJWWGZYVTBZRVY5SkJEeklhOGFjZ2FWOWE1V3JMYW9EWU9hVlk1czFhWlFVTmV4T3drM3htcTkxR2JJWjZ2akEra0MxblZmR3huL29CRjd0azAyNXp4Q2xFMXozYWdXdVo3Yi91ZG8vbmJIZDM0bkR4bzlRT294UFhvSFBLTXV5Q3lEcHFVMTB6dVFKN1QyVHRWL2g3bS9ieklXWWNzbWsvZXNUVStmdm5tQjFDSndvd2NVczVkMDA3MDJaMm1PdE9rT1NIemtDL3U5Z0N5SFZCVWV4NzlNMkJIeG1kNndPRVBvSUluN3A3Mm04alY0WnVFZVo2eGlHZHpCVmVlelh2MW5IM0dqc3dEMU92QkQ2Qm9qb2I2MmVkYUgrNXNuckpkajJxc1o1dTc3bXplcStmc00zWmtiYUN5cHg2ZFV4R2o5STdPUkR1L0lQL1g5aDJXUjd2VXFtaTMybmV4OStvNSs0d2RlV3lTSmVDZWthazExeG5uOU8wZFpsRWVNVFh2N2VaZ24ySHZGZjc1ZkhDR2F2ODl6anRPalUrcXRuUlF4RlNyUE12K2NvZjZyN3ZRYlk1ZUdmdHpQKzh2SWNCZGlJWXh4VThBQUFBQVNVVk9SSzVDWUlJPVwiO1xuLy8gLy8geWVsbG93OlxuLy8gLy8gbGV0IGZvbnREaWdpdHMgPSBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFFY0FBQUFLQ0FZQUFBRG1ka090QUFBQUFYTlNSMElBcnM0YzZRQUFBQVJuUVUxQkFBQ3hqd3Y4WVFVQUFBQUpjRWhaY3dBQURzTUFBQTdEQWNkdnFHUUFBQUZWU1VSQlZFaEx0Wk9CanNNd0NFUFQvZjgvZDNGa2tFT0J0cFAycEY0Q2pvR3V1V09ROHh6bmNReVBsVXhEanR1UitVelBmTjE1NDIxTmJoZWRmdGY3b3BzWW13RGttSGROenExODlLbGVhRnNPU0Y0ZnA2dEpsaWZXVngrZTZHMzFJR3JzTUJmekhuZDYxSXF6WlI1UVcxdXVvS3F4dGx4diszZnhCMzhtQ1BRNitlR0dkUjdGaXF0YWFvQkRiSmlIWVFSZlZmVzA3Z1M2YStodlBqeHhIdE5UMk16bEdJTXNCNWhmVzY2UjZocGJQdnBVY3hCTDdxSUQxYmt1UWo3MUF1VHRRWWljM1p6WG9BaS9BZ3BWWDlIeTIwRFR1NjBDenFlZTJRdG9yNnQ3MXhYTGwxNjhDM3M0SDcxVzhzSXRkejhNZEc0djZCQzJnczRqcExNOW5mc0JXdzBQcWhmV29XMkE3RVhpY0hZbXF3bllEM2krOHlSenVKN1ZVanB2Ukd2RkE1WEppcXZtRFlXc0hzaHFncXhmNTlHZW1hL3FBenB2Wk5XYS8xTHp0eXJBL1k5eWxsTTZ2ZEorOFJqLzhvNHh4aGY5L21oU2d4bktvZ0FBQUFCSlJVNUVya0pnZ2c9PVwiO1xuLy8gbGV0IGZvbnRJbWFnZTtcbi8vIGxldCBzaGFya0ltYWdlO1xuLy8gQTFsaWIuSW1hZ2VEZXRlY3QuaW1hZ2VEYXRhRnJvbUJhc2U2NChcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCMEFBQUFVQ0FZQUFBQnhuRGJIQUFBQUFYTlNSMElBcnM0YzZRQUFBQVJuUVUxQkFBQ3hqd3Y4WVFVQUFBQUpjRWhaY3dBQURzTUFBQTdEQWNkdnFHUUFBQVZ0U1VSQlZFaExiVlZMYjl4VUdEMSt2K2FSVE5JMmJaS21TZHEwRkZXcVlJc1FpRDhERW14WXdLS2JTckJFWWdFU0M0VFlndFJGb1N4WVFOUktDQWtoSVdpbDBLcWw1TldTTkRPWlpEd3p0c2YybVBOZHo1QzI0a1NPUGZiMVBkODUzOFBhYTVjdkZvN2p3Z3dta0dVWjl0dE5MQzJmeDlMU0JZeHh1TGVOT0d6Q3RGMDRsV2swcGs5aU1BanhhUDBPRE0xQXcwZ1JSVDFZbGdXM1VrWHVuVVpRcWZPNkJ0dXJvdE50bzlkcDQ2TlBQK0Z1QlhUYkNaQ21RMFZZRElmUTh3SGF6VDBjdFBjeHpQbWJmNjdudzNKODlVTFUyU1ZoeEhjeVpMbUJKQU55ZHhxVGN5L2kyTUlsbkpoZndjblRLd2pxRFhRN0xXdy9YTVBtdlQvUTNINm9CQWlNNWNXelY0Y3d3SGVSWnlrczVDaXlITHJwb2xhZGdLRWJLQW9TRExvWXBCR1NPSVJkYVNEUFRiaEJBNVBINXhGTXptQmlaZzY1RVdEdk1FSHIwVDAwZDdiUmFqYVI5RUlnRFNrcXhlMEg2NHBVenhneFR6eE1obUR4MGtZMnBOcDJDNTN3VUMzeWFaWGhlb0NtWS9yVU1tb1QwNWc2Y1FJenMzT1lhRXdoamlLcy83Mk91My9leGU0L3V3aTdFUzY4L2daYzE4SjB3OGRVTFZEN2pLR1JwWGoxcFpkQlFieDBTQXdNMDFSWnU3aDREcWZuRjVsTG5jb2lHSVpCbTEwVVhKZEVLYm9NS29xNjZJZDlHZys4OWQ3YktrWCt4Q1MrK09BcWJKUDJKd25TS01UbjMvN0FGUVg4MlNVbEVWa2F3K1NWT2V6VGlnUTZJN0JkQjRNOFI1OEJSTDBPakR6ajh3S2QxaDZlYk43SDVsOTNzUHZvSVo1c3IrTk5rcjM3NFJWNHRib2lGQWhSUDJ4ejh6NFNpV2dFY1ZhUk1pRG93eHdPQzhiV2M5aEdEc3YyU1pvaDdQZlE3OGM0YUQ3QjQ4ME5iRzFzWWZmeEZzeTBneGt2d2NkZmY2WElua2VGRmUzenlQT0U5c2VqdThLbGpVajVQNk9pTEVzVXNTRHFIYUxkMm1VeDdPQWdaSHZzSFdMbm9JUEF0VEhIUE0xT3VQQnNVN1hKODdoMTh4WmlGczRoeVE2Nk1hSTRHajBoNktMbXpDd1d5YzRHWHJsMERyNWZKbHl6WENTcGppanBzdDlxT0RiWlFNT3o0WkRFc1d5MlZZZ2hpeTJNQnJqeTVUWGF2SzNldTNIak82ejl1SXBBRHhHekpuSzZ4eE91cmY3S3B3V0N1Yk9zQ3phaE9ZbzBZWE1Qa3BndFEwc1NLZk11cW82T211OGlNSE40UnNTY2RoSDNXbWkxMjJpMTJpaVlmNEdRZmZiK08xajcvaHRrRWZ1YnJobHN1MnlRb2hlelRrWW9tQzZaQjFwdFlhWG9iRHpBNVRPbllMRnJxcFVBbm1PamwrUXdxYXBTbjBiRk0rQnBLZnQxaUVFMmhDdnJxRHpqVU9uSEEwUWtpVWxnc0RpNEJCb1ZKbHgzL2VmYll6cXFYQ1Jwb2ZiUVJiN0FjVXlPQlhEYTVJclE0YVNTaEhmMmQ1bmJmWFQ2QTFpR2lVYmdLWnM3WVl5ZGRvZ20yeVVsZ1F3UlFjcGNSdjhSU3RtU2NQNmNDa2FCdmE3VkYxOG9NbHJSMnlyVjZsVGhjOGFhdGoxYUJkU29mcW9lc0doME5USjd2WjdhWERhcXNMVjZWRm1nM1BYNlQ4K3BLMGhpTW9WVXp4OFlab095a0tTaExZY3ZrL2dpaVEyVFZXazRQQXdFL0JEVTZsV1dkOEtSZHFDMmt6SlFaVThrN09Va3piSDYyOTNSbmJJcGxUcm1VS0RSSVpQV3A4bEFqU1BOUHI1UWFEcWpJWUhCODVoWURXTkNBcGlzK3ZEWUtrZklrZkxEd0ZoeDgvZjdvM3RIWkU5RGlJVzAvRkhtVkF2bVY5VHFsT1BLc3N0QzZEOWVmNGE0R3Bpb3MzL1pCS3pJQkpsRXppQkx3aU15eDdiVUhCNUR5SlJhNWpHbkk1d0x0SWdDaFZRR2c4RFFOZlpWdVluMHJyS2FINEtwUm9OVGlwVWJkNVd0cTNmR242bXlTSVFzcDJ5cGpXZVZDZUhvV3ZDMFV2RmJYcEFSVmZDQnpFZDVVYXcrVDJJeDF2ZE4vTEsyV2I0OFV1Zk9McE5FS3QzaVlHZkxNT2d4eHNUanZKYVEvVWVrb2xTR3hOTm4yY0JrNDBvUEg2RWtjMmJPcUxPczVZQlJRUXJFSmRkemxZRC9BNGtVS1djU0M0ajVFUWpSbUhoc2N6Qi9sdi9sdWxCa1ltY1pVQm1jOUxtb2trUHVqWWU3UEJPSTdWS2dBclZPMC9BdjZvbllxMFhOdStFQUFBQUFTVVZPUks1Q1lJST1cIikudGhlbihmdW5jdGlvbiAoaSkgeyBUcmVhc3VyZVRyYWlsTG9nZ2VyLmVhc3lDYXNrZXRGaW5kZXJJbWFnZSA9IGkgfSwgZnVuY3Rpb24gKGkpIHsgY29uc29sZS5sb2coXCJDb3VsZCBub3QgbG9hZCB0aGUgZWFzeSBjYXNrZXQgZmluZGVyIGltYWdlLlwiKSB9KTtcbi8vIEExbGliLkltYWdlRGV0ZWN0LmltYWdlRGF0YUZyb21CYXNlNjQoXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ01BQUFBVkNBSUFBQUJEbU1DK0FBQUFBWE5TUjBJQXJzNGM2UUFBQUFSblFVMUJBQUN4and2OFlRVUFBQUFKY0VoWmN3QUFEc01BQUE3REFjZHZxR1FBQUFZMlNVUkJWRWhMVFZYTmp4eEhGYSt1NnVxdjZaNmQvUmhuWm5kRzNsMHZjV3lCZ3cwSUJCRVNjQ0s1SUNHUWNvaFBPVVJJL0FtSUl4Y0VONjRJQklkSWZBZ2xVckFRaXUzSUlNZUoyWkNFV0x1YmxkZHI3ODdzenV6T1YvZDBkVmRWODZ1ZXRlUW5UYW42VmRYN3ZZL2ZlMk5GN1F0S0U2SjFjcmozL2E4dk44NTVxMDAvVGRYMmJ2L0hyNzc0bytzdkVrN1ZjWHI3bjQvK2MrL2d5dFhsMWRYYStscllPWnI4NmEvYlI1MUpHTG05M2pnSW5PWDIwdk9ydFZhejJqNC83L3UyNkUwNng4bnF5NzhqcEFoVzFvbFd6STRXbE5hTTJmbm85RHZYNm5sR0toNGxtanc1bUZMTFByOVFxWEhHSEthTDR2T2Q0Y1BkWWU4MHViaFIxNHBzYmZYVGFWNExuYXRYVzErODFQam1OemErZEtXeHVGZ1JjYmE1ZVhqL2s5NTc3M2YvY1crUEVHS0hOWXNVTm5hMDBGTG0yQ3hGRGxZcko4bFVjZTUvdmpQNmFMTjdvUkdTUk0wN2JtTmw0WU1QSHA5dURVNzd1dUs3My9yYWVpNTF2ZWEwWHppbkoySTBUQis4OTJRVTUzdWRaTDhyUmhsUkpsZEdMR3JCZFVhOGtGS3JJSmFhREMrMTVpcys5VnlHSTZYcGNKUUhBVjFyVmF1UjY0ZEJiNUFOUnVsWHY5SmFiOWZtcWw3enVXcXpXUzJVN25WR3V6dkhPdytPT2ozeHNmZHlmK3ZEU2FyRHdDc0svZTc5V1V4VkMzaHVjNzFReXJZUlhKRWNQUHpwRDE2UVF0VnF6R2JrZEtJbWlYcnRoNWUrKzFLYmNHKy9tMDFpY2I1Vjh4MjcwSHBuKzdqVG5hVERHTGJDbDM0R1RWQ2IvOXN2WGc5OWRqS1dxYUsvZnZOZlowV0NhR1ViLzZtZDV6azNZT1R3Skd2VTJQNWh0alRQcWk1YkRQMTRMSVluazZoU05IeWIrTjc0Tk41K1BPNE54TVA5NGNIaCtIdHYvTXF2emhsYnBjQ3pxWkJSeGZYT0ZFVG1rakVMTWRFOHkvQWRCQUYzWFd3VVlVVkJWcHJPeVZBa1FpM084V21Tb1FiamszanJmMGViSHg3ZXViTi8rODZUemMyajd0SDAraS9mZmhZRzRuc2NNcDdLd1dRNjA5aUFvUWlIVXU0NFNGMmhsWlFLQjQ1TnVuMGhjOVY4TG9nVDlhZ1RmN3Jkdi8xKzUrYTk3cDJQVHYvOXllQ3ozWGljeUlJUWoxTVluWm1ieWEyYnQ5Sk1EU2NDNVJ6RzZabVdNaXlhV0ZiMS9FV0VSWmt0cFlSS2RQWmV1YmE4V0xNZDExNklIRzZ4Zy83WTQvYkMvTHdmVk1xbnhHRWtua3FwOVU5K2M2UDc1REUwYjczMTl2RHVINFhpUW9CeGhuSy92ZkZmRktuUzJtQ01Hc3RhMGZJdFFUMFplcXIwTVU3ejQ0RWN4L0prckFaVGRhNGVYWDYrdXJUQUxVdExFN2s4SGt4N28yU2FtUndBNHc4L3YvNzQzZC8zaGxraWNwaE1jdFdQVFVVZ0JlNUxpWVJwclV4TStBQXhSQ1pkbDQvMmRyNTl1WTVMRlk5WFFpOFRaQzVpbDljcWMxSFFQU0VnZ2xUS2Qxbmt1NW5TTUoybWVTckFLNExxQ2sweVNmNTg4OU1aU3FXMVZxZ0NYRmZJTldZRURTS0ZSQkNMVVlxdXlrY243WG9semZCU1U0c3QxWGllazcxTzJoK29KTldCVCtkQzE2Smtrc3JlTUltbkFqa0JzVVNtbENwU1NmOXlDekF3VENydEx5QlBCdEd5a0Mzb3JHRGxRcDRKYm5QTEJzOFpzaFB2NzN4NXRjcHROL0s1NzNtK1N4aGwxVGwvTG5BeEZGQnpreVVreEpnaDFCUVhCU2R2M254UUtzcFFDZ3d5amppTXZ6SURtT2xjWkMrZHBoZ1lObmRrbnNNUjBMMEVNem1FckMzemF4dmUyb3AvTkZKM1A4dEdNUWxjWnBlTXlySXNWZVNkdTd2bHhhZWhLQU51TVRDYTVRSXc1U0hxeE90dEVCMmNCM0l1Qkhodm9xWDBLWmpBdFZya1ZnSy85TjZJUzlEcDV1dWQrNDlLeFJsR3VUY0NNQ0NWTzFNbnMwR2R3bm96bDlKeE9Qempqa3NaVTFtR3hQS3d0cjkvc0x4VVJVVXpiU083cnVQbzhsa21NbmoyZHdOemhoSFZHeElUQUtlRmhxOW1neUVncFlXTnlSd21SVzc1elhVT0dLbmhDRmdPRlE3UTAwb2JLMml2YXh2MTBDRlhMa1o1UVI0ZVFrZHVQRTBYTUZ5SGc4S283ak54U0dLVkc3TTNNVEZLMExLR0VSaE5ackRqbkorUkFpTUVWNHllMlNhTkczVndMUFQ1N1k4UFpnYnc4MVl1WURTak1ZVEl6ZkFzWlFZMksxVXBzRk5HaVRvQkNRY29sU3JPd3B4Rk5sdGhBcFJFazgzZXpURGN4aXBXWElDejhBWjdKTUR6dmRrOGUxYmdyRUhDQU1vRXM0SXFtZzZsb29ZTE52NGN3VW1zYUJEWU1xdk43T3BDUHVyakpUQzgrVHBPTVU1TTZpa3pETUpMeGxBOHJGQ2FTb1BBREpNYXBrek5KRG9DZTZmZXdvd3JMWnBSTkV2M0xJZWxXd1IveHpoQ243Tlpoc0J2TTQ2TkVpMEJtTExBTm9MRGluT1lQWHRlZGdMcWdJQUlJZjhIeHUrVnBzbWdXRm9BQUFBQVNVVk9SSzVDWUlJPVwiKS50aGVuKGZ1bmN0aW9uIChpKSB7IFRyZWFzdXJlVHJhaWxMb2dnZXIuZWxpdGVDYXNrZXRGaW5kZXJJbWFnZSA9IGkgfSwgZnVuY3Rpb24gKGkpIHsgY29uc29sZS5sb2coXCJDb3VsZCBub3QgbG9hZCB0aGUgZWxpdGUgY2Fza2V0IGZpbmRlciBpbWFnZS5cIikgfSk7XG4vLyBBMWxpYi5JbWFnZURldGVjdC5pbWFnZURhdGFGcm9tQmFzZTY0KGVjdG9wbGFzbWF0b3IpLnRoZW4oZnVuY3Rpb24gKGkpIHsgVHJlYXN1cmVUcmFpbExvZ2dlci5lY3RvSW1nID0gaSB9LCBmdW5jdGlvbiAoaSkgeyBjb25zb2xlLmxvZyhcIkNvdWxkIG5vdCBsb2FkIHRoZSBlY3RvcGxhc21hdG9yIGltYWdlLlwiKSB9KTtcbi8vIEExbGliLkltYWdlRGV0ZWN0LmltYWdlRGF0YUZyb21CYXNlNjQoc2hhcmspLnRoZW4oZnVuY3Rpb24gKGkpIHsgVHJlYXN1cmVUcmFpbExvZ2dlci5zaGFyayA9IGkgfSwgZnVuY3Rpb24gKGkpIHsgY29uc29sZS5sb2coXCJDb3VsZCBub3QgbG9hZCB0aGUgc2hhcmsgaW1hZ2UuXCIpIH0pO1xuLy8gQTFsaWIuSW1hZ2VEZXRlY3QuaW1hZ2VEYXRhRnJvbUJhc2U2NChmb250RGlnaXRzKS50aGVuKGZ1bmN0aW9uIChpKSB7IFRyZWFzdXJlVHJhaWxMb2dnZXIuZm9udERpZ2l0cyA9IGkgfSwgZnVuY3Rpb24gKGkpIHsgY29uc29sZS5sb2coXCJDb3VsZCBub3QgbG9hZCB0aGUgZm9udCBkaWdpdHMgaW1hZ2UuXCIpIH0pO1xuLy8gQTFsaWIuSW1hZ2VEZXRlY3QuaW1hZ2VEYXRhRnJvbUJhc2U2NChmb250RGlnaXRzKS50aGVuKGZ1bmN0aW9uIChpKSB7IGZvbnRJbWFnZSA9IGkgfSwgZnVuY3Rpb24gKGkpIHsgY29uc29sZS5sb2coXCJDb3VsZCBub3QgbG9hZCB0aGUgZm9udCBkaWdpdHMgaW1hZ2UuXCIpIH0pO1xuLy8gQTFsaWIuSW1hZ2VEZXRlY3QuaW1hZ2VEYXRhRnJvbUJhc2U2NChzaGFyaykudGhlbihmdW5jdGlvbiAoaSkgeyBzaGFya0ltYWdlID0gaSB9LCBmdW5jdGlvbiAoaSkgeyBjb25zb2xlLmxvZyhcIkNvdWxkIG5vdCBsb2FkIHRoZSBzaGFyayBpbWFnZS5cIikgfSk7XG4vLyAvLyBsZXQgZm9udCA9IE9DUi5nZW5lcmF0ZWZvbnQoZm9udEltYWdlLCBcIjAxMjM0NTY3ODltKClcIiwgXCJcIiwge30sIDcsIDQsIDAuOSwgdHJ1ZSk7XG4vLyAvLyBJbnZlbnRvcnkgc3BvdCBkaW1lbnNpb25zOiAzOHgzNFxuLy8gZnVuY3Rpb24gVHJlYXN1cmVUcmFpbExvZ2dlcigpIHtcbi8vIFx0dmFyIG1lID0gdGhpcztcbi8vIFx0dGhpcy5maW5kU2hhcmsgPSBmdW5jdGlvbiAoKSB7XG4vLyBcdFx0bGV0IHNjcmVlbkltYWdlID0gQTFsaWIuY2FwdHVyZUhvbGRGdWxsUnMoKTtcbi8vIFx0XHRsZXQgcG9zaXRpb24gPSBzY3JlZW5JbWFnZS5maW5kU3ViaW1hZ2UoVHJlYXN1cmVUcmFpbExvZ2dlci5zaGFyayk7XG4vLyBcdFx0Y29uc29sZS5sb2coXCJzaGFyayBwb3NpdGlvblwiKTtcbi8vIFx0XHRjb25zb2xlLmxvZyhwb3NpdGlvbik7XG4vLyBcdFx0Y29uc29sZS5sb2coXCItLS1cIik7XG4vLyBcdFx0cmV0dXJuIHBvc2l0aW9uO1xuLy8gXHR9XG4vLyBcdHRoaXMudGVzdGluZyA9IGZ1bmN0aW9uICgpIHtcbi8vIFx0XHRsZXQgc2NyZWVuSW1hZ2UgPSBBMWxpYi5jYXB0dXJlSG9sZEZ1bGxScygpO1xuLy8gXHRcdGxldCBwb3NpdGlvbiA9IHNjcmVlbkltYWdlLmZpbmRTdWJpbWFnZShUcmVhc3VyZVRyYWlsTG9nZ2VyLmVjdG9JbWcpO1xuLy8gXHRcdGNvbnNvbGUubG9nKFwiZWN0byBwb3NpdGlvblwiKTtcbi8vIFx0XHRjb25zb2xlLmxvZyhwb3NpdGlvbik7XG4vLyBcdFx0Y29uc29sZS5sb2coXCJAQEBcIik7XG4vLyBcdFx0cmV0dXJuIDA7XG4vLyBcdH1cbi8vIFx0dGhpcy5maW5kRWFzeUNhc2tldHMgPSBmdW5jdGlvbiAoKSB7XG4vLyBcdFx0bGV0IHNjcmVlbkltYWdlID0gQTFsaWIuY2FwdHVyZUhvbGRGdWxsUnMoKTtcbi8vIFx0XHRsZXQgcG9zaXRpb24gPSBzY3JlZW5JbWFnZS5maW5kU3ViaW1hZ2UoVHJlYXN1cmVUcmFpbExvZ2dlci5lYXN5Q2Fza2V0RmluZGVySW1hZ2UpO1xuLy8gXHRcdGNvbnNvbGUubG9nKFwiZWFzeSBwb3NpdGlvblwiKTtcbi8vIFx0XHRjb25zb2xlLmxvZyhwb3NpdGlvbik7XG4vLyBcdFx0Y29uc29sZS5sb2coXCI9PT1cIik7XG4vLyBcdFx0cmV0dXJuIDA7XG4vLyBcdH1cbi8vIFx0dGhpcy5maW5kRWxpdGVDYXNrZXRzID0gZnVuY3Rpb24gKCkge1xuLy8gXHRcdGxldCBzY3JlZW5JbWFnZSA9IEExbGliLmNhcHR1cmVIb2xkRnVsbFJzKCk7XG4vLyBcdFx0bGV0IHBvc2l0aW9uID0gc2NyZWVuSW1hZ2UuZmluZFN1YmltYWdlKFRyZWFzdXJlVHJhaWxMb2dnZXIuZWxpdGVDYXNrZXRGaW5kZXJJbWFnZSk7XG4vLyBcdFx0Y29uc29sZS5sb2coXCJlbGl0ZSBwb3NpdGlvblwiKTtcbi8vIFx0XHRjb25zb2xlLmxvZyhwb3NpdGlvbik7XG4vLyBcdFx0Y29uc29sZS5sb2coXCIjIyNcIik7XG4vLyBcdFx0cmV0dXJuIDA7XG4vLyBcdH1cbi8vIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./index.ts\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});